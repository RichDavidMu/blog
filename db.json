{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/lib/hint/hint.min.css","path":"lib/hint/hint.min.css","modified":0,"renderable":1},{"_id":"source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":0},{"_id":"source/img/bg/nav1.jpg","path":"img/bg/nav1.jpg","modified":0,"renderable":0},{"_id":"source/img/bg/nav4.jpg","path":"img/bg/nav4.jpg","modified":0,"renderable":0},{"_id":"source/img/bg/nav3.jpg","path":"img/bg/nav3.jpg","modified":0,"renderable":0},{"_id":"source/img/bg/nav2.jpg","path":"img/bg/nav2.jpg","modified":0,"renderable":0},{"_id":"source/img/bg/nav5.jpg","path":"img/bg/nav5.jpg","modified":0,"renderable":0},{"_id":"source/img/bg/nav6.jpg","path":"img/bg/nav6.jpg","modified":0,"renderable":0},{"_id":"source/img/blogCovers/blog-post3.jpg","path":"img/blogCovers/blog-post3.jpg","modified":0,"renderable":0},{"_id":"source/img/blogCovers/blog-post1.jpg","path":"img/blogCovers/blog-post1.jpg","modified":0,"renderable":0},{"_id":"source/img/blogCovers/blog-post5.jpg","path":"img/blogCovers/blog-post5.jpg","modified":0,"renderable":0},{"_id":"source/img/blogCovers/blog-post4.jpg","path":"img/blogCovers/blog-post4.jpg","modified":0,"renderable":0},{"_id":"source/img/blogCovers/blog-post6.png","path":"img/blogCovers/blog-post6.png","modified":0,"renderable":0},{"_id":"source/img/blogCovers/js1.jpg","path":"img/blogCovers/js1.jpg","modified":0,"renderable":0},{"_id":"source/img/blogCovers/js2.jpg","path":"img/blogCovers/js2.jpg","modified":0,"renderable":0},{"_id":"source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":0},{"_id":"source/img/blogCovers/blog-post2.png","path":"img/blogCovers/blog-post2.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/Javascript学习笔记.md","hash":"ae2696278957187700381efb787655d01d8c3e04","modified":1641804099736},{"_id":"source/about/index.md","hash":"84c364f7b122bc428b36d8e481df59896034628e","modified":1749530368846},{"_id":"source/img/favicon.jpg","hash":"7aed5a29b82ecd98b4c0a307680f51109890761b","modified":1634482518345},{"_id":"source/img/blogCovers/blog-post3.jpg","hash":"50bcfcfc1fcdff2df692099e064a3d47895c072a","modified":1634977915520},{"_id":"source/img/blogCovers/blog-post1.jpg","hash":"6599bfc75d9806876eeb2a0db2a9f3d53672c03a","modified":1634977929107},{"_id":"source/img/blogCovers/blog-post5.jpg","hash":"328f407de31d624e57f77b6c31db15b95e1a04aa","modified":1634977960618},{"_id":"source/img/blogCovers/blog-post4.jpg","hash":"73047d4e267626bfa6f74ad3da362eca3e194a50","modified":1634977940505},{"_id":"source/img/blogCovers/js1.jpg","hash":"f714f5ed139d2a608d2c733a17b88f464ad96c1b","modified":1634977870644},{"_id":"source/img/blogCovers/js2.jpg","hash":"4d3d3f43a782313b73745b2f179e8866af302eb0","modified":1634977900525},{"_id":"source/img/blogCovers/blog-post6.png","hash":"d5d04479ecffdd8c21ea8e34240021d48121e5a7","modified":1634977950950},{"_id":"source/img/avatar.png","hash":"973acae3678424ac46d08d0fbdac80ddeee52a82","modified":1634483159660},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"source/img/bg/nav4.jpg","hash":"7e74c6ea89648516cbc2da2cd795f6e26c209400","modified":1634481591709},{"_id":"node_modules/hexo-theme-fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"03cfa8e5f149514b57ef80dcb84eb7fea261370d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"df5b54be535593d5442cebafbea34eb9bd69b987","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README_en.md","hash":"ca8fd19a4948de1f253616a62c0e8a7d81f692f5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"cd5cbd070b6190aa0b4839400c0a1581e2654470","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"13a6a799415fc2f6f69ebd1a399fb44426a5d641","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"18f04247801549fe78600c1ee9c601fcbea4cab3","modified":1635760857688},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a0c7984495d4f2d33b64adfa33adebbf768a5ac3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"1a6d415446da11dee5c5f400e7d67544fbe743ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"ad6fed7b646d3ca961db83db0fbe020e3a5d42ad","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"472d0813ca5b88000a7bc6039f33b7e27b5a3216","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"20c2a195a109d2a263b5fa6e79cbcc62932508ad","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"58291dfec65c36889dfce0ddc603540b67e4c598","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"666476260a2cead2cc2928d51977c4a7ba8de6bb","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7f566edf750241e62d7c54abfbb0c504fdab850a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"2a7b49f0f9aecf07550b5a0b99242aab5654cf2b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"1014b901d396f4fc445cb1ffc938d5380d894d71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"79e3679a7069351a6172c281b9d09f59d7580484","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"0ad89eb7c92a822980fa9a85285e6d94ad845d1d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"16d33eb89ecf90f4046720fde5395d972c7ba1fd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"af977ed0792508bb0766ea8afe82d34ef1e8fb3c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/archive-list.ejs","hash":"53a4f6029373a40394a87aba9284696a71610f90","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/beian.ejs","hash":"58b4bbe36386de4305a8da5ffd7d56802df23049","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/css.ejs","hash":"c363829a4b80f74fc1c565e41f6dab41c95006ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/footer.ejs","hash":"a62278c38a310da495d96c39abacacef266945cb","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/head.ejs","hash":"7d0cf31f2595cfe6d5ad31d569654f21a00dfd77","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/nav.ejs","hash":"e71b3c4aa263163597d31b1f91e5a1a877084cfd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/post-meta.ejs","hash":"32a17edadeed40da6db21d2d8031bd47d2fc9bf4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/scripts.ejs","hash":"0ee838b6fcd895d21a29d9d67dbb99b752d623d1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/toc.ejs","hash":"3d2fb5552f373e5a0c56bc356702d807bcbcb411","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"44faef3e77ab08b91e4c5c6f1cd9087a9faff443","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"6c37e9f1ac1d6d00b3c32794e02e244dba942cd9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"cde964c8cd3217268a231de5e018a62c53c2e047","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"3aa5b4ea879cd34d3a32468d88da18d72cbcc8e0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"8e33f915028ac56258f6999d19b1ad8d800cecfe","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"649457796374c79e49a19bd541e4ad8e78fe8995","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"2520c6459b544a4e965b838f8095e2a84390a43c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"4a787cfce27045aa0a92ec22e84f2ccf30cabc4c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"633f0142c657805359b0197f287e12ae4bcde731","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"d058f30bd09b28769c4d8313428ff23dfc8d52dd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"4a43f2700e91937650bef511fd438825b001c4c6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/twikoo.ejs","hash":"1af53bc0be642610a3a4d4e7c05287854a821508","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/utterances.ejs","hash":"e1ed6530dfd7310f91060a75766a93ac3c39be3a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/valine.ejs","hash":"4052ab2a8f78efa92f0fe17abe8f66135943390a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/waline.ejs","hash":"21e00443054802e893aac1f668b69d5bb4b39b3a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/math.ejs","hash":"a7ed1d3079c32497c8955ca75f5fb6992e5ffb8b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"b5fd5a2d9c463eb59318af0f47c591c485b6ad27","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/typed.ejs","hash":"ece659572cf4e12638a1607fca512c25098bbd82","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"28e186c32576eb3d5d923273471a001c47fe8071","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"deed966f38cf0c8dee3f72e5b1f2e878510db0e1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"c1db1a4f9eca6e36b660530641e3a4fb6a30c8d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"63aedd67d90d641cc672540db20ef615f528c9f1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"cd55a2dce6b9d3e165a0a26d0b5bf7f649006bcd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"32fb938d72b2d86159cb315a98b086bd17fa4415","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"616c1f7147078c3d532dd1cfd2af09c0c3a816f0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"d547ab0b91f84eb0acd0bc0c5d716ce17c30361a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/rewrite.styl","hash":"c66e0da2c0d05e76a686a77ab4e74f0d2e89777d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"7e32a3268accf3d524209c213e15e2d5d5e2e1a6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post.styl","hash":"3a6b4f8a29648d9d2c1e99b52a7b42df3f15cf62","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/tag_plugin.styl","hash":"b89b96c8a6a433a6f372b42710554b05cab85a24","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"30f8fab95a5214d79df0ccc02b937df8bd885676","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"9f932ca3f9625c13aa5353f58319881e62c0c653","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"0ce7552dc4993926426019398d73e817cfd841a1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"d8011325756eb6e4ce619b3e7b4d6d80c2de8a57","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"55e10a6965462f8f62f85e75fd5e143af02a4b44","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":499162500000},{"_id":"source/img/bg/nav2.jpg","hash":"36ecf31be3bad17908f260ed84c7e1b1e502664d","modified":1634481624455},{"_id":"source/img/bg/nav1.jpg","hash":"7841316dd7f8b19e3842c194d8723455d1bcfde6","modified":1634481640716},{"_id":"source/img/bg/nav6.jpg","hash":"8ace282145a2045e36229a0d27e45d90445828da","modified":1634482054150},{"_id":"source/img/bg/nav5.jpg","hash":"e9b8d941fde52c4b11ae98f8c9494b7b2785a6d9","modified":1634481734419},{"_id":"source/img/bg/nav3.jpg","hash":"d217bbe85b853adf4e8f869f10788399953c56cf","modified":1634481728736},{"_id":"public/local-search.xml","hash":"508392c61fea936a92eb1053b255799ae8a43706","modified":1749530466741},{"_id":"public/about/index.html","hash":"a212b14cfb2874b170d1d3faf02b9fe0b9d32513","modified":1749530466741},{"_id":"public/archives/index.html","hash":"f69ac5399fcde0be1f76f29a4fcfcf7687d47ac8","modified":1749530466741},{"_id":"public/archives/2020/index.html","hash":"fbe280bdab02e93095bc58893eb38b3605761fdf","modified":1749530466741},{"_id":"public/archives/2020/02/index.html","hash":"3f6c17da52c37453d2ad14655a43d62a9fe8d5e6","modified":1749530466741},{"_id":"public/categories/学习笔记/index.html","hash":"1b83abe1a6fe1903a999f22114c611741da9e0a0","modified":1749530466741},{"_id":"public/tags/JavaScript/index.html","hash":"2f9e81509566a364a4db8512146496a36245cf07","modified":1749530466741},{"_id":"public/index.html","hash":"f227026c9af56c8e08443518522503d6698cb722","modified":1749530466741},{"_id":"public/404.html","hash":"487d61b9fcb90d93508a5eed5cce91cf637441d9","modified":1749530466741},{"_id":"public/tags/index.html","hash":"70e1ecaa55fe2b8ea1c2f8fcf025c2c6e13c5443","modified":1749530466741},{"_id":"public/categories/index.html","hash":"1f9a8ee6fa5aded16bdd15eb8f2ac9b7e9b08461","modified":1749530466741},{"_id":"public/links/index.html","hash":"c4633a9626fe615b71d9db8341f69b57fae8c613","modified":1749530466741},{"_id":"public/2020/02/11/Javascript学习笔记/index.html","hash":"4aae5e4b2296e3621efda10e93a31e18f1c8e724","modified":1749530466741},{"_id":"public/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1749530466741},{"_id":"public/img/favicon.png","hash":"973acae3678424ac46d08d0fbdac80ddeee52a82","modified":1749530466741},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1749530466741},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1749530466741},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1749530466741},{"_id":"public/img/favicon.jpg","hash":"7aed5a29b82ecd98b4c0a307680f51109890761b","modified":1635760964210},{"_id":"public/img/blogCovers/blog-post3.jpg","hash":"50bcfcfc1fcdff2df692099e064a3d47895c072a","modified":1749530466741},{"_id":"public/img/blogCovers/blog-post1.jpg","hash":"6599bfc75d9806876eeb2a0db2a9f3d53672c03a","modified":1749530466741},{"_id":"public/img/blogCovers/blog-post5.jpg","hash":"328f407de31d624e57f77b6c31db15b95e1a04aa","modified":1749530466741},{"_id":"public/img/blogCovers/blog-post4.jpg","hash":"73047d4e267626bfa6f74ad3da362eca3e194a50","modified":1749530466741},{"_id":"public/img/blogCovers/js1.jpg","hash":"f714f5ed139d2a608d2c733a17b88f464ad96c1b","modified":1749530466741},{"_id":"public/img/blogCovers/js2.jpg","hash":"4d3d3f43a782313b73745b2f179e8866af302eb0","modified":1749530466741},{"_id":"public/img/blogCovers/blog-post6.png","hash":"d5d04479ecffdd8c21ea8e34240021d48121e5a7","modified":1749530466741},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1749530466741},{"_id":"public/js/color-schema.js","hash":"2520c6459b544a4e965b838f8095e2a84390a43c","modified":1749530466741},{"_id":"public/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":1749530466741},{"_id":"public/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":1749530466741},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1749530466741},{"_id":"public/js/leancloud.js","hash":"4a787cfce27045aa0a92ec22e84f2ccf30cabc4c","modified":1749530466741},{"_id":"public/js/local-search.js","hash":"633f0142c657805359b0197f287e12ae4bcde731","modified":1749530466741},{"_id":"public/js/plugins.js","hash":"d058f30bd09b28769c4d8313428ff23dfc8d52dd","modified":1749530466741},{"_id":"public/js/utils.js","hash":"4a43f2700e91937650bef511fd438825b001c4c6","modified":1749530466741},{"_id":"public/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1749530466741},{"_id":"public/css/main.css","hash":"80b7c3dc3f47db8b700b4437bdf45706fe504f66","modified":1749530466741},{"_id":"public/img/avatar.png","hash":"973acae3678424ac46d08d0fbdac80ddeee52a82","modified":1749530466741},{"_id":"public/img/bg/nav4.jpg","hash":"7e74c6ea89648516cbc2da2cd795f6e26c209400","modified":1749530466741},{"_id":"public/img/bg/nav2.jpg","hash":"36ecf31be3bad17908f260ed84c7e1b1e502664d","modified":1749530466741},{"_id":"public/img/bg/nav1.jpg","hash":"7841316dd7f8b19e3842c194d8723455d1bcfde6","modified":1749530466741},{"_id":"public/img/bg/nav6.jpg","hash":"8ace282145a2045e36229a0d27e45d90445828da","modified":1749530466741},{"_id":"public/img/bg/nav5.jpg","hash":"e9b8d941fde52c4b11ae98f8c9494b7b2785a6d9","modified":1749530466741},{"_id":"public/img/bg/nav3.jpg","hash":"d217bbe85b853adf4e8f869f10788399953c56cf","modified":1749530466741},{"_id":"source/_posts/Javascript学习笔记二.md","hash":"7acdf81fdf676289d88e3d603fb0e4c2e0dcd096","modified":1641804099736},{"_id":"source/_posts/eventLoop理解.md","hash":"d53a2610ba048d90df7e81bd60d3830ff3ed4eda","modified":1641804099737},{"_id":"source/_posts/promise详解.md","hash":"5c886f8a25b76da61cff745ed6ee7ab95c53b7dd","modified":1641804099737},{"_id":"source/_posts/vue实战踩坑-防盗链.md","hash":"b74d97cadd09a3a091939b2c8936d9eecd1a664b","modified":1641804099737},{"_id":"source/_posts/vue实战-博客系统.md","hash":"b270203d2d7238293b6e9a97224ecb39930a8b1b","modified":1642910454275},{"_id":"source/_posts/howTransformBabelAst.md","hash":"90a8ba810e14ecc55678b5bdef4549bb9a80ba40","modified":1749530368845},{"_id":"source/_posts/vue实战-知乎日报.md","hash":"dd86ad5aa94439fcd2937f8984c0eb5ec593dc35","modified":1642910454275},{"_id":"source/_posts/同源限制理解与解决.md","hash":"4699be4f06aac2423bb84ff25c3262587586c3e6","modified":1641804099737},{"_id":"source/_posts/howBabelWork_parser.md","hash":"875e31985dd6be382503a7573302f6d29f8857d0","modified":1749530368845},{"_id":"source/img/blogCovers/blog-post2.png","hash":"06d7571d7c2138c1fa0bd80dd086a3d94dd140d8","modified":1641804099792},{"_id":"source/img/blogCovers/babel.svg","hash":"7a197cfe44548cc1a3f581152af70a3051e11671","modified":1641804644752},{"_id":"source/img/favicon.png","hash":"973acae3678424ac46d08d0fbdac80ddeee52a82","modified":1641804099794},{"_id":"public/baidu_urls.txt","hash":"1478da255580d67a47160ed53f4351306c7a9c38","modified":1749530466741},{"_id":"public/categories/源码解读/index.html","hash":"cbb45cdddf3f6353cef3578e61ac0fd814dcf152","modified":1749530466741},{"_id":"public/categories/项目实战/index.html","hash":"e0f8da0d60753d3ea4e72f208129984f7c73b3b3","modified":1749530466741},{"_id":"public/archives/2020/03/index.html","hash":"eca70add70c0100084fbdc7dc6df39d3f128d6f3","modified":1749530466741},{"_id":"public/archives/2020/04/index.html","hash":"885f215fceae99f6f87a5d064b1dc06580c638f8","modified":1749530466741},{"_id":"public/archives/2021/index.html","hash":"db6dde137549415dfae66a61f8d5e24ec260ff61","modified":1749530466741},{"_id":"public/archives/2021/04/index.html","hash":"e352bd34c01ebd90f0dde9f235f6785ad798dbaf","modified":1749530466741},{"_id":"public/tags/异步编程/index.html","hash":"996a7b3d67fb96f338c021aa3e5109dad9790a3f","modified":1749530466741},{"_id":"public/tags/Babel/index.html","hash":"29e81fd9c5b9ee984d0c08135ab3935a30a1cd62","modified":1749530466741},{"_id":"public/tags/前端工程化/index.html","hash":"8ef78a54209419ea525801138573583931dfc416","modified":1749530466741},{"_id":"public/tags/Vue/index.html","hash":"fae6ff9286b6ac412f75f5686c3bf119f325e0ab","modified":1749530466741},{"_id":"public/tags/Webpack/index.html","hash":"b2c7374c3e820a1136b4699b3a3dfdbb7b181423","modified":1749530466741},{"_id":"public/tags/http/index.html","hash":"860988e0ef5852dd57a5ce7f76c09aa452c9b23a","modified":1749530466741},{"_id":"public/tags/NodeJs/index.html","hash":"395edb771002d224224b78e22ab479c172ac1b08","modified":1749530466741},{"_id":"public/tags/浏览器/index.html","hash":"4778664aee654ad0ad94211484a8b3093cc7acce","modified":1749530466741},{"_id":"public/2021/04/09/howTransformBabelAst/index.html","hash":"896dc8b4e356a56f5d176b69c4cecdf58f3224e1","modified":1749530466741},{"_id":"public/2021/04/01/howBabelWork_parser/index.html","hash":"3d3192ae14e01bbafb6e38fcf19a954a7fef9aa4","modified":1749530466741},{"_id":"public/2020/04/19/vue实战-博客系统/index.html","hash":"05e3742acbf042f8c7f6c46dc3b26e8b99576fe7","modified":1749530466741},{"_id":"public/2020/04/01/eventLoop理解/index.html","hash":"2c55be3001d8b45a766bee0b810772b1ca585a18","modified":1749530466741},{"_id":"public/2020/03/28/vue实战踩坑-防盗链/index.html","hash":"578fbcd1b6d821e45bd952cdbc05b409438e5872","modified":1749530466741},{"_id":"public/2020/03/22/vue实战-知乎日报/index.html","hash":"f2105a02a77d334da40bffcc6094b42e9c8e166d","modified":1749530466741},{"_id":"public/2020/03/10/promise详解/index.html","hash":"edf405b2bc63869dbcf256e772332a70915d8576","modified":1749530466741},{"_id":"public/2020/03/02/同源限制理解与解决/index.html","hash":"b2a85676428cb327df84cb6f2dceeb96503ebd46","modified":1749530466741},{"_id":"public/2020/02/12/Javascript学习笔记二/index.html","hash":"3fc5eaeb1e9e2b978047c2cc1aa105e6fe48f62b","modified":1749530466741},{"_id":"public/img/blogCovers/babel.svg","hash":"7a197cfe44548cc1a3f581152af70a3051e11671","modified":1642752806533},{"_id":"public/img/blogCovers/blog-post2.png","hash":"06d7571d7c2138c1fa0bd80dd086a3d94dd140d8","modified":1749530466741},{"_id":"public/baidusitemap.xml","hash":"6f264faeac22f3da5e7fcdc611df6c255b5c3700","modified":1749530466741},{"_id":"public/sitemap.xml","hash":"532da9ce9c15a7ced4db99cf098d3aa31663a5c9","modified":1749530466741},{"_id":"source/_posts/Hexo博客使用Github自动部署到个人服务器.md","hash":"e015266cc9425b7809eec27df7b0cdebc17bd16d","modified":1749530368844},{"_id":"source/_posts/useSelector是如何触发更新的以及手写一个简单的useSelector.md","hash":"cbf0885b0c56b888d7abffd71ff67efbafb7c090","modified":1749530368845},{"_id":"public/2022/02/10/Hexo博客使用Github自动部署到个人服务器/index.html","hash":"284d3fdedaaf31650f5de474d5c507a952119f1e","modified":1749530466741},{"_id":"public/2022/02/15/useSelector是如何触发更新的以及手写一个简单的useSelector/index.html","hash":"c1c416a80938e77d590e6019a61292319450413b","modified":1749530466741},{"_id":"public/categories/CI-CD/index.html","hash":"9e9178cc2447a25f5f8b22ab73207432243b9b67","modified":1749530466741},{"_id":"public/archives/page/2/index.html","hash":"dfe0742258071e8828fe24ea1c27d73df2d89219","modified":1749530466741},{"_id":"public/archives/2022/index.html","hash":"48bb3d735d197c3e312880ce38f2df04b3472207","modified":1749530466741},{"_id":"public/archives/2022/02/index.html","hash":"3c8a239f81fc4f8e0565697072a8e4b4fe538926","modified":1749530466741},{"_id":"public/page/2/index.html","hash":"d6a7dc8f8aa605bf4a536db99b49f268751fc09f","modified":1749530466741},{"_id":"public/tags/hexo/index.html","hash":"c8ee4f4ec157bc3083f4fc6a96772210e6016fe8","modified":1749530466741},{"_id":"public/tags/redux/index.html","hash":"37468de625f7f900fc58ed4297c922ed81d73abf","modified":1749530466741}],"Category":[{"name":"学习笔记","_id":"ckv5ff35w0002xgep6dqgdmdf"},{"name":"源码解读","_id":"ckyo4lu6o0007nz69hfpn4go2"},{"name":"项目实战","_id":"ckyo4lu6s000inz69dhnu091e"},{"name":"CI/CD","_id":"ckzgq58re0001o9691t7x1mqq"}],"Data":[],"Page":[{"title":"about","date":"2021-10-17T14:03:14.000Z","layout":"about","_content":"年更博客，写博客是想空闲时间记录一些学习心得，因为用自己思路写的东西，再去回头看会省去很多理解的时间。\n\n如果你能在这里有所收获，那我荣幸之至，想和我交流，可以在每一篇文章下面留言。\n\n技术上目前涉足JavaScript/React/Pixi等。\n\n博客主题来自[Fluid](https://github.com/fluid-dev/hexo-theme-fluid)主题，非常感谢制作者的分享，希望自己以后也能设计出这么美的主题。","source":"about/index.md","raw":"---\ntitle: about\ndate: 2021-10-17 22:03:14\nlayout: about\n---\n年更博客，写博客是想空闲时间记录一些学习心得，因为用自己思路写的东西，再去回头看会省去很多理解的时间。\n\n如果你能在这里有所收获，那我荣幸之至，想和我交流，可以在每一篇文章下面留言。\n\n技术上目前涉足JavaScript/React/Pixi等。\n\n博客主题来自[Fluid](https://github.com/fluid-dev/hexo-theme-fluid)主题，非常感谢制作者的分享，希望自己以后也能设计出这么美的主题。","updated":"2025-06-10T04:39:28.846Z","path":"about/index.html","_id":"ckv5ff35p0000xgep040f6ezj","comments":1,"content":"<p>年更博客，写博客是想空闲时间记录一些学习心得，因为用自己思路写的东西，再去回头看会省去很多理解的时间。</p>\n<p>如果你能在这里有所收获，那我荣幸之至，想和我交流，可以在每一篇文章下面留言。</p>\n<p>技术上目前涉足JavaScript/React/Pixi等。</p>\n<p>博客主题来自<a href=\"https://github.com/fluid-dev/hexo-theme-fluid\">Fluid</a>主题，非常感谢制作者的分享，希望自己以后也能设计出这么美的主题。</p>\n","site":{"data":{}},"wordcount":162,"excerpt":"","more":"<p>年更博客，写博客是想空闲时间记录一些学习心得，因为用自己思路写的东西，再去回头看会省去很多理解的时间。</p>\n<p>如果你能在这里有所收获，那我荣幸之至，想和我交流，可以在每一篇文章下面留言。</p>\n<p>技术上目前涉足JavaScript/React/Pixi等。</p>\n<p>博客主题来自<a href=\"https://github.com/fluid-dev/hexo-theme-fluid\">Fluid</a>主题，非常感谢制作者的分享，希望自己以后也能设计出这么美的主题。</p>\n"}],"Post":[{"title":"Javascript学习笔记一","date":"2020-02-11T08:26:09.000Z","index_img":"/img/blogCovers/js1.jpg","_content":"\n打算把最近学习的JavaScript写个博客整理记录一下，学习方式是《JavaScript语言精粹》这本书和[廖雪峰的博客](https://www.liaoxuefeng.com/wiki/1022910821149312)，不太明白的地方会去看《JavaScript权威指南》、[JavaScript|MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript)和[W3School](https://www.w3school.com.cn/js/index.asp)。\n## 数据类型\nJavaScript 变量能够保存多种数据类型：数值、字符串值、数组、对象等等：\n### Numbers\nJavaScript只有一种数字类型，不区分整型与浮点型，存储方式使用64位浮点数，1和1.0的值是相同的。\n```javascript\n123; // 整数123\n0.456; // 浮点数0.456\n1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5\n-99; // 负数\nNaN; // NaN表示Not a Number，当无法计算结果时用NaN表示，可以用isNaN检测NaN\nInfinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity\n```\n可以操作数字的方法 \n- 五个number方法 [查看](https://www.w3school.com.cn/js/js_number_methods.asp)\n\t* 将数字以字符串返回：`number.toString(radix)`,`radix`控制进制，默认十进制。\n\t* 将number转换为一个十进制形式的字符串，保留`fractionDigits`位小数（多余的四舍五入）：`number.toFixed(fractionDigits)`\n\t* 将number转换成为一个指数形式的字符串，保留`fractionDigits`位小数（多余的四舍五入）`number.toExponential（fractionDigits）`\n\t* 将number转换为一个十进制形式的字符串，保留`precision`个有效数字（多余的四舍五入）：`number.toPrecision(precision)`\n- 三个全局方法 [查看](https://www.w3school.com.cn/js/js_number_methods.asp)\n  * 可以将x转换为数字，x为任意JavaScript变量（日期，布尔值等）：`Number(x)`\n  * 解析一段字符串并返回整型数值（向下取整）。允许空格。只返回首个数字： `parseInt(string)`\n  * 解析一段字符串并返回数值。允许空格。只返回首个数字：`parseFloat(string)`\n- math对象方法执行数学数学任务 [查看](https://www.w3school.com.cn/js/js_math.asp)\n  * 返回x的四舍五入：`Math.round(x)`\n  * 返回x的y次幂：`Math.pow(x,y)`\n  * 返回x的平方根：`Math.sqrt(x)`\n  * 返回x的绝对值：`Math.abs(x)`\n  * x向上取整：`Math.ceil(x)`，x向下取整：`Math.floor(x)`\n  * x正弦余弦：`Math.sin(x)` , `Math.cos(x)`\n  * 最大最小值：`Math.min(1,,2,3,4) //1` ，`Math.max(1,2,3,4) //4`,[用于数组](https://www.cnblogs.com/lguow/p/9725258.html)\n  * 返回一个0-1的随机数：`Math.random()`，更多[随机数trick](https://www.w3school.com.cn/js/js_random.asp)\n\n### Strings\nJavaScript的字符串就是用`' '`或`\" \"`括起来的字符\n例：\n```javascript\n'I\\'m \\\"OK\\\"!';\n```\n含义`I'm \"OK\"!`\n>字符串一旦创建就不能改变，可以使用字符串方法操作返回新的字符串\n\n`\\`是转义字符 \n\n```javascript\n'A' === '\\u0041'; //true\n```\nstring有`length`属性\n```javascript\n'seven'.length; //5\n```\n可以用`+`号连接其他字符串来创建一个新的字符串\n```javascript\n'c'+'a'+'t' ==='cat'; //true\n```\nstring拥有方法 [查看](https://www.w3school.com.cn/js/js_string_methods.asp)\n\n+ 查找：`string.indexOf(searchString,position)` , `string.lastIndexOf(seachString,position)` , `string.search(regexp)`.\n`searchString`要搜索的字符串，`position`开始搜索的位置，`regexp`正则表达式对象，以number返回位置\n\n\t>  两种方法，`string.indexOf()` 与 `string.search()`，是相等的。\n\t> \n\t> 这两种方法是不相等的。区别在于：\n\t> \n\t> `string.search()` 方法无法设置第二个开始位置参数。 `string.indexOf()` 方法无法设置更强大的搜索值（正则表达式）。\n+ 提取字符：`string.charAt(position)` 方法返回字符串中指定下标（位置）的字符串。\n`string.charCodeAt(position)`方法返回字符串中指定索引的字符 unicode 编码，常用此方法建造哈希表，相反`string.fromCharCode(charCode...)`根据编码返回字符串\n\n\t>ECMAScript 5 (2009) 允许对字符串的属性访问 `[ ]`，如`str[0]`\n\t>用属性访问有点不太靠谱：\n\t> \n\t> 不适用 Internet Explorer 7 或更早的版本 它让字符串看起来像是数组（其实并不\t是） 如果找不到字符，`[ ]` 返回 `undefined`，而 `charAt()` 返回空字符串。 \n\t> 它是只读的。`str[0] = \"A\"` 不会产生错误（但也不会工作！）\n\t> 如果您希望按照数组的方式处理字符串，可以先把它转换为数组。\n+ 把字符串转换为数组：`string.split(separator,limit)`\n以`separator`分割，改参数可以是字符串或正则表达式，`limit`限制被分割的片段数量，返回元素为字符串的数组。\n+ 提取字符串：`string.slice(start, end)`，`string.substring(start, end)`，`string.substr(start, length)`\n`start`**开始**提取位置，`end`**最后**一个字符的位置，如果为负数则与`string.length`相加，即倒数位置，`length`要提取的字符串**长度**。\n不改变原字符串，将提取结果以新字符串返回。\n\n\t> `substring()` 类似于 `slice()`。不同之处在于 `substring()` 无法接受负的索引。\n\t> `substr()` 类似于 `slice()`。不同之处在于第二个参数规定被提取部分的长度。\n+ 替换：`replace(seachValue,replaceValue)`\n`seachValue`可以是**字符串**或**正则表达式**，`replaceValue`可以是**字符串**或一个**函数**。\n当`replaceValue`是一个**字符串**，字符`$`拥有特别含义：\n\n\t```javascript\n\tvar oldareacode = /\\((\\d{3})\\)/g;\n\tvar p = '(555)666-1212'.replace(oldareacode,'$1-');\n\t//p 是 '555-666-1212'\n\t```\n\t美元符号序列 |替换对象\n\t----|-----\n\t$`$$`|$\n\t$`$&`|整个匹配文本\n\t$`$number`|分组捕获的文本\n\t$``$` ``|匹配之前的文本\n\t$`$'`|匹配之后的文本\n\n\t如果`replaceValue`是一个**函数**，那么每次遇到一次匹配函数就会调用一次，该函数返回的字符串用作替换文本，在下一个参数是分组2捕获的文本、\n\t\n\n\t```javascript\n\tvar old = 'hello World';\n\tvar p = old.replace('hello',function (c){\n    \tconsole.log(c);//hello\n    \treturn 'Hello'    \n\t\t})\n\tconsole.log(p);//Hello World\n\t```\n\n\t>`replace()` 只替换首个匹配\n\t>默认地，`replace()` 对大小写敏感。\n\t>如需执行大小写不敏感的替换，请使用正则表达式 `/i`,请注意正则表达式不带引号。如：`replace(/he/i,'she')`\n\t>如需替换所有匹配，请使用正则表达式的 `/g` 标志（用于全局搜索)。如：`replace(/he/g,'she')`\n+ 转换大小写：`toUpperCase()`,`toLowerCase()`\n+ 连接字符串：`concat()`与`+`等效\n+ 删除字符串两端的空白符：`String.trim()`\n\t> Internet Explorer 8 或更低版本不支持 `trim()` 方法。\n\t> 如需支持 IE 8，您可搭配正则表达式使用 `replace()` 方法代替：\n\t> `str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '')`; \n+ 匹配：`string.match(regexp)`方法让字符串与一个正则表达式匹配。根据g表示来决定如何匹配，如果没有`g`表示，那么结果与`regexp.exec(string)`的结果相同。否则会生成包含所有匹配的数组。\n\n#### 多行字符串和模板字符串\nES6语法\n\n```javascript\n`这是一个\n多行\n字符串`;\n```\n\n```javascript\nvar name = '小明';\nvar age = 20;\nvar message = `你好, ${name}, 你今年${age}岁了!`;\nmessage === '你好,小明,你今年20岁了'; //true\n```\n### boolean\n布尔值只有`true`和`false`\n```javascript\ntrue; // 这是一个true值\nfalse; // 这是一个false值\n2 > 1; // 这是一个true值\n2 >= 3; // 这是一个false值\n```\n几个tips\n+ `NaN`这个特殊的Number与所有其他值都不相等，包括它自己\n```javascript\nNaN === NaN; // false\n```\n+ 唯一能判断`NaN`的方法是通过`isNaN()`函数：\n\n```javascript\nisNaN(NaN); // true\n```\n\n+ 最后要注意浮点数的相等比较：\n\n```javascript\n1 / 3 === (1 - 2 / 3); // false\n```\n\n> 这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：\n\n```javascript\nMath.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true\n```\n### null和undefined\n`null`表示一个“空”的值\n`undefined`表示值未定义\n\n> JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。\n\n### 数组\n数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。\n\n```javascript\nvar misc = [1, 2, 3.14, 'Hello', null, true，['',''],{'':''}];\nmisc.length  //8\nmisc[0] //1\nmisc[8] //undefined\n```\n与大多数其他语言不同，JavaScript的数组没有上界\n```javascript\nvar myArray = [1,2,3,4,5];\nmyArray.length; // 5\nmyArray[10000] = true;\nmyArray.length; //10001\nmyArray.length = 3;//myArray是['1','2','3']\n```\n数组专题\n数组拥有方法 [查看](https://www.w3school.com.cn/js/js_array_methods.asp)\n数组的排序 [查看](https://www.w3school.com.cn/js/js_array_sort.asp)\n 数组的遍历 [查看](https://www.w3school.com.cn/js/js_array_iteration.asp)\n\n### 对象\nJavaScript的对象是一组由键-值组成的无序集合，例如：\n\n```javascript\nvar person = {\n    name: 'Bob',\n    age: 20,\n    tags: ['js', 'web', 'mobile'],\n    city: 'Beijing',\n    hasCar: true,\n    zipcode: null\n};\n```\n\n\n","source":"_posts/Javascript学习笔记.md","raw":"---\ntitle: Javascript学习笔记一\ndate: 2020-02-11 16:26:09\nindex_img: /img/blogCovers/js1.jpg\ntags: [JavaScript]\ncategories: [学习笔记]\n---\n\n打算把最近学习的JavaScript写个博客整理记录一下，学习方式是《JavaScript语言精粹》这本书和[廖雪峰的博客](https://www.liaoxuefeng.com/wiki/1022910821149312)，不太明白的地方会去看《JavaScript权威指南》、[JavaScript|MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript)和[W3School](https://www.w3school.com.cn/js/index.asp)。\n## 数据类型\nJavaScript 变量能够保存多种数据类型：数值、字符串值、数组、对象等等：\n### Numbers\nJavaScript只有一种数字类型，不区分整型与浮点型，存储方式使用64位浮点数，1和1.0的值是相同的。\n```javascript\n123; // 整数123\n0.456; // 浮点数0.456\n1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5\n-99; // 负数\nNaN; // NaN表示Not a Number，当无法计算结果时用NaN表示，可以用isNaN检测NaN\nInfinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity\n```\n可以操作数字的方法 \n- 五个number方法 [查看](https://www.w3school.com.cn/js/js_number_methods.asp)\n\t* 将数字以字符串返回：`number.toString(radix)`,`radix`控制进制，默认十进制。\n\t* 将number转换为一个十进制形式的字符串，保留`fractionDigits`位小数（多余的四舍五入）：`number.toFixed(fractionDigits)`\n\t* 将number转换成为一个指数形式的字符串，保留`fractionDigits`位小数（多余的四舍五入）`number.toExponential（fractionDigits）`\n\t* 将number转换为一个十进制形式的字符串，保留`precision`个有效数字（多余的四舍五入）：`number.toPrecision(precision)`\n- 三个全局方法 [查看](https://www.w3school.com.cn/js/js_number_methods.asp)\n  * 可以将x转换为数字，x为任意JavaScript变量（日期，布尔值等）：`Number(x)`\n  * 解析一段字符串并返回整型数值（向下取整）。允许空格。只返回首个数字： `parseInt(string)`\n  * 解析一段字符串并返回数值。允许空格。只返回首个数字：`parseFloat(string)`\n- math对象方法执行数学数学任务 [查看](https://www.w3school.com.cn/js/js_math.asp)\n  * 返回x的四舍五入：`Math.round(x)`\n  * 返回x的y次幂：`Math.pow(x,y)`\n  * 返回x的平方根：`Math.sqrt(x)`\n  * 返回x的绝对值：`Math.abs(x)`\n  * x向上取整：`Math.ceil(x)`，x向下取整：`Math.floor(x)`\n  * x正弦余弦：`Math.sin(x)` , `Math.cos(x)`\n  * 最大最小值：`Math.min(1,,2,3,4) //1` ，`Math.max(1,2,3,4) //4`,[用于数组](https://www.cnblogs.com/lguow/p/9725258.html)\n  * 返回一个0-1的随机数：`Math.random()`，更多[随机数trick](https://www.w3school.com.cn/js/js_random.asp)\n\n### Strings\nJavaScript的字符串就是用`' '`或`\" \"`括起来的字符\n例：\n```javascript\n'I\\'m \\\"OK\\\"!';\n```\n含义`I'm \"OK\"!`\n>字符串一旦创建就不能改变，可以使用字符串方法操作返回新的字符串\n\n`\\`是转义字符 \n\n```javascript\n'A' === '\\u0041'; //true\n```\nstring有`length`属性\n```javascript\n'seven'.length; //5\n```\n可以用`+`号连接其他字符串来创建一个新的字符串\n```javascript\n'c'+'a'+'t' ==='cat'; //true\n```\nstring拥有方法 [查看](https://www.w3school.com.cn/js/js_string_methods.asp)\n\n+ 查找：`string.indexOf(searchString,position)` , `string.lastIndexOf(seachString,position)` , `string.search(regexp)`.\n`searchString`要搜索的字符串，`position`开始搜索的位置，`regexp`正则表达式对象，以number返回位置\n\n\t>  两种方法，`string.indexOf()` 与 `string.search()`，是相等的。\n\t> \n\t> 这两种方法是不相等的。区别在于：\n\t> \n\t> `string.search()` 方法无法设置第二个开始位置参数。 `string.indexOf()` 方法无法设置更强大的搜索值（正则表达式）。\n+ 提取字符：`string.charAt(position)` 方法返回字符串中指定下标（位置）的字符串。\n`string.charCodeAt(position)`方法返回字符串中指定索引的字符 unicode 编码，常用此方法建造哈希表，相反`string.fromCharCode(charCode...)`根据编码返回字符串\n\n\t>ECMAScript 5 (2009) 允许对字符串的属性访问 `[ ]`，如`str[0]`\n\t>用属性访问有点不太靠谱：\n\t> \n\t> 不适用 Internet Explorer 7 或更早的版本 它让字符串看起来像是数组（其实并不\t是） 如果找不到字符，`[ ]` 返回 `undefined`，而 `charAt()` 返回空字符串。 \n\t> 它是只读的。`str[0] = \"A\"` 不会产生错误（但也不会工作！）\n\t> 如果您希望按照数组的方式处理字符串，可以先把它转换为数组。\n+ 把字符串转换为数组：`string.split(separator,limit)`\n以`separator`分割，改参数可以是字符串或正则表达式，`limit`限制被分割的片段数量，返回元素为字符串的数组。\n+ 提取字符串：`string.slice(start, end)`，`string.substring(start, end)`，`string.substr(start, length)`\n`start`**开始**提取位置，`end`**最后**一个字符的位置，如果为负数则与`string.length`相加，即倒数位置，`length`要提取的字符串**长度**。\n不改变原字符串，将提取结果以新字符串返回。\n\n\t> `substring()` 类似于 `slice()`。不同之处在于 `substring()` 无法接受负的索引。\n\t> `substr()` 类似于 `slice()`。不同之处在于第二个参数规定被提取部分的长度。\n+ 替换：`replace(seachValue,replaceValue)`\n`seachValue`可以是**字符串**或**正则表达式**，`replaceValue`可以是**字符串**或一个**函数**。\n当`replaceValue`是一个**字符串**，字符`$`拥有特别含义：\n\n\t```javascript\n\tvar oldareacode = /\\((\\d{3})\\)/g;\n\tvar p = '(555)666-1212'.replace(oldareacode,'$1-');\n\t//p 是 '555-666-1212'\n\t```\n\t美元符号序列 |替换对象\n\t----|-----\n\t$`$$`|$\n\t$`$&`|整个匹配文本\n\t$`$number`|分组捕获的文本\n\t$``$` ``|匹配之前的文本\n\t$`$'`|匹配之后的文本\n\n\t如果`replaceValue`是一个**函数**，那么每次遇到一次匹配函数就会调用一次，该函数返回的字符串用作替换文本，在下一个参数是分组2捕获的文本、\n\t\n\n\t```javascript\n\tvar old = 'hello World';\n\tvar p = old.replace('hello',function (c){\n    \tconsole.log(c);//hello\n    \treturn 'Hello'    \n\t\t})\n\tconsole.log(p);//Hello World\n\t```\n\n\t>`replace()` 只替换首个匹配\n\t>默认地，`replace()` 对大小写敏感。\n\t>如需执行大小写不敏感的替换，请使用正则表达式 `/i`,请注意正则表达式不带引号。如：`replace(/he/i,'she')`\n\t>如需替换所有匹配，请使用正则表达式的 `/g` 标志（用于全局搜索)。如：`replace(/he/g,'she')`\n+ 转换大小写：`toUpperCase()`,`toLowerCase()`\n+ 连接字符串：`concat()`与`+`等效\n+ 删除字符串两端的空白符：`String.trim()`\n\t> Internet Explorer 8 或更低版本不支持 `trim()` 方法。\n\t> 如需支持 IE 8，您可搭配正则表达式使用 `replace()` 方法代替：\n\t> `str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '')`; \n+ 匹配：`string.match(regexp)`方法让字符串与一个正则表达式匹配。根据g表示来决定如何匹配，如果没有`g`表示，那么结果与`regexp.exec(string)`的结果相同。否则会生成包含所有匹配的数组。\n\n#### 多行字符串和模板字符串\nES6语法\n\n```javascript\n`这是一个\n多行\n字符串`;\n```\n\n```javascript\nvar name = '小明';\nvar age = 20;\nvar message = `你好, ${name}, 你今年${age}岁了!`;\nmessage === '你好,小明,你今年20岁了'; //true\n```\n### boolean\n布尔值只有`true`和`false`\n```javascript\ntrue; // 这是一个true值\nfalse; // 这是一个false值\n2 > 1; // 这是一个true值\n2 >= 3; // 这是一个false值\n```\n几个tips\n+ `NaN`这个特殊的Number与所有其他值都不相等，包括它自己\n```javascript\nNaN === NaN; // false\n```\n+ 唯一能判断`NaN`的方法是通过`isNaN()`函数：\n\n```javascript\nisNaN(NaN); // true\n```\n\n+ 最后要注意浮点数的相等比较：\n\n```javascript\n1 / 3 === (1 - 2 / 3); // false\n```\n\n> 这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：\n\n```javascript\nMath.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true\n```\n### null和undefined\n`null`表示一个“空”的值\n`undefined`表示值未定义\n\n> JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。\n\n### 数组\n数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。\n\n```javascript\nvar misc = [1, 2, 3.14, 'Hello', null, true，['',''],{'':''}];\nmisc.length  //8\nmisc[0] //1\nmisc[8] //undefined\n```\n与大多数其他语言不同，JavaScript的数组没有上界\n```javascript\nvar myArray = [1,2,3,4,5];\nmyArray.length; // 5\nmyArray[10000] = true;\nmyArray.length; //10001\nmyArray.length = 3;//myArray是['1','2','3']\n```\n数组专题\n数组拥有方法 [查看](https://www.w3school.com.cn/js/js_array_methods.asp)\n数组的排序 [查看](https://www.w3school.com.cn/js/js_array_sort.asp)\n 数组的遍历 [查看](https://www.w3school.com.cn/js/js_array_iteration.asp)\n\n### 对象\nJavaScript的对象是一组由键-值组成的无序集合，例如：\n\n```javascript\nvar person = {\n    name: 'Bob',\n    age: 20,\n    tags: ['js', 'web', 'mobile'],\n    city: 'Beijing',\n    hasCar: true,\n    zipcode: null\n};\n```\n\n\n","slug":"Javascript学习笔记","published":1,"updated":"2022-01-10T08:41:39.736Z","_id":"ckv5ff35t0001xgepaegu0pvk","comments":1,"layout":"post","photos":[],"link":"","content":"<p>打算把最近学习的JavaScript写个博客整理记录一下，学习方式是《JavaScript语言精粹》这本书和<a href=\"https://www.liaoxuefeng.com/wiki/1022910821149312\">廖雪峰的博客</a>，不太明白的地方会去看《JavaScript权威指南》、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript\">JavaScript|MDN</a>和<a href=\"https://www.w3school.com.cn/js/index.asp\">W3School</a>。</p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>JavaScript 变量能够保存多种数据类型：数值、字符串值、数组、对象等等：</p>\n<h3 id=\"Numbers\"><a href=\"#Numbers\" class=\"headerlink\" title=\"Numbers\"></a>Numbers</h3><p>JavaScript只有一种数字类型，不区分整型与浮点型，存储方式使用64位浮点数，1和1.0的值是相同的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-number\">123</span>; <span class=\"hljs-comment\">// 整数123</span><br><span class=\"hljs-number\">0.456</span>; <span class=\"hljs-comment\">// 浮点数0.456</span><br><span class=\"hljs-number\">1.2345e3</span>; <span class=\"hljs-comment\">// 科学计数法表示1.2345x1000，等同于1234.5</span><br>-<span class=\"hljs-number\">99</span>; <span class=\"hljs-comment\">// 负数</span><br><span class=\"hljs-literal\">NaN</span>; <span class=\"hljs-comment\">// NaN表示Not a Number，当无法计算结果时用NaN表示，可以用isNaN检测NaN</span><br><span class=\"hljs-literal\">Infinity</span>; <span class=\"hljs-comment\">// Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</span><br></code></pre></td></tr></table></figure>\n<p>可以操作数字的方法 </p>\n<ul>\n<li>五个number方法 <a href=\"https://www.w3school.com.cn/js/js_number_methods.asp\">查看</a><ul>\n<li>将数字以字符串返回：<code>number.toString(radix)</code>,<code>radix</code>控制进制，默认十进制。</li>\n<li>将number转换为一个十进制形式的字符串，保留<code>fractionDigits</code>位小数（多余的四舍五入）：<code>number.toFixed(fractionDigits)</code></li>\n<li>将number转换成为一个指数形式的字符串，保留<code>fractionDigits</code>位小数（多余的四舍五入）<code>number.toExponential（fractionDigits）</code></li>\n<li>将number转换为一个十进制形式的字符串，保留<code>precision</code>个有效数字（多余的四舍五入）：<code>number.toPrecision(precision)</code></li>\n</ul>\n</li>\n<li>三个全局方法 <a href=\"https://www.w3school.com.cn/js/js_number_methods.asp\">查看</a><ul>\n<li>可以将x转换为数字，x为任意JavaScript变量（日期，布尔值等）：<code>Number(x)</code></li>\n<li>解析一段字符串并返回整型数值（向下取整）。允许空格。只返回首个数字： <code>parseInt(string)</code></li>\n<li>解析一段字符串并返回数值。允许空格。只返回首个数字：<code>parseFloat(string)</code></li>\n</ul>\n</li>\n<li>math对象方法执行数学数学任务 <a href=\"https://www.w3school.com.cn/js/js_math.asp\">查看</a><ul>\n<li>返回x的四舍五入：<code>Math.round(x)</code></li>\n<li>返回x的y次幂：<code>Math.pow(x,y)</code></li>\n<li>返回x的平方根：<code>Math.sqrt(x)</code></li>\n<li>返回x的绝对值：<code>Math.abs(x)</code></li>\n<li>x向上取整：<code>Math.ceil(x)</code>，x向下取整：<code>Math.floor(x)</code></li>\n<li>x正弦余弦：<code>Math.sin(x)</code> , <code>Math.cos(x)</code></li>\n<li>最大最小值：<code>Math.min(1,,2,3,4) //1</code> ，<code>Math.max(1,2,3,4) //4</code>,<a href=\"https://www.cnblogs.com/lguow/p/9725258.html\">用于数组</a></li>\n<li>返回一个0-1的随机数：<code>Math.random()</code>，更多<a href=\"https://www.w3school.com.cn/js/js_random.asp\">随机数trick</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Strings\"><a href=\"#Strings\" class=\"headerlink\" title=\"Strings\"></a>Strings</h3><p>JavaScript的字符串就是用<code>&#39; &#39;</code>或<code>&quot; &quot;</code>括起来的字符<br>例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;I\\&#x27;m \\&quot;OK\\&quot;!&#x27;</span>;<br></code></pre></td></tr></table></figure>\n<p>含义<code>I&#39;m &quot;OK&quot;!</code></p>\n<blockquote>\n<p>字符串一旦创建就不能改变，可以使用字符串方法操作返回新的字符串</p>\n</blockquote>\n<p><code>\\</code>是转义字符 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;A&#x27;</span> === <span class=\"hljs-string\">&#x27;\\u0041&#x27;</span>; <span class=\"hljs-comment\">//true</span><br></code></pre></td></tr></table></figure>\n<p>string有<code>length</code>属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;seven&#x27;</span>.length; <span class=\"hljs-comment\">//5</span><br></code></pre></td></tr></table></figure>\n<p>可以用<code>+</code>号连接其他字符串来创建一个新的字符串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;c&#x27;</span>+<span class=\"hljs-string\">&#x27;a&#x27;</span>+<span class=\"hljs-string\">&#x27;t&#x27;</span> ===<span class=\"hljs-string\">&#x27;cat&#x27;</span>; <span class=\"hljs-comment\">//true</span><br></code></pre></td></tr></table></figure>\n<p>string拥有方法 <a href=\"https://www.w3school.com.cn/js/js_string_methods.asp\">查看</a></p>\n<ul>\n<li><p>查找：<code>string.indexOf(searchString,position)</code> , <code>string.lastIndexOf(seachString,position)</code> , <code>string.search(regexp)</code>.<br><code>searchString</code>要搜索的字符串，<code>position</code>开始搜索的位置，<code>regexp</code>正则表达式对象，以number返回位置</p>\n<blockquote>\n<p> 两种方法，<code>string.indexOf()</code> 与 <code>string.search()</code>，是相等的。</p>\n<p>这两种方法是不相等的。区别在于：</p>\n<p><code>string.search()</code> 方法无法设置第二个开始位置参数。 <code>string.indexOf()</code> 方法无法设置更强大的搜索值（正则表达式）。</p>\n</blockquote>\n</li>\n<li><p>提取字符：<code>string.charAt(position)</code> 方法返回字符串中指定下标（位置）的字符串。<br><code>string.charCodeAt(position)</code>方法返回字符串中指定索引的字符 unicode 编码，常用此方法建造哈希表，相反<code>string.fromCharCode(charCode...)</code>根据编码返回字符串</p>\n<blockquote>\n<p>ECMAScript 5 (2009) 允许对字符串的属性访问 <code>[ ]</code>，如<code>str[0]</code><br>用属性访问有点不太靠谱：</p>\n<p>不适用 Internet Explorer 7 或更早的版本 它让字符串看起来像是数组（其实并不    是） 如果找不到字符，<code>[ ]</code> 返回 <code>undefined</code>，而 <code>charAt()</code> 返回空字符串。<br>它是只读的。<code>str[0] = &quot;A&quot;</code> 不会产生错误（但也不会工作！）<br>如果您希望按照数组的方式处理字符串，可以先把它转换为数组。</p>\n</blockquote>\n</li>\n<li><p>把字符串转换为数组：<code>string.split(separator,limit)</code><br>以<code>separator</code>分割，改参数可以是字符串或正则表达式，<code>limit</code>限制被分割的片段数量，返回元素为字符串的数组。</p>\n</li>\n<li><p>提取字符串：<code>string.slice(start, end)</code>，<code>string.substring(start, end)</code>，<code>string.substr(start, length)</code><br><code>start</code><strong>开始</strong>提取位置，<code>end</code><strong>最后</strong>一个字符的位置，如果为负数则与<code>string.length</code>相加，即倒数位置，<code>length</code>要提取的字符串<strong>长度</strong>。<br>不改变原字符串，将提取结果以新字符串返回。</p>\n<blockquote>\n<p><code>substring()</code> 类似于 <code>slice()</code>。不同之处在于 <code>substring()</code> 无法接受负的索引。<br><code>substr()</code> 类似于 <code>slice()</code>。不同之处在于第二个参数规定被提取部分的长度。</p>\n</blockquote>\n</li>\n<li><p>替换：<code>replace(seachValue,replaceValue)</code><br><code>seachValue</code>可以是<strong>字符串</strong>或<strong>正则表达式</strong>，<code>replaceValue</code>可以是<strong>字符串</strong>或一个<strong>函数</strong>。<br>当<code>replaceValue</code>是一个<strong>字符串</strong>，字符<code>$</code>拥有特别含义：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> oldareacode = <span class=\"hljs-regexp\">/\\((\\d&#123;3&#125;)\\)/g</span>;<br><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-string\">&#x27;(555)666-1212&#x27;</span>.replace(oldareacode,<span class=\"hljs-string\">&#x27;$1-&#x27;</span>);<br><span class=\"hljs-comment\">//p 是 &#x27;555-666-1212&#x27;</span><br></code></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>美元符号序列</th>\n<th>替换对象</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$<code>$$</code></td>\n<td>$</td>\n</tr>\n<tr>\n<td>$<code>$&amp;</code></td>\n<td>整个匹配文本</td>\n</tr>\n<tr>\n<td>$<code>$number</code></td>\n<td>分组捕获的文本</td>\n</tr>\n<tr>\n<td>$<code>$` </code></td>\n<td>匹配之前的文本</td>\n</tr>\n<tr>\n<td>$<code>$&#39;</code></td>\n<td>匹配之后的文本</td>\n</tr>\n</tbody></table>\n<p>  如果<code>replaceValue</code>是一个<strong>函数</strong>，那么每次遇到一次匹配函数就会调用一次，该函数返回的字符串用作替换文本，在下一个参数是分组2捕获的文本、</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> old = <span class=\"hljs-string\">&#x27;hello World&#x27;</span>;<br><span class=\"hljs-keyword\">var</span> p = old.replace(<span class=\"hljs-string\">&#x27;hello&#x27;</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">c</span>)</span>&#123;<br>   \t<span class=\"hljs-built_in\">console</span>.log(c);<span class=\"hljs-comment\">//hello</span><br>   \t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;Hello&#x27;</span>    <br>\t&#125;)<br><span class=\"hljs-built_in\">console</span>.log(p);<span class=\"hljs-comment\">//Hello World</span><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>replace()</code> 只替换首个匹配<br>默认地，<code>replace()</code> 对大小写敏感。<br>如需执行大小写不敏感的替换，请使用正则表达式 <code>/i</code>,请注意正则表达式不带引号。如：<code>replace(/he/i,&#39;she&#39;)</code><br>如需替换所有匹配，请使用正则表达式的 <code>/g</code> 标志（用于全局搜索)。如：<code>replace(/he/g,&#39;she&#39;)</code></p>\n</blockquote>\n</li>\n<li><p>转换大小写：<code>toUpperCase()</code>,<code>toLowerCase()</code></p>\n</li>\n<li><p>连接字符串：<code>concat()</code>与<code>+</code>等效</p>\n</li>\n<li><p>删除字符串两端的空白符：<code>String.trim()</code></p>\n<blockquote>\n<p>Internet Explorer 8 或更低版本不支持 <code>trim()</code> 方法。<br>如需支持 IE 8，您可搭配正则表达式使用 <code>replace()</code> 方法代替：<br><code>str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, &#39;&#39;)</code>; </p>\n</blockquote>\n</li>\n<li><p>匹配：<code>string.match(regexp)</code>方法让字符串与一个正则表达式匹配。根据g表示来决定如何匹配，如果没有<code>g</code>表示，那么结果与<code>regexp.exec(string)</code>的结果相同。否则会生成包含所有匹配的数组。</p>\n</li>\n</ul>\n<h4 id=\"多行字符串和模板字符串\"><a href=\"#多行字符串和模板字符串\" class=\"headerlink\" title=\"多行字符串和模板字符串\"></a>多行字符串和模板字符串</h4><p>ES6语法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">`这是一个</span><br><span class=\"hljs-string\">多行</span><br><span class=\"hljs-string\">字符串`</span>;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">&#x27;小明&#x27;</span>;<br><span class=\"hljs-keyword\">var</span> age = <span class=\"hljs-number\">20</span>;<br><span class=\"hljs-keyword\">var</span> message = <span class=\"hljs-string\">`你好, <span class=\"hljs-subst\">$&#123;name&#125;</span>, 你今年<span class=\"hljs-subst\">$&#123;age&#125;</span>岁了!`</span>;<br>message === <span class=\"hljs-string\">&#x27;你好,小明,你今年20岁了&#x27;</span>; <span class=\"hljs-comment\">//true</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"boolean\"><a href=\"#boolean\" class=\"headerlink\" title=\"boolean\"></a>boolean</h3><p>布尔值只有<code>true</code>和<code>false</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// 这是一个true值</span><br><span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// 这是一个false值</span><br><span class=\"hljs-number\">2</span> &gt; <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 这是一个true值</span><br><span class=\"hljs-number\">2</span> &gt;= <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">// 这是一个false值</span><br></code></pre></td></tr></table></figure>\n<p>几个tips</p>\n<ul>\n<li><code>NaN</code>这个特殊的Number与所有其他值都不相等，包括它自己<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-literal\">NaN</span> === <span class=\"hljs-literal\">NaN</span>; <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure></li>\n<li>唯一能判断<code>NaN</code>的方法是通过<code>isNaN()</code>函数：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">isNaN</span>(<span class=\"hljs-literal\">NaN</span>); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>最后要注意浮点数的相等比较：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-number\">1</span> / <span class=\"hljs-number\">3</span> === (<span class=\"hljs-number\">1</span> - <span class=\"hljs-number\">2</span> / <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">Math</span>.abs(<span class=\"hljs-number\">1</span> / <span class=\"hljs-number\">3</span> - (<span class=\"hljs-number\">1</span> - <span class=\"hljs-number\">2</span> / <span class=\"hljs-number\">3</span>)) &lt; <span class=\"hljs-number\">0.0000001</span>; <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"null和undefined\"><a href=\"#null和undefined\" class=\"headerlink\" title=\"null和undefined\"></a>null和undefined</h3><p><code>null</code>表示一个“空”的值<br><code>undefined</code>表示值未定义</p>\n<blockquote>\n<p>JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。</p>\n</blockquote>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> misc = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3.14</span>, <span class=\"hljs-string\">&#x27;Hello&#x27;</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">true</span>，[<span class=\"hljs-string\">&#x27;&#x27;</span>,<span class=\"hljs-string\">&#x27;&#x27;</span>],&#123;<span class=\"hljs-string\">&#x27;&#x27;</span>:<span class=\"hljs-string\">&#x27;&#x27;</span>&#125;];<br>misc.length  <span class=\"hljs-comment\">//8</span><br>misc[<span class=\"hljs-number\">0</span>] <span class=\"hljs-comment\">//1</span><br>misc[<span class=\"hljs-number\">8</span>] <span class=\"hljs-comment\">//undefined</span><br></code></pre></td></tr></table></figure>\n<p>与大多数其他语言不同，JavaScript的数组没有上界</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> myArray = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>];<br>myArray.length; <span class=\"hljs-comment\">// 5</span><br>myArray[<span class=\"hljs-number\">10000</span>] = <span class=\"hljs-literal\">true</span>;<br>myArray.length; <span class=\"hljs-comment\">//10001</span><br>myArray.length = <span class=\"hljs-number\">3</span>;<span class=\"hljs-comment\">//myArray是[&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;]</span><br></code></pre></td></tr></table></figure>\n<p>数组专题<br>数组拥有方法 <a href=\"https://www.w3school.com.cn/js/js_array_methods.asp\">查看</a><br>数组的排序 <a href=\"https://www.w3school.com.cn/js/js_array_sort.asp\">查看</a><br> 数组的遍历 <a href=\"https://www.w3school.com.cn/js/js_array_iteration.asp\">查看</a></p>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><p>JavaScript的对象是一组由键-值组成的无序集合，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> person = &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;Bob&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">20</span>,<br>    <span class=\"hljs-attr\">tags</span>: [<span class=\"hljs-string\">&#x27;js&#x27;</span>, <span class=\"hljs-string\">&#x27;web&#x27;</span>, <span class=\"hljs-string\">&#x27;mobile&#x27;</span>],<br>    <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">&#x27;Beijing&#x27;</span>,<br>    <span class=\"hljs-attr\">hasCar</span>: <span class=\"hljs-literal\">true</span>,<br>    <span class=\"hljs-attr\">zipcode</span>: <span class=\"hljs-literal\">null</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"wordcount":4823,"excerpt":"","more":"<p>打算把最近学习的JavaScript写个博客整理记录一下，学习方式是《JavaScript语言精粹》这本书和<a href=\"https://www.liaoxuefeng.com/wiki/1022910821149312\">廖雪峰的博客</a>，不太明白的地方会去看《JavaScript权威指南》、<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript\">JavaScript|MDN</a>和<a href=\"https://www.w3school.com.cn/js/index.asp\">W3School</a>。</p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>JavaScript 变量能够保存多种数据类型：数值、字符串值、数组、对象等等：</p>\n<h3 id=\"Numbers\"><a href=\"#Numbers\" class=\"headerlink\" title=\"Numbers\"></a>Numbers</h3><p>JavaScript只有一种数字类型，不区分整型与浮点型，存储方式使用64位浮点数，1和1.0的值是相同的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-number\">123</span>; <span class=\"hljs-comment\">// 整数123</span><br><span class=\"hljs-number\">0.456</span>; <span class=\"hljs-comment\">// 浮点数0.456</span><br><span class=\"hljs-number\">1.2345e3</span>; <span class=\"hljs-comment\">// 科学计数法表示1.2345x1000，等同于1234.5</span><br>-<span class=\"hljs-number\">99</span>; <span class=\"hljs-comment\">// 负数</span><br><span class=\"hljs-literal\">NaN</span>; <span class=\"hljs-comment\">// NaN表示Not a Number，当无法计算结果时用NaN表示，可以用isNaN检测NaN</span><br><span class=\"hljs-literal\">Infinity</span>; <span class=\"hljs-comment\">// Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</span><br></code></pre></td></tr></table></figure>\n<p>可以操作数字的方法 </p>\n<ul>\n<li>五个number方法 <a href=\"https://www.w3school.com.cn/js/js_number_methods.asp\">查看</a><ul>\n<li>将数字以字符串返回：<code>number.toString(radix)</code>,<code>radix</code>控制进制，默认十进制。</li>\n<li>将number转换为一个十进制形式的字符串，保留<code>fractionDigits</code>位小数（多余的四舍五入）：<code>number.toFixed(fractionDigits)</code></li>\n<li>将number转换成为一个指数形式的字符串，保留<code>fractionDigits</code>位小数（多余的四舍五入）<code>number.toExponential（fractionDigits）</code></li>\n<li>将number转换为一个十进制形式的字符串，保留<code>precision</code>个有效数字（多余的四舍五入）：<code>number.toPrecision(precision)</code></li>\n</ul>\n</li>\n<li>三个全局方法 <a href=\"https://www.w3school.com.cn/js/js_number_methods.asp\">查看</a><ul>\n<li>可以将x转换为数字，x为任意JavaScript变量（日期，布尔值等）：<code>Number(x)</code></li>\n<li>解析一段字符串并返回整型数值（向下取整）。允许空格。只返回首个数字： <code>parseInt(string)</code></li>\n<li>解析一段字符串并返回数值。允许空格。只返回首个数字：<code>parseFloat(string)</code></li>\n</ul>\n</li>\n<li>math对象方法执行数学数学任务 <a href=\"https://www.w3school.com.cn/js/js_math.asp\">查看</a><ul>\n<li>返回x的四舍五入：<code>Math.round(x)</code></li>\n<li>返回x的y次幂：<code>Math.pow(x,y)</code></li>\n<li>返回x的平方根：<code>Math.sqrt(x)</code></li>\n<li>返回x的绝对值：<code>Math.abs(x)</code></li>\n<li>x向上取整：<code>Math.ceil(x)</code>，x向下取整：<code>Math.floor(x)</code></li>\n<li>x正弦余弦：<code>Math.sin(x)</code> , <code>Math.cos(x)</code></li>\n<li>最大最小值：<code>Math.min(1,,2,3,4) //1</code> ，<code>Math.max(1,2,3,4) //4</code>,<a href=\"https://www.cnblogs.com/lguow/p/9725258.html\">用于数组</a></li>\n<li>返回一个0-1的随机数：<code>Math.random()</code>，更多<a href=\"https://www.w3school.com.cn/js/js_random.asp\">随机数trick</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Strings\"><a href=\"#Strings\" class=\"headerlink\" title=\"Strings\"></a>Strings</h3><p>JavaScript的字符串就是用<code>&#39; &#39;</code>或<code>&quot; &quot;</code>括起来的字符<br>例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;I\\&#x27;m \\&quot;OK\\&quot;!&#x27;</span>;<br></code></pre></td></tr></table></figure>\n<p>含义<code>I&#39;m &quot;OK&quot;!</code></p>\n<blockquote>\n<p>字符串一旦创建就不能改变，可以使用字符串方法操作返回新的字符串</p>\n</blockquote>\n<p><code>\\</code>是转义字符 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;A&#x27;</span> === <span class=\"hljs-string\">&#x27;\\u0041&#x27;</span>; <span class=\"hljs-comment\">//true</span><br></code></pre></td></tr></table></figure>\n<p>string有<code>length</code>属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;seven&#x27;</span>.length; <span class=\"hljs-comment\">//5</span><br></code></pre></td></tr></table></figure>\n<p>可以用<code>+</code>号连接其他字符串来创建一个新的字符串</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;c&#x27;</span>+<span class=\"hljs-string\">&#x27;a&#x27;</span>+<span class=\"hljs-string\">&#x27;t&#x27;</span> ===<span class=\"hljs-string\">&#x27;cat&#x27;</span>; <span class=\"hljs-comment\">//true</span><br></code></pre></td></tr></table></figure>\n<p>string拥有方法 <a href=\"https://www.w3school.com.cn/js/js_string_methods.asp\">查看</a></p>\n<ul>\n<li><p>查找：<code>string.indexOf(searchString,position)</code> , <code>string.lastIndexOf(seachString,position)</code> , <code>string.search(regexp)</code>.<br><code>searchString</code>要搜索的字符串，<code>position</code>开始搜索的位置，<code>regexp</code>正则表达式对象，以number返回位置</p>\n<blockquote>\n<p> 两种方法，<code>string.indexOf()</code> 与 <code>string.search()</code>，是相等的。</p>\n<p>这两种方法是不相等的。区别在于：</p>\n<p><code>string.search()</code> 方法无法设置第二个开始位置参数。 <code>string.indexOf()</code> 方法无法设置更强大的搜索值（正则表达式）。</p>\n</blockquote>\n</li>\n<li><p>提取字符：<code>string.charAt(position)</code> 方法返回字符串中指定下标（位置）的字符串。<br><code>string.charCodeAt(position)</code>方法返回字符串中指定索引的字符 unicode 编码，常用此方法建造哈希表，相反<code>string.fromCharCode(charCode...)</code>根据编码返回字符串</p>\n<blockquote>\n<p>ECMAScript 5 (2009) 允许对字符串的属性访问 <code>[ ]</code>，如<code>str[0]</code><br>用属性访问有点不太靠谱：</p>\n<p>不适用 Internet Explorer 7 或更早的版本 它让字符串看起来像是数组（其实并不    是） 如果找不到字符，<code>[ ]</code> 返回 <code>undefined</code>，而 <code>charAt()</code> 返回空字符串。<br>它是只读的。<code>str[0] = &quot;A&quot;</code> 不会产生错误（但也不会工作！）<br>如果您希望按照数组的方式处理字符串，可以先把它转换为数组。</p>\n</blockquote>\n</li>\n<li><p>把字符串转换为数组：<code>string.split(separator,limit)</code><br>以<code>separator</code>分割，改参数可以是字符串或正则表达式，<code>limit</code>限制被分割的片段数量，返回元素为字符串的数组。</p>\n</li>\n<li><p>提取字符串：<code>string.slice(start, end)</code>，<code>string.substring(start, end)</code>，<code>string.substr(start, length)</code><br><code>start</code><strong>开始</strong>提取位置，<code>end</code><strong>最后</strong>一个字符的位置，如果为负数则与<code>string.length</code>相加，即倒数位置，<code>length</code>要提取的字符串<strong>长度</strong>。<br>不改变原字符串，将提取结果以新字符串返回。</p>\n<blockquote>\n<p><code>substring()</code> 类似于 <code>slice()</code>。不同之处在于 <code>substring()</code> 无法接受负的索引。<br><code>substr()</code> 类似于 <code>slice()</code>。不同之处在于第二个参数规定被提取部分的长度。</p>\n</blockquote>\n</li>\n<li><p>替换：<code>replace(seachValue,replaceValue)</code><br><code>seachValue</code>可以是<strong>字符串</strong>或<strong>正则表达式</strong>，<code>replaceValue</code>可以是<strong>字符串</strong>或一个<strong>函数</strong>。<br>当<code>replaceValue</code>是一个<strong>字符串</strong>，字符<code>$</code>拥有特别含义：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> oldareacode = <span class=\"hljs-regexp\">/\\((\\d&#123;3&#125;)\\)/g</span>;<br><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-string\">&#x27;(555)666-1212&#x27;</span>.replace(oldareacode,<span class=\"hljs-string\">&#x27;$1-&#x27;</span>);<br><span class=\"hljs-comment\">//p 是 &#x27;555-666-1212&#x27;</span><br></code></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>美元符号序列</th>\n<th>替换对象</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$<code>$$</code></td>\n<td>$</td>\n</tr>\n<tr>\n<td>$<code>$&amp;</code></td>\n<td>整个匹配文本</td>\n</tr>\n<tr>\n<td>$<code>$number</code></td>\n<td>分组捕获的文本</td>\n</tr>\n<tr>\n<td>$<code>$` </code></td>\n<td>匹配之前的文本</td>\n</tr>\n<tr>\n<td>$<code>$&#39;</code></td>\n<td>匹配之后的文本</td>\n</tr>\n</tbody></table>\n<p>  如果<code>replaceValue</code>是一个<strong>函数</strong>，那么每次遇到一次匹配函数就会调用一次，该函数返回的字符串用作替换文本，在下一个参数是分组2捕获的文本、</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> old = <span class=\"hljs-string\">&#x27;hello World&#x27;</span>;<br><span class=\"hljs-keyword\">var</span> p = old.replace(<span class=\"hljs-string\">&#x27;hello&#x27;</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">c</span>)</span>&#123;<br>   \t<span class=\"hljs-built_in\">console</span>.log(c);<span class=\"hljs-comment\">//hello</span><br>   \t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;Hello&#x27;</span>    <br>\t&#125;)<br><span class=\"hljs-built_in\">console</span>.log(p);<span class=\"hljs-comment\">//Hello World</span><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>replace()</code> 只替换首个匹配<br>默认地，<code>replace()</code> 对大小写敏感。<br>如需执行大小写不敏感的替换，请使用正则表达式 <code>/i</code>,请注意正则表达式不带引号。如：<code>replace(/he/i,&#39;she&#39;)</code><br>如需替换所有匹配，请使用正则表达式的 <code>/g</code> 标志（用于全局搜索)。如：<code>replace(/he/g,&#39;she&#39;)</code></p>\n</blockquote>\n</li>\n<li><p>转换大小写：<code>toUpperCase()</code>,<code>toLowerCase()</code></p>\n</li>\n<li><p>连接字符串：<code>concat()</code>与<code>+</code>等效</p>\n</li>\n<li><p>删除字符串两端的空白符：<code>String.trim()</code></p>\n<blockquote>\n<p>Internet Explorer 8 或更低版本不支持 <code>trim()</code> 方法。<br>如需支持 IE 8，您可搭配正则表达式使用 <code>replace()</code> 方法代替：<br><code>str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, &#39;&#39;)</code>; </p>\n</blockquote>\n</li>\n<li><p>匹配：<code>string.match(regexp)</code>方法让字符串与一个正则表达式匹配。根据g表示来决定如何匹配，如果没有<code>g</code>表示，那么结果与<code>regexp.exec(string)</code>的结果相同。否则会生成包含所有匹配的数组。</p>\n</li>\n</ul>\n<h4 id=\"多行字符串和模板字符串\"><a href=\"#多行字符串和模板字符串\" class=\"headerlink\" title=\"多行字符串和模板字符串\"></a>多行字符串和模板字符串</h4><p>ES6语法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">`这是一个</span><br><span class=\"hljs-string\">多行</span><br><span class=\"hljs-string\">字符串`</span>;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">&#x27;小明&#x27;</span>;<br><span class=\"hljs-keyword\">var</span> age = <span class=\"hljs-number\">20</span>;<br><span class=\"hljs-keyword\">var</span> message = <span class=\"hljs-string\">`你好, <span class=\"hljs-subst\">$&#123;name&#125;</span>, 你今年<span class=\"hljs-subst\">$&#123;age&#125;</span>岁了!`</span>;<br>message === <span class=\"hljs-string\">&#x27;你好,小明,你今年20岁了&#x27;</span>; <span class=\"hljs-comment\">//true</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"boolean\"><a href=\"#boolean\" class=\"headerlink\" title=\"boolean\"></a>boolean</h3><p>布尔值只有<code>true</code>和<code>false</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// 这是一个true值</span><br><span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// 这是一个false值</span><br><span class=\"hljs-number\">2</span> &gt; <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 这是一个true值</span><br><span class=\"hljs-number\">2</span> &gt;= <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">// 这是一个false值</span><br></code></pre></td></tr></table></figure>\n<p>几个tips</p>\n<ul>\n<li><code>NaN</code>这个特殊的Number与所有其他值都不相等，包括它自己<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-literal\">NaN</span> === <span class=\"hljs-literal\">NaN</span>; <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure></li>\n<li>唯一能判断<code>NaN</code>的方法是通过<code>isNaN()</code>函数：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">isNaN</span>(<span class=\"hljs-literal\">NaN</span>); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>最后要注意浮点数的相等比较：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-number\">1</span> / <span class=\"hljs-number\">3</span> === (<span class=\"hljs-number\">1</span> - <span class=\"hljs-number\">2</span> / <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">Math</span>.abs(<span class=\"hljs-number\">1</span> / <span class=\"hljs-number\">3</span> - (<span class=\"hljs-number\">1</span> - <span class=\"hljs-number\">2</span> / <span class=\"hljs-number\">3</span>)) &lt; <span class=\"hljs-number\">0.0000001</span>; <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"null和undefined\"><a href=\"#null和undefined\" class=\"headerlink\" title=\"null和undefined\"></a>null和undefined</h3><p><code>null</code>表示一个“空”的值<br><code>undefined</code>表示值未定义</p>\n<blockquote>\n<p>JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。</p>\n</blockquote>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> misc = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3.14</span>, <span class=\"hljs-string\">&#x27;Hello&#x27;</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">true</span>，[<span class=\"hljs-string\">&#x27;&#x27;</span>,<span class=\"hljs-string\">&#x27;&#x27;</span>],&#123;<span class=\"hljs-string\">&#x27;&#x27;</span>:<span class=\"hljs-string\">&#x27;&#x27;</span>&#125;];<br>misc.length  <span class=\"hljs-comment\">//8</span><br>misc[<span class=\"hljs-number\">0</span>] <span class=\"hljs-comment\">//1</span><br>misc[<span class=\"hljs-number\">8</span>] <span class=\"hljs-comment\">//undefined</span><br></code></pre></td></tr></table></figure>\n<p>与大多数其他语言不同，JavaScript的数组没有上界</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> myArray = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>];<br>myArray.length; <span class=\"hljs-comment\">// 5</span><br>myArray[<span class=\"hljs-number\">10000</span>] = <span class=\"hljs-literal\">true</span>;<br>myArray.length; <span class=\"hljs-comment\">//10001</span><br>myArray.length = <span class=\"hljs-number\">3</span>;<span class=\"hljs-comment\">//myArray是[&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;]</span><br></code></pre></td></tr></table></figure>\n<p>数组专题<br>数组拥有方法 <a href=\"https://www.w3school.com.cn/js/js_array_methods.asp\">查看</a><br>数组的排序 <a href=\"https://www.w3school.com.cn/js/js_array_sort.asp\">查看</a><br> 数组的遍历 <a href=\"https://www.w3school.com.cn/js/js_array_iteration.asp\">查看</a></p>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><p>JavaScript的对象是一组由键-值组成的无序集合，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> person = &#123;<br>    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;Bob&#x27;</span>,<br>    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">20</span>,<br>    <span class=\"hljs-attr\">tags</span>: [<span class=\"hljs-string\">&#x27;js&#x27;</span>, <span class=\"hljs-string\">&#x27;web&#x27;</span>, <span class=\"hljs-string\">&#x27;mobile&#x27;</span>],<br>    <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">&#x27;Beijing&#x27;</span>,<br>    <span class=\"hljs-attr\">hasCar</span>: <span class=\"hljs-literal\">true</span>,<br>    <span class=\"hljs-attr\">zipcode</span>: <span class=\"hljs-literal\">null</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n\n"},{"title":"Javascript学习笔记二","date":"2020-02-12T08:26:09.000Z","index_img":"/img/blogCovers/js2.jpg","_content":"\n数组是值的有序集合。每个值叫做一个元素，而每个元素在数组中的位置，以数字表示，称为索引。\nJavaScript数组是JavaScript对象的特殊形式，数组索引实际上和碰巧是整数的属性名差不多。通常，数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象属性要快很多\nJavaScript数组可以包含任意数据类型\n\n\n\n## 创建数组\n1. 使用数组字面量`[]`\nJavaScript数组可以包含任意数据类型\n\t```javascript\n\tvar arr = [1,2,'hello',null,undefined,true,{'hei':'黑'},[1,2]];\n\tarr.length;//8\n\t```\n\t如果直接省略数组中某个值将被赋予`undefined`值\n\t\n\n\t```javascript\n\tvar count=[1,,3];\n\tcount[1];//undefined\n\tvar undefs = [,,];//数组有个两个元素都是undefined,索引已经定义\n\t```\n\t因为数组字面量语法允许有可选的结尾的逗号，故`[,,]`只有两个元素而非三个\n2. 调用构造函数`Array()`\n\n\t```javascript\n\tvar a = new Array()//空数组，等同于数组字面量[].\n\tvar b = new Array(10)//创建指定长度的数组，此时数组中没有元素，甚至索引属性‘0’、‘1’都未定义\n\tb.length();//10\n\t0 in b;//false\n\tvar c = new Array(1,2,'hello',null,undefined,true,{'hei':'黑'},[1,2])\n\t//创建一数组，构造函数的参数将会成为新数组的元素，使用个数组字面量比使用构造函数要简单\n\t```\n## 数组的读写\n使用`[]`操作符来访问修改数组中的一个元素\n\n```javascript\narr[0];//读取下标为0的元素，1\narr[8] = 'end';//在下标为8的地方写入数据\narr.length;//9\narr[-1.23] = true;//这将创建一个名为‘-1.23’的属性\narr['1000'] = 0;\narr.length;//9,不变\narr[1.000];//与a[1]相等\n```\n## 数组的长度\n每个数组有一个`length`属性，就是这个属性使其区别于其他常规的JavaScript对象。\n\n```javascript\narr.length;//9\narr.length = 3;//现在arr为[1,2,'hello']\narr.length = 0;//删除所有元素，a为[];\narr.length = 5;//长度为5，没有元素，就像new Array(5)\n```\n## 数组元素的添加和删除\n- 添加\n1. 添加数组元素最简单的方法：为新索引赋值：\n\n\t```javascript\n\ta = []   //空数组\n\ta[0] = 1;//[1]\n\ta[2] = 2;//[1,,2]\n\t```\n\n2. 使用`push()`和`pop()`\n\n\t```javascript\n\ta = [0];\n\ta.push(1);//向末尾添加一个元素。 [0,1]\n\ta.unshift(0);//向开头添加一个元素。[0,0,1]\n\t```\n\n- 删除\n1. `delete()`,类似于赋值undefined，不会影响数组长度\n\n\t```javascript\n\ta =[1,2,3];\n\tdelete a[1];\n\t1 in a;//false\n\ta.length;//3\n\t```\n2. `pop()` `shift()`\n\n\t```javascript\n\ta = [1,2,3];\n\ta.shift();//移除开头元素,[2,3]\n\ta.pop();//移除末尾元素，[2]\n\t```\n最后一个可删除，可添加的方法`splice()`,详细内容往下看\n## 数组的遍历\n1. `for`循环\n最常用\n2. `for in`循环，遍历的是索引\nfor in可以遍历对象，也可遍历数组，但遍历数组的时候有些问题\n\n\t> 1.index索引为字符串型数字，不能直接进行几何运算\n\t> 2.遍历顺序有可能不是按照实际数组的内部顺序\n\t> 3.使用for in会遍历数组所有的可枚举属性，包括原型。所以for in更适合遍历对象，不要使用for in遍历数组\n\n3. `for of`循环（ES6），遍历的是元素。\n\n\t```javascript\n\tArray.prototype.method=function(){\n\t　　console.log(this.length);\n\t}\n\tvar myArray=[1,2,4,5,6,7]\n\tmyArray.name=\"数组\";\n\tfor (var value of myArray) {\n\t  console.log(value);\n\t}\n\t//1 2 4 5 6 7\n\t```\n\n\t> \t记住，for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值。\n\t> \n\t> for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name\n4. `forEach()` (ES5)\n\t\n\t```javascript\n\tvar a = ['A', 'B', 'C'];\n\ta.forEach(function (element) {\n\t    console.log(element);\n\t});//A,B,C\n\t```\n\tforEach()方法无法再所有元素都传递给调用函数之前终止遍历。也就是说，没有像for循环中使用的相应的break语句。如果要提前终止，必须把forEach()方法放在一个try中，并抛出一个异常。\n## 数组方法\n- `Array.concat(item...)`\n该方法产生一个新数组，它包含一份array的赋值并把一个或多个item附加在它后面\n\n\t```javascript\n\tvar a = ['A', 'B', 'C'];\n\tvar b = ['x','y','z'];\n\tvar c = a.concat(b,true);\n\t//['A', 'B', 'C','x','y','z',true]\n\t```\n\n- `Array.join(separator)`\n把一个array构造成一个字符串。他把array中的每个元素使用`separator`连接起来，构成一个字符串，默认的`separator` 是`,`，无间隔连接使用空字符串`''`\n\n\t```javascript\n\tvar a = ['A', 'B', 'C'];\n\tvar c = a.join('');//'ABC'\n\t```\n- `Array.reverse()`\n翻转array里的元素的排序，并返回array本身：\n\n\t```javascript\n\tvar a = ['A', 'B', 'C'];\n\ta.reverse();//a和b都是['C','B','A']\n\t```\n- `Array.slice(start,end)`\n对array中的一段做浅复制。首先复制`array[start]`,一直复制到`array[end]`为止。`end`参数是可选的，默认是该数组的长度`array.length`。\n\t\n\t```javascript\n\tvar a = ['A', 'B', 'C'];\n\tb = a.slice(0,1);//['A']\n\tc = a.slice(1);//['B','C']\n\td = a.slice(4);//[]\n\t```\n- `Array.sort(comparefn)`\n`sort`方法对array中的内容进行排序。他不能正确的给一组数字排序：\n\n\t```javascript\n\tvar a = [4,8,15,16,23,42];\n\ta.sort();//Array(6) [15, 16, 23, 4, 42, 8]\n\t```\n\tJavaScript的默认比较函数把要排序的元素都视为字符串。，比较数字的时候，会把他们转换为字符串，于是得到了一个错误结果。\n\t幸运的是可以使用自己的比较函数，你的比较函数接受两个参数，并且如果相等返回0，如果第一个参数在前，则返回一个负数，如果第二个参数应在前，则返回一个正数。\n\t```javascript\n\tvar a = [4,8,15,16,23,42];\n\ta.sort(function(a,b){\n\t    return a-b\n\t});//Array(6) [4, 8, 15, 16, 23, 42]\n\t```\n- `array.splice (start,deleteCount,item...)`\n`splice`方法从array中移除一个或者多个元素，并使用新的item替换他们。参数`start`是从数组array中移除元素的开始位置。参数`deleteCount`是要移除的元素个数。如果有额外参数那些`item`会插入到被移除元素的位置上\n\n\t```javascript\n\tvar arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];\n\t// 从索引2开始删除3个元素,然后再添加两个元素:\n\tarr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']\n\tarr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']\n\t// 只删除,不添加:\n\tarr.splice(2, 2); // ['Google', 'Facebook']\n\tarr; // ['Microsoft', 'Apple', 'Oracle']\n\t// 只添加,不删除:\n\tarr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素\n\tarr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']\n\t```\n- `map()`(ES5)\n举例说明，比如我们有一个函数f(x)=x^2^，要把这个函数作用在一个数组[1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map实现如下:\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200214165103406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n\n\t```javascript\n\tfunction pow(x) {\n\t    return x * x;\n\t}\n\tvar arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\tvar results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]\n\tconsole.log(results);\n\t```\n- `filter()`\n它用于把Array的某些元素过滤掉，然后返回剩下的元素。\n和`map()`类似，Array的`filter()`也接收一个函数。和`map()`不同的是，`filter()`把传入的函数依次作用于每个元素，然后根据返回值是`true`还是`false`决定保留还是丢弃该元素。\n\n\t```javascript\n\t//删除偶数，保留奇数\n\tvar arr = [1, 2, 4, 5, 6, 9, 10, 15];\n\tvar r = arr.filter(function (x) {\n\t    return x % 2 !== 0;\n\t});\n\tr; // [1, 5, 9, 15]\n\t```\n\t`filter()`接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身：\n\t\n\n\t```javascript\n\t//去处Array的重复元素\n\tvar r,arr = ['apple', 'strawberry', 'banana', \n\t\t'pear', 'apple', 'orange', 'orange', 'strawberry'];\n\tr = arr.filter(function (element, index, self) {\n\t    return self.indexOf(element) === index;\n\t});\n\t```\n- `every()`与`some()`\n`every()`方法像是数学中的量词 $\\forall$：当且仅当对数组中的所有元素调用判定函数都返回`true`，他才返回`true`\n\n\t```javascript\n\tvar arr = ['Apple', 'pear', 'orange'];\n\tconsole.log(arr.every(function (s) {\n\t    return s.length > 0;\n\t})); // true, 因为每个元素都满足s.length>0\n\t```\n\t`some()`方法则像数学中的量词 $\\exists$：当数组中至少有一个元素调用判定函数返回`true`，他就返回`true`，否则返回`false`\n\t\n\n\t```javascript\n\tvar arr = ['Apple', 'pear', 'orange'];\n\t\tconsole.log(arr.every(function (s) {\n\t\t    return s.length <5;\n\t\t})); // true, 因为存在'pear'长度小于5\n\t```\n- `reduce()`和`reduceRight()`\n Array的`reduce()`把一个函数作用在这个Array的`[x1, x2, x3...]`上，这个函数必须接收两个参数，`reduce()`把结果继续和序列的下一个元素做累积计算，其效果就是：\n\n\t```\n\t[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)\n\t```\n\n\t```javascript\n\t//用reduce求和\n\tvar arr = [1, 3, 5, 7, 9];\n\tarr.reduce(function (x, y) {\n\t    return x + y;\n\t}); // 25\n\t```\n\t`reduceRight()`的原理相同，只是方向相反\n- `find(function(currentValue, index, arr))`（ES6）、`findIndex(function(currentValue, index, arr))`（ES6）、`indexOf(item,start)`、`lastIndexOf(item,start)`和`includes(searchElement, fromIndex)`\n`find()` 方法返回数组中满足提供的测试函数的第一个元素的值。`currentValue`必选参数，当前元素。`index`可选参数，当前元素索引。\n\n\t```javascript\n\tvar ages = [3, 10, 18, 20];\n\tfunction checkAdult(age) {\n\t    return age >= 18;\n\t}\n\tvar value = ages.find(checkAdult);\n\t//18\n\t```\n\t`findIndex()`方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回`-1`\n\t\n\n\t```javascript\n\tvar ages = [3, 10, 18, 20];\n\tfunction checkAdult(age) {\n\t\t    return age >= 18;\n\t\t}\n\tvar value = ages.findIndex(checkAdult);\n\t\t//2\n\t```\n\t`indexOf()`方法返回在数组中可以找到给定元素的第一个索引，如果不存在，则返回`-1`，`item`是要找的元素，`start`是开始位置（可选，默认`0`）\n\t```javascript\n\tvar fruits=[\"Banana\",\"Orange\",\"Apple\",\"Mango\",\"Banana\",\"Orange\",\"Apple\"];\n\tvar a = fruits.indexOf(\"Apple\",4);//6\n\t```\n\t`lastIndexOf()` 方法可返回一个指定的元素在数组中最后出现的位置，从该字符串的后面向前查找。如果要检索的元素没有出现，则该方法返回 `-1`\n\t```javascript\n\tvar fruits=[\"Banana\",\"Orange\",\"Apple\",\"Mango\",\"Banana\",\"Orange\",\"Apple\"];\n\tvar a = fruits.lastIndexOf(\"Apple\",4);//2\n\t```\n\t`includes()` 方法用来判断一个数组是否包含一个指定的值，如果是返回 `true`，否则`false`。`searchElement` 必须参数，需要查找的元素值。`fromIndex` 可选参数，从该索引处开始查找\n\t```javascript\n\t[1, 2, 3].includes(2);     // true\n\t[1, 2, 3].includes(4);     // false\n\t[1, 2, 3].includes(3, 3);  // false\n\t[1, 2, 3].includes(3, -1); // true\n\t[1, 2, NaN].includes(NaN); // true\n\t```\n- `Array.isArray(obj)`\n\tisArray() 方法用于判断一个对象是否为数组。如果对象是数组返回 true，否则返回 false。\n\t```javascript\n\tArray.isArray([]) ;// true\n\tArrray.isArray({});//false\n\t```\n## 类数组对象\nJavaScript数组的有一些特性是其他对象没有的：\n\n- 当有新的元素添加到数组时，自动更新length属性。\n- 设置length为一个较小值将截断数组。\n- 从Array.prototype 中级证一些有用的方法。\n- 其类属性为‘Array’ \n","source":"_posts/Javascript学习笔记二.md","raw":"---\ntitle: Javascript学习笔记二\ndate: 2020-02-12 16:26:09\nindex_img: /img/blogCovers/js2.jpg\ntags: [JavaScript]\ncategories: [学习笔记]\n---\n\n数组是值的有序集合。每个值叫做一个元素，而每个元素在数组中的位置，以数字表示，称为索引。\nJavaScript数组是JavaScript对象的特殊形式，数组索引实际上和碰巧是整数的属性名差不多。通常，数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象属性要快很多\nJavaScript数组可以包含任意数据类型\n\n\n\n## 创建数组\n1. 使用数组字面量`[]`\nJavaScript数组可以包含任意数据类型\n\t```javascript\n\tvar arr = [1,2,'hello',null,undefined,true,{'hei':'黑'},[1,2]];\n\tarr.length;//8\n\t```\n\t如果直接省略数组中某个值将被赋予`undefined`值\n\t\n\n\t```javascript\n\tvar count=[1,,3];\n\tcount[1];//undefined\n\tvar undefs = [,,];//数组有个两个元素都是undefined,索引已经定义\n\t```\n\t因为数组字面量语法允许有可选的结尾的逗号，故`[,,]`只有两个元素而非三个\n2. 调用构造函数`Array()`\n\n\t```javascript\n\tvar a = new Array()//空数组，等同于数组字面量[].\n\tvar b = new Array(10)//创建指定长度的数组，此时数组中没有元素，甚至索引属性‘0’、‘1’都未定义\n\tb.length();//10\n\t0 in b;//false\n\tvar c = new Array(1,2,'hello',null,undefined,true,{'hei':'黑'},[1,2])\n\t//创建一数组，构造函数的参数将会成为新数组的元素，使用个数组字面量比使用构造函数要简单\n\t```\n## 数组的读写\n使用`[]`操作符来访问修改数组中的一个元素\n\n```javascript\narr[0];//读取下标为0的元素，1\narr[8] = 'end';//在下标为8的地方写入数据\narr.length;//9\narr[-1.23] = true;//这将创建一个名为‘-1.23’的属性\narr['1000'] = 0;\narr.length;//9,不变\narr[1.000];//与a[1]相等\n```\n## 数组的长度\n每个数组有一个`length`属性，就是这个属性使其区别于其他常规的JavaScript对象。\n\n```javascript\narr.length;//9\narr.length = 3;//现在arr为[1,2,'hello']\narr.length = 0;//删除所有元素，a为[];\narr.length = 5;//长度为5，没有元素，就像new Array(5)\n```\n## 数组元素的添加和删除\n- 添加\n1. 添加数组元素最简单的方法：为新索引赋值：\n\n\t```javascript\n\ta = []   //空数组\n\ta[0] = 1;//[1]\n\ta[2] = 2;//[1,,2]\n\t```\n\n2. 使用`push()`和`pop()`\n\n\t```javascript\n\ta = [0];\n\ta.push(1);//向末尾添加一个元素。 [0,1]\n\ta.unshift(0);//向开头添加一个元素。[0,0,1]\n\t```\n\n- 删除\n1. `delete()`,类似于赋值undefined，不会影响数组长度\n\n\t```javascript\n\ta =[1,2,3];\n\tdelete a[1];\n\t1 in a;//false\n\ta.length;//3\n\t```\n2. `pop()` `shift()`\n\n\t```javascript\n\ta = [1,2,3];\n\ta.shift();//移除开头元素,[2,3]\n\ta.pop();//移除末尾元素，[2]\n\t```\n最后一个可删除，可添加的方法`splice()`,详细内容往下看\n## 数组的遍历\n1. `for`循环\n最常用\n2. `for in`循环，遍历的是索引\nfor in可以遍历对象，也可遍历数组，但遍历数组的时候有些问题\n\n\t> 1.index索引为字符串型数字，不能直接进行几何运算\n\t> 2.遍历顺序有可能不是按照实际数组的内部顺序\n\t> 3.使用for in会遍历数组所有的可枚举属性，包括原型。所以for in更适合遍历对象，不要使用for in遍历数组\n\n3. `for of`循环（ES6），遍历的是元素。\n\n\t```javascript\n\tArray.prototype.method=function(){\n\t　　console.log(this.length);\n\t}\n\tvar myArray=[1,2,4,5,6,7]\n\tmyArray.name=\"数组\";\n\tfor (var value of myArray) {\n\t  console.log(value);\n\t}\n\t//1 2 4 5 6 7\n\t```\n\n\t> \t记住，for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值。\n\t> \n\t> for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name\n4. `forEach()` (ES5)\n\t\n\t```javascript\n\tvar a = ['A', 'B', 'C'];\n\ta.forEach(function (element) {\n\t    console.log(element);\n\t});//A,B,C\n\t```\n\tforEach()方法无法再所有元素都传递给调用函数之前终止遍历。也就是说，没有像for循环中使用的相应的break语句。如果要提前终止，必须把forEach()方法放在一个try中，并抛出一个异常。\n## 数组方法\n- `Array.concat(item...)`\n该方法产生一个新数组，它包含一份array的赋值并把一个或多个item附加在它后面\n\n\t```javascript\n\tvar a = ['A', 'B', 'C'];\n\tvar b = ['x','y','z'];\n\tvar c = a.concat(b,true);\n\t//['A', 'B', 'C','x','y','z',true]\n\t```\n\n- `Array.join(separator)`\n把一个array构造成一个字符串。他把array中的每个元素使用`separator`连接起来，构成一个字符串，默认的`separator` 是`,`，无间隔连接使用空字符串`''`\n\n\t```javascript\n\tvar a = ['A', 'B', 'C'];\n\tvar c = a.join('');//'ABC'\n\t```\n- `Array.reverse()`\n翻转array里的元素的排序，并返回array本身：\n\n\t```javascript\n\tvar a = ['A', 'B', 'C'];\n\ta.reverse();//a和b都是['C','B','A']\n\t```\n- `Array.slice(start,end)`\n对array中的一段做浅复制。首先复制`array[start]`,一直复制到`array[end]`为止。`end`参数是可选的，默认是该数组的长度`array.length`。\n\t\n\t```javascript\n\tvar a = ['A', 'B', 'C'];\n\tb = a.slice(0,1);//['A']\n\tc = a.slice(1);//['B','C']\n\td = a.slice(4);//[]\n\t```\n- `Array.sort(comparefn)`\n`sort`方法对array中的内容进行排序。他不能正确的给一组数字排序：\n\n\t```javascript\n\tvar a = [4,8,15,16,23,42];\n\ta.sort();//Array(6) [15, 16, 23, 4, 42, 8]\n\t```\n\tJavaScript的默认比较函数把要排序的元素都视为字符串。，比较数字的时候，会把他们转换为字符串，于是得到了一个错误结果。\n\t幸运的是可以使用自己的比较函数，你的比较函数接受两个参数，并且如果相等返回0，如果第一个参数在前，则返回一个负数，如果第二个参数应在前，则返回一个正数。\n\t```javascript\n\tvar a = [4,8,15,16,23,42];\n\ta.sort(function(a,b){\n\t    return a-b\n\t});//Array(6) [4, 8, 15, 16, 23, 42]\n\t```\n- `array.splice (start,deleteCount,item...)`\n`splice`方法从array中移除一个或者多个元素，并使用新的item替换他们。参数`start`是从数组array中移除元素的开始位置。参数`deleteCount`是要移除的元素个数。如果有额外参数那些`item`会插入到被移除元素的位置上\n\n\t```javascript\n\tvar arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];\n\t// 从索引2开始删除3个元素,然后再添加两个元素:\n\tarr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']\n\tarr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']\n\t// 只删除,不添加:\n\tarr.splice(2, 2); // ['Google', 'Facebook']\n\tarr; // ['Microsoft', 'Apple', 'Oracle']\n\t// 只添加,不删除:\n\tarr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素\n\tarr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']\n\t```\n- `map()`(ES5)\n举例说明，比如我们有一个函数f(x)=x^2^，要把这个函数作用在一个数组[1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map实现如下:\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200214165103406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n\n\t```javascript\n\tfunction pow(x) {\n\t    return x * x;\n\t}\n\tvar arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\tvar results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]\n\tconsole.log(results);\n\t```\n- `filter()`\n它用于把Array的某些元素过滤掉，然后返回剩下的元素。\n和`map()`类似，Array的`filter()`也接收一个函数。和`map()`不同的是，`filter()`把传入的函数依次作用于每个元素，然后根据返回值是`true`还是`false`决定保留还是丢弃该元素。\n\n\t```javascript\n\t//删除偶数，保留奇数\n\tvar arr = [1, 2, 4, 5, 6, 9, 10, 15];\n\tvar r = arr.filter(function (x) {\n\t    return x % 2 !== 0;\n\t});\n\tr; // [1, 5, 9, 15]\n\t```\n\t`filter()`接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身：\n\t\n\n\t```javascript\n\t//去处Array的重复元素\n\tvar r,arr = ['apple', 'strawberry', 'banana', \n\t\t'pear', 'apple', 'orange', 'orange', 'strawberry'];\n\tr = arr.filter(function (element, index, self) {\n\t    return self.indexOf(element) === index;\n\t});\n\t```\n- `every()`与`some()`\n`every()`方法像是数学中的量词 $\\forall$：当且仅当对数组中的所有元素调用判定函数都返回`true`，他才返回`true`\n\n\t```javascript\n\tvar arr = ['Apple', 'pear', 'orange'];\n\tconsole.log(arr.every(function (s) {\n\t    return s.length > 0;\n\t})); // true, 因为每个元素都满足s.length>0\n\t```\n\t`some()`方法则像数学中的量词 $\\exists$：当数组中至少有一个元素调用判定函数返回`true`，他就返回`true`，否则返回`false`\n\t\n\n\t```javascript\n\tvar arr = ['Apple', 'pear', 'orange'];\n\t\tconsole.log(arr.every(function (s) {\n\t\t    return s.length <5;\n\t\t})); // true, 因为存在'pear'长度小于5\n\t```\n- `reduce()`和`reduceRight()`\n Array的`reduce()`把一个函数作用在这个Array的`[x1, x2, x3...]`上，这个函数必须接收两个参数，`reduce()`把结果继续和序列的下一个元素做累积计算，其效果就是：\n\n\t```\n\t[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)\n\t```\n\n\t```javascript\n\t//用reduce求和\n\tvar arr = [1, 3, 5, 7, 9];\n\tarr.reduce(function (x, y) {\n\t    return x + y;\n\t}); // 25\n\t```\n\t`reduceRight()`的原理相同，只是方向相反\n- `find(function(currentValue, index, arr))`（ES6）、`findIndex(function(currentValue, index, arr))`（ES6）、`indexOf(item,start)`、`lastIndexOf(item,start)`和`includes(searchElement, fromIndex)`\n`find()` 方法返回数组中满足提供的测试函数的第一个元素的值。`currentValue`必选参数，当前元素。`index`可选参数，当前元素索引。\n\n\t```javascript\n\tvar ages = [3, 10, 18, 20];\n\tfunction checkAdult(age) {\n\t    return age >= 18;\n\t}\n\tvar value = ages.find(checkAdult);\n\t//18\n\t```\n\t`findIndex()`方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回`-1`\n\t\n\n\t```javascript\n\tvar ages = [3, 10, 18, 20];\n\tfunction checkAdult(age) {\n\t\t    return age >= 18;\n\t\t}\n\tvar value = ages.findIndex(checkAdult);\n\t\t//2\n\t```\n\t`indexOf()`方法返回在数组中可以找到给定元素的第一个索引，如果不存在，则返回`-1`，`item`是要找的元素，`start`是开始位置（可选，默认`0`）\n\t```javascript\n\tvar fruits=[\"Banana\",\"Orange\",\"Apple\",\"Mango\",\"Banana\",\"Orange\",\"Apple\"];\n\tvar a = fruits.indexOf(\"Apple\",4);//6\n\t```\n\t`lastIndexOf()` 方法可返回一个指定的元素在数组中最后出现的位置，从该字符串的后面向前查找。如果要检索的元素没有出现，则该方法返回 `-1`\n\t```javascript\n\tvar fruits=[\"Banana\",\"Orange\",\"Apple\",\"Mango\",\"Banana\",\"Orange\",\"Apple\"];\n\tvar a = fruits.lastIndexOf(\"Apple\",4);//2\n\t```\n\t`includes()` 方法用来判断一个数组是否包含一个指定的值，如果是返回 `true`，否则`false`。`searchElement` 必须参数，需要查找的元素值。`fromIndex` 可选参数，从该索引处开始查找\n\t```javascript\n\t[1, 2, 3].includes(2);     // true\n\t[1, 2, 3].includes(4);     // false\n\t[1, 2, 3].includes(3, 3);  // false\n\t[1, 2, 3].includes(3, -1); // true\n\t[1, 2, NaN].includes(NaN); // true\n\t```\n- `Array.isArray(obj)`\n\tisArray() 方法用于判断一个对象是否为数组。如果对象是数组返回 true，否则返回 false。\n\t```javascript\n\tArray.isArray([]) ;// true\n\tArrray.isArray({});//false\n\t```\n## 类数组对象\nJavaScript数组的有一些特性是其他对象没有的：\n\n- 当有新的元素添加到数组时，自动更新length属性。\n- 设置length为一个较小值将截断数组。\n- 从Array.prototype 中级证一些有用的方法。\n- 其类属性为‘Array’ \n","slug":"Javascript学习笔记二","published":1,"updated":"2022-01-10T08:41:39.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckyo4lu6i0000nz6973jf9sth","content":"<p>数组是值的有序集合。每个值叫做一个元素，而每个元素在数组中的位置，以数字表示，称为索引。<br>JavaScript数组是JavaScript对象的特殊形式，数组索引实际上和碰巧是整数的属性名差不多。通常，数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象属性要快很多<br>JavaScript数组可以包含任意数据类型</p>\n<h2 id=\"创建数组\"><a href=\"#创建数组\" class=\"headerlink\" title=\"创建数组\"></a>创建数组</h2><ol>\n<li><p>使用数组字面量<code>[]</code><br>JavaScript数组可以包含任意数据类型</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&#x27;hello&#x27;</span>,<span class=\"hljs-literal\">null</span>,<span class=\"hljs-literal\">undefined</span>,<span class=\"hljs-literal\">true</span>,&#123;<span class=\"hljs-string\">&#x27;hei&#x27;</span>:<span class=\"hljs-string\">&#x27;黑&#x27;</span>&#125;,[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>]];<br>arr.length;<span class=\"hljs-comment\">//8</span><br></code></pre></td></tr></table></figure>\n<p> 如果直接省略数组中某个值将被赋予<code>undefined</code>值</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> count=[<span class=\"hljs-number\">1</span>,,<span class=\"hljs-number\">3</span>];<br>count[<span class=\"hljs-number\">1</span>];<span class=\"hljs-comment\">//undefined</span><br><span class=\"hljs-keyword\">var</span> undefs = [,,];<span class=\"hljs-comment\">//数组有个两个元素都是undefined,索引已经定义</span><br></code></pre></td></tr></table></figure>\n<p> 因为数组字面量语法允许有可选的结尾的逗号，故<code>[,,]</code>只有两个元素而非三个</p>\n</li>\n<li><p>调用构造函数<code>Array()</code></p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>()<span class=\"hljs-comment\">//空数组，等同于数组字面量[].</span><br><span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>(<span class=\"hljs-number\">10</span>)<span class=\"hljs-comment\">//创建指定长度的数组，此时数组中没有元素，甚至索引属性‘0’、‘1’都未定义</span><br>b.length();<span class=\"hljs-comment\">//10</span><br><span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">in</span> b;<span class=\"hljs-comment\">//false</span><br><span class=\"hljs-keyword\">var</span> c = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&#x27;hello&#x27;</span>,<span class=\"hljs-literal\">null</span>,<span class=\"hljs-literal\">undefined</span>,<span class=\"hljs-literal\">true</span>,&#123;<span class=\"hljs-string\">&#x27;hei&#x27;</span>:<span class=\"hljs-string\">&#x27;黑&#x27;</span>&#125;,[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>])<br><span class=\"hljs-comment\">//创建一数组，构造函数的参数将会成为新数组的元素，使用个数组字面量比使用构造函数要简单</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组的读写\"><a href=\"#数组的读写\" class=\"headerlink\" title=\"数组的读写\"></a>数组的读写</h2><p>使用<code>[]</code>操作符来访问修改数组中的一个元素</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">arr[<span class=\"hljs-number\">0</span>];<span class=\"hljs-comment\">//读取下标为0的元素，1</span><br>arr[<span class=\"hljs-number\">8</span>] = <span class=\"hljs-string\">&#x27;end&#x27;</span>;<span class=\"hljs-comment\">//在下标为8的地方写入数据</span><br>arr.length;<span class=\"hljs-comment\">//9</span><br>arr[-<span class=\"hljs-number\">1.23</span>] = <span class=\"hljs-literal\">true</span>;<span class=\"hljs-comment\">//这将创建一个名为‘-1.23’的属性</span><br>arr[<span class=\"hljs-string\">&#x27;1000&#x27;</span>] = <span class=\"hljs-number\">0</span>;<br>arr.length;<span class=\"hljs-comment\">//9,不变</span><br>arr[<span class=\"hljs-number\">1.000</span>];<span class=\"hljs-comment\">//与a[1]相等</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组的长度\"><a href=\"#数组的长度\" class=\"headerlink\" title=\"数组的长度\"></a>数组的长度</h2><p>每个数组有一个<code>length</code>属性，就是这个属性使其区别于其他常规的JavaScript对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">arr.length;<span class=\"hljs-comment\">//9</span><br>arr.length = <span class=\"hljs-number\">3</span>;<span class=\"hljs-comment\">//现在arr为[1,2,&#x27;hello&#x27;]</span><br>arr.length = <span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//删除所有元素，a为[];</span><br>arr.length = <span class=\"hljs-number\">5</span>;<span class=\"hljs-comment\">//长度为5，没有元素，就像new Array(5)</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组元素的添加和删除\"><a href=\"#数组元素的添加和删除\" class=\"headerlink\" title=\"数组元素的添加和删除\"></a>数组元素的添加和删除</h2><ul>\n<li>添加</li>\n</ul>\n<ol>\n<li><p>添加数组元素最简单的方法：为新索引赋值：</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">a = []   <span class=\"hljs-comment\">//空数组</span><br>a[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//[1]</span><br>a[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">2</span>;<span class=\"hljs-comment\">//[1,,2]</span><br></code></pre></td></tr></table></figure></li>\n<li><p>使用<code>push()</code>和<code>pop()</code></p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">a = [<span class=\"hljs-number\">0</span>];<br>a.push(<span class=\"hljs-number\">1</span>);<span class=\"hljs-comment\">//向末尾添加一个元素。 [0,1]</span><br>a.unshift(<span class=\"hljs-number\">0</span>);<span class=\"hljs-comment\">//向开头添加一个元素。[0,0,1]</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>删除</li>\n</ul>\n<ol>\n<li><p><code>delete()</code>,类似于赋值undefined，不会影响数组长度</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">a =[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];<br><span class=\"hljs-keyword\">delete</span> a[<span class=\"hljs-number\">1</span>];<br><span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">in</span> a;<span class=\"hljs-comment\">//false</span><br>a.length;<span class=\"hljs-comment\">//3</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>pop()</code> <code>shift()</code></p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">a = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];<br>a.shift();<span class=\"hljs-comment\">//移除开头元素,[2,3]</span><br>a.pop();<span class=\"hljs-comment\">//移除末尾元素，[2]</span><br></code></pre></td></tr></table></figure>\n<p>最后一个可删除，可添加的方法<code>splice()</code>,详细内容往下看</p>\n<h2 id=\"数组的遍历\"><a href=\"#数组的遍历\" class=\"headerlink\" title=\"数组的遍历\"></a>数组的遍历</h2></li>\n<li><p><code>for</code>循环<br>最常用</p>\n</li>\n<li><p><code>for in</code>循环，遍历的是索引<br>for in可以遍历对象，也可遍历数组，但遍历数组的时候有些问题</p>\n<blockquote>\n<p>1.index索引为字符串型数字，不能直接进行几何运算<br>2.遍历顺序有可能不是按照实际数组的内部顺序<br>3.使用for in会遍历数组所有的可枚举属性，包括原型。所以for in更适合遍历对象，不要使用for in遍历数组</p>\n</blockquote>\n</li>\n<li><p><code>for of</code>循环（ES6），遍历的是元素。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">Array</span>.prototype.method=<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>　　<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.length);<br>&#125;<br><span class=\"hljs-keyword\">var</span> myArray=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>]<br>myArray.name=<span class=\"hljs-string\">&quot;数组&quot;</span>;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> value <span class=\"hljs-keyword\">of</span> myArray) &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(value);<br>&#125;<br><span class=\"hljs-comment\">//1 2 4 5 6 7</span><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<pre><code>记住，for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值。\n</code></pre>\n<p>for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name</p>\n</blockquote>\n</li>\n<li><p><code>forEach()</code> (ES5)</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-string\">&#x27;A&#x27;</span>, <span class=\"hljs-string\">&#x27;B&#x27;</span>, <span class=\"hljs-string\">&#x27;C&#x27;</span>];<br>a.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">element</span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(element);<br>&#125;);<span class=\"hljs-comment\">//A,B,C</span><br></code></pre></td></tr></table></figure>\n<p> forEach()方法无法再所有元素都传递给调用函数之前终止遍历。也就是说，没有像for循环中使用的相应的break语句。如果要提前终止，必须把forEach()方法放在一个try中，并抛出一个异常。</p>\n<h2 id=\"数组方法\"><a href=\"#数组方法\" class=\"headerlink\" title=\"数组方法\"></a>数组方法</h2></li>\n</ol>\n<ul>\n<li><p><code>Array.concat(item...)</code><br>该方法产生一个新数组，它包含一份array的赋值并把一个或多个item附加在它后面</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-string\">&#x27;A&#x27;</span>, <span class=\"hljs-string\">&#x27;B&#x27;</span>, <span class=\"hljs-string\">&#x27;C&#x27;</span>];<br><span class=\"hljs-keyword\">var</span> b = [<span class=\"hljs-string\">&#x27;x&#x27;</span>,<span class=\"hljs-string\">&#x27;y&#x27;</span>,<span class=\"hljs-string\">&#x27;z&#x27;</span>];<br><span class=\"hljs-keyword\">var</span> c = a.concat(b,<span class=\"hljs-literal\">true</span>);<br><span class=\"hljs-comment\">//[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;,true]</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>Array.join(separator)</code><br>把一个array构造成一个字符串。他把array中的每个元素使用<code>separator</code>连接起来，构成一个字符串，默认的<code>separator</code> 是<code>,</code>，无间隔连接使用空字符串<code>&#39;&#39;</code></p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-string\">&#x27;A&#x27;</span>, <span class=\"hljs-string\">&#x27;B&#x27;</span>, <span class=\"hljs-string\">&#x27;C&#x27;</span>];<br><span class=\"hljs-keyword\">var</span> c = a.join(<span class=\"hljs-string\">&#x27;&#x27;</span>);<span class=\"hljs-comment\">//&#x27;ABC&#x27;</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>Array.reverse()</code><br>翻转array里的元素的排序，并返回array本身：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-string\">&#x27;A&#x27;</span>, <span class=\"hljs-string\">&#x27;B&#x27;</span>, <span class=\"hljs-string\">&#x27;C&#x27;</span>];<br>a.reverse();<span class=\"hljs-comment\">//a和b都是[&#x27;C&#x27;,&#x27;B&#x27;,&#x27;A&#x27;]</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>Array.slice(start,end)</code><br>对array中的一段做浅复制。首先复制<code>array[start]</code>,一直复制到<code>array[end]</code>为止。<code>end</code>参数是可选的，默认是该数组的长度<code>array.length</code>。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-string\">&#x27;A&#x27;</span>, <span class=\"hljs-string\">&#x27;B&#x27;</span>, <span class=\"hljs-string\">&#x27;C&#x27;</span>];<br>b = a.slice(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>);<span class=\"hljs-comment\">//[&#x27;A&#x27;]</span><br>c = a.slice(<span class=\"hljs-number\">1</span>);<span class=\"hljs-comment\">//[&#x27;B&#x27;,&#x27;C&#x27;]</span><br>d = a.slice(<span class=\"hljs-number\">4</span>);<span class=\"hljs-comment\">//[]</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>Array.sort(comparefn)</code><br><code>sort</code>方法对array中的内容进行排序。他不能正确的给一组数字排序：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">15</span>,<span class=\"hljs-number\">16</span>,<span class=\"hljs-number\">23</span>,<span class=\"hljs-number\">42</span>];<br>a.sort();<span class=\"hljs-comment\">//Array(6) [15, 16, 23, 4, 42, 8]</span><br></code></pre></td></tr></table></figure>\n<p>  JavaScript的默认比较函数把要排序的元素都视为字符串。，比较数字的时候，会把他们转换为字符串，于是得到了一个错误结果。<br>  幸运的是可以使用自己的比较函数，你的比较函数接受两个参数，并且如果相等返回0，如果第一个参数在前，则返回一个负数，如果第二个参数应在前，则返回一个正数。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">15</span>,<span class=\"hljs-number\">16</span>,<span class=\"hljs-number\">23</span>,<span class=\"hljs-number\">42</span>];<br>a.sort(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a,b</span>)</span>&#123;<br>    <span class=\"hljs-keyword\">return</span> a-b<br>&#125;);<span class=\"hljs-comment\">//Array(6) [4, 8, 15, 16, 23, 42]</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>array.splice (start,deleteCount,item...)</code><br><code>splice</code>方法从array中移除一个或者多个元素，并使用新的item替换他们。参数<code>start</code>是从数组array中移除元素的开始位置。参数<code>deleteCount</code>是要移除的元素个数。如果有额外参数那些<code>item</code>会插入到被移除元素的位置上</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-string\">&#x27;Microsoft&#x27;</span>, <span class=\"hljs-string\">&#x27;Apple&#x27;</span>, <span class=\"hljs-string\">&#x27;Yahoo&#x27;</span>, <span class=\"hljs-string\">&#x27;AOL&#x27;</span>, <span class=\"hljs-string\">&#x27;Excite&#x27;</span>, <span class=\"hljs-string\">&#x27;Oracle&#x27;</span>];<br><span class=\"hljs-comment\">// 从索引2开始删除3个元素,然后再添加两个元素:</span><br>arr.splice(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&#x27;Google&#x27;</span>, <span class=\"hljs-string\">&#x27;Facebook&#x27;</span>); <span class=\"hljs-comment\">// 返回删除的元素 [&#x27;Yahoo&#x27;, &#x27;AOL&#x27;, &#x27;Excite&#x27;]</span><br>arr; <span class=\"hljs-comment\">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span><br><span class=\"hljs-comment\">// 只删除,不添加:</span><br>arr.splice(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// [&#x27;Google&#x27;, &#x27;Facebook&#x27;]</span><br>arr; <span class=\"hljs-comment\">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Oracle&#x27;]</span><br><span class=\"hljs-comment\">// 只添加,不删除:</span><br>arr.splice(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;Google&#x27;</span>, <span class=\"hljs-string\">&#x27;Facebook&#x27;</span>); <span class=\"hljs-comment\">// 返回[],因为没有删除任何元素</span><br>arr; <span class=\"hljs-comment\">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>map()</code>(ES5)<br>举例说明，比如我们有一个函数f(x)=x^2^，要把这个函数作用在一个数组[1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map实现如下:<br><img src=\"https://img-blog.csdnimg.cn/20200214165103406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">pow</span>(<span class=\"hljs-params\">x</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> x * x;<br>&#125;<br><span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>];<br><span class=\"hljs-keyword\">var</span> results = arr.map(pow); <span class=\"hljs-comment\">// [1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class=\"hljs-built_in\">console</span>.log(results);<br></code></pre></td></tr></table></figure></li>\n<li><p><code>filter()</code><br>它用于把Array的某些元素过滤掉，然后返回剩下的元素。<br>和<code>map()</code>类似，Array的<code>filter()</code>也接收一个函数。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>true</code>还是<code>false</code>决定保留还是丢弃该元素。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//删除偶数，保留奇数</span><br><span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">15</span>];<br><span class=\"hljs-keyword\">var</span> r = arr.filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> x % <span class=\"hljs-number\">2</span> !== <span class=\"hljs-number\">0</span>;<br>&#125;);<br>r; <span class=\"hljs-comment\">// [1, 5, 9, 15]</span><br></code></pre></td></tr></table></figure>\n<p>  <code>filter()</code>接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//去处Array的重复元素</span><br><span class=\"hljs-keyword\">var</span> r,arr = [<span class=\"hljs-string\">&#x27;apple&#x27;</span>, <span class=\"hljs-string\">&#x27;strawberry&#x27;</span>, <span class=\"hljs-string\">&#x27;banana&#x27;</span>, <br>\t<span class=\"hljs-string\">&#x27;pear&#x27;</span>, <span class=\"hljs-string\">&#x27;apple&#x27;</span>, <span class=\"hljs-string\">&#x27;orange&#x27;</span>, <span class=\"hljs-string\">&#x27;orange&#x27;</span>, <span class=\"hljs-string\">&#x27;strawberry&#x27;</span>];<br>r = arr.filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">element, index, self</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> self.indexOf(element) === index;<br>&#125;);<br></code></pre></td></tr></table></figure></li>\n<li><p><code>every()</code>与<code>some()</code><br><code>every()</code>方法像是数学中的量词 $\\forall$：当且仅当对数组中的所有元素调用判定函数都返回<code>true</code>，他才返回<code>true</code></p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-string\">&#x27;Apple&#x27;</span>, <span class=\"hljs-string\">&#x27;pear&#x27;</span>, <span class=\"hljs-string\">&#x27;orange&#x27;</span>];<br><span class=\"hljs-built_in\">console</span>.log(arr.every(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">s</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> s.length &gt; <span class=\"hljs-number\">0</span>;<br>&#125;)); <span class=\"hljs-comment\">// true, 因为每个元素都满足s.length&gt;0</span><br></code></pre></td></tr></table></figure>\n<p>  <code>some()</code>方法则像数学中的量词 $\\exists$：当数组中至少有一个元素调用判定函数返回<code>true</code>，他就返回<code>true</code>，否则返回<code>false</code></p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-string\">&#x27;Apple&#x27;</span>, <span class=\"hljs-string\">&#x27;pear&#x27;</span>, <span class=\"hljs-string\">&#x27;orange&#x27;</span>];<br>\t<span class=\"hljs-built_in\">console</span>.log(arr.every(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">s</span>) </span>&#123;<br>\t    <span class=\"hljs-keyword\">return</span> s.length &lt;<span class=\"hljs-number\">5</span>;<br>\t&#125;)); <span class=\"hljs-comment\">// true, 因为存在&#x27;pear&#x27;长度小于5</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>reduce()</code>和<code>reduceRight()</code><br>Array的<code>reduce()</code>把一个函数作用在这个Array的<code>[x1, x2, x3...]</code>上，这个函数必须接收两个参数，<code>reduce()</code>把结果继续和序列的下一个元素做累积计算，其效果就是：</p>\n  <figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs llvm\">[<span class=\"hljs-keyword\">x</span><span class=\"hljs-number\">1</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-keyword\">x</span><span class=\"hljs-number\">2</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-keyword\">x</span><span class=\"hljs-number\">3</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-keyword\">x</span><span class=\"hljs-number\">4</span>].reduce(f) <span class=\"hljs-operator\">=</span> f(f(f(<span class=\"hljs-keyword\">x</span><span class=\"hljs-number\">1</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-keyword\">x</span><span class=\"hljs-number\">2</span>)<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-keyword\">x</span><span class=\"hljs-number\">3</span>)<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-keyword\">x</span><span class=\"hljs-number\">4</span>)<br></code></pre></td></tr></table></figure>\n\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//用reduce求和</span><br><span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">9</span>];<br>arr.reduce(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x, y</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> x + y;<br>&#125;); <span class=\"hljs-comment\">// 25</span><br></code></pre></td></tr></table></figure>\n<p>  <code>reduceRight()</code>的原理相同，只是方向相反</p>\n</li>\n<li><p><code>find(function(currentValue, index, arr))</code>（ES6）、<code>findIndex(function(currentValue, index, arr))</code>（ES6）、<code>indexOf(item,start)</code>、<code>lastIndexOf(item,start)</code>和<code>includes(searchElement, fromIndex)</code><br><code>find()</code> 方法返回数组中满足提供的测试函数的第一个元素的值。<code>currentValue</code>必选参数，当前元素。<code>index</code>可选参数，当前元素索引。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> ages = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">18</span>, <span class=\"hljs-number\">20</span>];<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">checkAdult</span>(<span class=\"hljs-params\">age</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> age &gt;= <span class=\"hljs-number\">18</span>;<br>&#125;<br><span class=\"hljs-keyword\">var</span> value = ages.find(checkAdult);<br><span class=\"hljs-comment\">//18</span><br></code></pre></td></tr></table></figure>\n<p>  <code>findIndex()</code>方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回<code>-1</code></p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> ages = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">18</span>, <span class=\"hljs-number\">20</span>];<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">checkAdult</span>(<span class=\"hljs-params\">age</span>) </span>&#123;<br>\t    <span class=\"hljs-keyword\">return</span> age &gt;= <span class=\"hljs-number\">18</span>;<br>\t&#125;<br><span class=\"hljs-keyword\">var</span> value = ages.findIndex(checkAdult);<br>\t<span class=\"hljs-comment\">//2</span><br></code></pre></td></tr></table></figure>\n<p>  <code>indexOf()</code>方法返回在数组中可以找到给定元素的第一个索引，如果不存在，则返回<code>-1</code>，<code>item</code>是要找的元素，<code>start</code>是开始位置（可选，默认<code>0</code>）</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> fruits=[<span class=\"hljs-string\">&quot;Banana&quot;</span>,<span class=\"hljs-string\">&quot;Orange&quot;</span>,<span class=\"hljs-string\">&quot;Apple&quot;</span>,<span class=\"hljs-string\">&quot;Mango&quot;</span>,<span class=\"hljs-string\">&quot;Banana&quot;</span>,<span class=\"hljs-string\">&quot;Orange&quot;</span>,<span class=\"hljs-string\">&quot;Apple&quot;</span>];<br><span class=\"hljs-keyword\">var</span> a = fruits.indexOf(<span class=\"hljs-string\">&quot;Apple&quot;</span>,<span class=\"hljs-number\">4</span>);<span class=\"hljs-comment\">//6</span><br></code></pre></td></tr></table></figure>\n<p>  <code>lastIndexOf()</code> 方法可返回一个指定的元素在数组中最后出现的位置，从该字符串的后面向前查找。如果要检索的元素没有出现，则该方法返回 <code>-1</code></p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> fruits=[<span class=\"hljs-string\">&quot;Banana&quot;</span>,<span class=\"hljs-string\">&quot;Orange&quot;</span>,<span class=\"hljs-string\">&quot;Apple&quot;</span>,<span class=\"hljs-string\">&quot;Mango&quot;</span>,<span class=\"hljs-string\">&quot;Banana&quot;</span>,<span class=\"hljs-string\">&quot;Orange&quot;</span>,<span class=\"hljs-string\">&quot;Apple&quot;</span>];<br><span class=\"hljs-keyword\">var</span> a = fruits.lastIndexOf(<span class=\"hljs-string\">&quot;Apple&quot;</span>,<span class=\"hljs-number\">4</span>);<span class=\"hljs-comment\">//2</span><br></code></pre></td></tr></table></figure>\n<p>  <code>includes()</code> 方法用来判断一个数组是否包含一个指定的值，如果是返回 <code>true</code>，否则<code>false</code>。<code>searchElement</code> 必须参数，需要查找的元素值。<code>fromIndex</code> 可选参数，从该索引处开始查找</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].includes(<span class=\"hljs-number\">2</span>);     <span class=\"hljs-comment\">// true</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].includes(<span class=\"hljs-number\">4</span>);     <span class=\"hljs-comment\">// false</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].includes(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>);  <span class=\"hljs-comment\">// false</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].includes(<span class=\"hljs-number\">3</span>, -<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// true</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">NaN</span>].includes(<span class=\"hljs-literal\">NaN</span>); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>Array.isArray(obj)</code><br>  isArray() 方法用于判断一个对象是否为数组。如果对象是数组返回 true，否则返回 false。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">Array</span>.isArray([]) ;<span class=\"hljs-comment\">// true</span><br>Arrray.isArray(&#123;&#125;);<span class=\"hljs-comment\">//false</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"类数组对象\"><a href=\"#类数组对象\" class=\"headerlink\" title=\"类数组对象\"></a>类数组对象</h2><p>JavaScript数组的有一些特性是其他对象没有的：</p>\n</li>\n<li><p>当有新的元素添加到数组时，自动更新length属性。</p>\n</li>\n<li><p>设置length为一个较小值将截断数组。</p>\n</li>\n<li><p>从Array.prototype 中级证一些有用的方法。</p>\n</li>\n<li><p>其类属性为‘Array’ </p>\n</li>\n</ul>\n","site":{"data":{}},"wordcount":7349,"excerpt":"","more":"<p>数组是值的有序集合。每个值叫做一个元素，而每个元素在数组中的位置，以数字表示，称为索引。<br>JavaScript数组是JavaScript对象的特殊形式，数组索引实际上和碰巧是整数的属性名差不多。通常，数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象属性要快很多<br>JavaScript数组可以包含任意数据类型</p>\n<h2 id=\"创建数组\"><a href=\"#创建数组\" class=\"headerlink\" title=\"创建数组\"></a>创建数组</h2><ol>\n<li><p>使用数组字面量<code>[]</code><br>JavaScript数组可以包含任意数据类型</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&#x27;hello&#x27;</span>,<span class=\"hljs-literal\">null</span>,<span class=\"hljs-literal\">undefined</span>,<span class=\"hljs-literal\">true</span>,&#123;<span class=\"hljs-string\">&#x27;hei&#x27;</span>:<span class=\"hljs-string\">&#x27;黑&#x27;</span>&#125;,[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>]];<br>arr.length;<span class=\"hljs-comment\">//8</span><br></code></pre></td></tr></table></figure>\n<p> 如果直接省略数组中某个值将被赋予<code>undefined</code>值</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> count=[<span class=\"hljs-number\">1</span>,,<span class=\"hljs-number\">3</span>];<br>count[<span class=\"hljs-number\">1</span>];<span class=\"hljs-comment\">//undefined</span><br><span class=\"hljs-keyword\">var</span> undefs = [,,];<span class=\"hljs-comment\">//数组有个两个元素都是undefined,索引已经定义</span><br></code></pre></td></tr></table></figure>\n<p> 因为数组字面量语法允许有可选的结尾的逗号，故<code>[,,]</code>只有两个元素而非三个</p>\n</li>\n<li><p>调用构造函数<code>Array()</code></p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>()<span class=\"hljs-comment\">//空数组，等同于数组字面量[].</span><br><span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>(<span class=\"hljs-number\">10</span>)<span class=\"hljs-comment\">//创建指定长度的数组，此时数组中没有元素，甚至索引属性‘0’、‘1’都未定义</span><br>b.length();<span class=\"hljs-comment\">//10</span><br><span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">in</span> b;<span class=\"hljs-comment\">//false</span><br><span class=\"hljs-keyword\">var</span> c = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-string\">&#x27;hello&#x27;</span>,<span class=\"hljs-literal\">null</span>,<span class=\"hljs-literal\">undefined</span>,<span class=\"hljs-literal\">true</span>,&#123;<span class=\"hljs-string\">&#x27;hei&#x27;</span>:<span class=\"hljs-string\">&#x27;黑&#x27;</span>&#125;,[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>])<br><span class=\"hljs-comment\">//创建一数组，构造函数的参数将会成为新数组的元素，使用个数组字面量比使用构造函数要简单</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组的读写\"><a href=\"#数组的读写\" class=\"headerlink\" title=\"数组的读写\"></a>数组的读写</h2><p>使用<code>[]</code>操作符来访问修改数组中的一个元素</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">arr[<span class=\"hljs-number\">0</span>];<span class=\"hljs-comment\">//读取下标为0的元素，1</span><br>arr[<span class=\"hljs-number\">8</span>] = <span class=\"hljs-string\">&#x27;end&#x27;</span>;<span class=\"hljs-comment\">//在下标为8的地方写入数据</span><br>arr.length;<span class=\"hljs-comment\">//9</span><br>arr[-<span class=\"hljs-number\">1.23</span>] = <span class=\"hljs-literal\">true</span>;<span class=\"hljs-comment\">//这将创建一个名为‘-1.23’的属性</span><br>arr[<span class=\"hljs-string\">&#x27;1000&#x27;</span>] = <span class=\"hljs-number\">0</span>;<br>arr.length;<span class=\"hljs-comment\">//9,不变</span><br>arr[<span class=\"hljs-number\">1.000</span>];<span class=\"hljs-comment\">//与a[1]相等</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组的长度\"><a href=\"#数组的长度\" class=\"headerlink\" title=\"数组的长度\"></a>数组的长度</h2><p>每个数组有一个<code>length</code>属性，就是这个属性使其区别于其他常规的JavaScript对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">arr.length;<span class=\"hljs-comment\">//9</span><br>arr.length = <span class=\"hljs-number\">3</span>;<span class=\"hljs-comment\">//现在arr为[1,2,&#x27;hello&#x27;]</span><br>arr.length = <span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//删除所有元素，a为[];</span><br>arr.length = <span class=\"hljs-number\">5</span>;<span class=\"hljs-comment\">//长度为5，没有元素，就像new Array(5)</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数组元素的添加和删除\"><a href=\"#数组元素的添加和删除\" class=\"headerlink\" title=\"数组元素的添加和删除\"></a>数组元素的添加和删除</h2><ul>\n<li>添加</li>\n</ul>\n<ol>\n<li><p>添加数组元素最简单的方法：为新索引赋值：</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">a = []   <span class=\"hljs-comment\">//空数组</span><br>a[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//[1]</span><br>a[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">2</span>;<span class=\"hljs-comment\">//[1,,2]</span><br></code></pre></td></tr></table></figure></li>\n<li><p>使用<code>push()</code>和<code>pop()</code></p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">a = [<span class=\"hljs-number\">0</span>];<br>a.push(<span class=\"hljs-number\">1</span>);<span class=\"hljs-comment\">//向末尾添加一个元素。 [0,1]</span><br>a.unshift(<span class=\"hljs-number\">0</span>);<span class=\"hljs-comment\">//向开头添加一个元素。[0,0,1]</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>删除</li>\n</ul>\n<ol>\n<li><p><code>delete()</code>,类似于赋值undefined，不会影响数组长度</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">a =[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];<br><span class=\"hljs-keyword\">delete</span> a[<span class=\"hljs-number\">1</span>];<br><span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">in</span> a;<span class=\"hljs-comment\">//false</span><br>a.length;<span class=\"hljs-comment\">//3</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>pop()</code> <code>shift()</code></p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">a = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];<br>a.shift();<span class=\"hljs-comment\">//移除开头元素,[2,3]</span><br>a.pop();<span class=\"hljs-comment\">//移除末尾元素，[2]</span><br></code></pre></td></tr></table></figure>\n<p>最后一个可删除，可添加的方法<code>splice()</code>,详细内容往下看</p>\n<h2 id=\"数组的遍历\"><a href=\"#数组的遍历\" class=\"headerlink\" title=\"数组的遍历\"></a>数组的遍历</h2></li>\n<li><p><code>for</code>循环<br>最常用</p>\n</li>\n<li><p><code>for in</code>循环，遍历的是索引<br>for in可以遍历对象，也可遍历数组，但遍历数组的时候有些问题</p>\n<blockquote>\n<p>1.index索引为字符串型数字，不能直接进行几何运算<br>2.遍历顺序有可能不是按照实际数组的内部顺序<br>3.使用for in会遍历数组所有的可枚举属性，包括原型。所以for in更适合遍历对象，不要使用for in遍历数组</p>\n</blockquote>\n</li>\n<li><p><code>for of</code>循环（ES6），遍历的是元素。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">Array</span>.prototype.method=<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>　　<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.length);<br>&#125;<br><span class=\"hljs-keyword\">var</span> myArray=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>]<br>myArray.name=<span class=\"hljs-string\">&quot;数组&quot;</span>;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> value <span class=\"hljs-keyword\">of</span> myArray) &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(value);<br>&#125;<br><span class=\"hljs-comment\">//1 2 4 5 6 7</span><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<pre><code>记住，for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值。\n</code></pre>\n<p>for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name</p>\n</blockquote>\n</li>\n<li><p><code>forEach()</code> (ES5)</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-string\">&#x27;A&#x27;</span>, <span class=\"hljs-string\">&#x27;B&#x27;</span>, <span class=\"hljs-string\">&#x27;C&#x27;</span>];<br>a.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">element</span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(element);<br>&#125;);<span class=\"hljs-comment\">//A,B,C</span><br></code></pre></td></tr></table></figure>\n<p> forEach()方法无法再所有元素都传递给调用函数之前终止遍历。也就是说，没有像for循环中使用的相应的break语句。如果要提前终止，必须把forEach()方法放在一个try中，并抛出一个异常。</p>\n<h2 id=\"数组方法\"><a href=\"#数组方法\" class=\"headerlink\" title=\"数组方法\"></a>数组方法</h2></li>\n</ol>\n<ul>\n<li><p><code>Array.concat(item...)</code><br>该方法产生一个新数组，它包含一份array的赋值并把一个或多个item附加在它后面</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-string\">&#x27;A&#x27;</span>, <span class=\"hljs-string\">&#x27;B&#x27;</span>, <span class=\"hljs-string\">&#x27;C&#x27;</span>];<br><span class=\"hljs-keyword\">var</span> b = [<span class=\"hljs-string\">&#x27;x&#x27;</span>,<span class=\"hljs-string\">&#x27;y&#x27;</span>,<span class=\"hljs-string\">&#x27;z&#x27;</span>];<br><span class=\"hljs-keyword\">var</span> c = a.concat(b,<span class=\"hljs-literal\">true</span>);<br><span class=\"hljs-comment\">//[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;,true]</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>Array.join(separator)</code><br>把一个array构造成一个字符串。他把array中的每个元素使用<code>separator</code>连接起来，构成一个字符串，默认的<code>separator</code> 是<code>,</code>，无间隔连接使用空字符串<code>&#39;&#39;</code></p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-string\">&#x27;A&#x27;</span>, <span class=\"hljs-string\">&#x27;B&#x27;</span>, <span class=\"hljs-string\">&#x27;C&#x27;</span>];<br><span class=\"hljs-keyword\">var</span> c = a.join(<span class=\"hljs-string\">&#x27;&#x27;</span>);<span class=\"hljs-comment\">//&#x27;ABC&#x27;</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>Array.reverse()</code><br>翻转array里的元素的排序，并返回array本身：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-string\">&#x27;A&#x27;</span>, <span class=\"hljs-string\">&#x27;B&#x27;</span>, <span class=\"hljs-string\">&#x27;C&#x27;</span>];<br>a.reverse();<span class=\"hljs-comment\">//a和b都是[&#x27;C&#x27;,&#x27;B&#x27;,&#x27;A&#x27;]</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>Array.slice(start,end)</code><br>对array中的一段做浅复制。首先复制<code>array[start]</code>,一直复制到<code>array[end]</code>为止。<code>end</code>参数是可选的，默认是该数组的长度<code>array.length</code>。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-string\">&#x27;A&#x27;</span>, <span class=\"hljs-string\">&#x27;B&#x27;</span>, <span class=\"hljs-string\">&#x27;C&#x27;</span>];<br>b = a.slice(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span>);<span class=\"hljs-comment\">//[&#x27;A&#x27;]</span><br>c = a.slice(<span class=\"hljs-number\">1</span>);<span class=\"hljs-comment\">//[&#x27;B&#x27;,&#x27;C&#x27;]</span><br>d = a.slice(<span class=\"hljs-number\">4</span>);<span class=\"hljs-comment\">//[]</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>Array.sort(comparefn)</code><br><code>sort</code>方法对array中的内容进行排序。他不能正确的给一组数字排序：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">15</span>,<span class=\"hljs-number\">16</span>,<span class=\"hljs-number\">23</span>,<span class=\"hljs-number\">42</span>];<br>a.sort();<span class=\"hljs-comment\">//Array(6) [15, 16, 23, 4, 42, 8]</span><br></code></pre></td></tr></table></figure>\n<p>  JavaScript的默认比较函数把要排序的元素都视为字符串。，比较数字的时候，会把他们转换为字符串，于是得到了一个错误结果。<br>  幸运的是可以使用自己的比较函数，你的比较函数接受两个参数，并且如果相等返回0，如果第一个参数在前，则返回一个负数，如果第二个参数应在前，则返回一个正数。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">15</span>,<span class=\"hljs-number\">16</span>,<span class=\"hljs-number\">23</span>,<span class=\"hljs-number\">42</span>];<br>a.sort(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a,b</span>)</span>&#123;<br>    <span class=\"hljs-keyword\">return</span> a-b<br>&#125;);<span class=\"hljs-comment\">//Array(6) [4, 8, 15, 16, 23, 42]</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>array.splice (start,deleteCount,item...)</code><br><code>splice</code>方法从array中移除一个或者多个元素，并使用新的item替换他们。参数<code>start</code>是从数组array中移除元素的开始位置。参数<code>deleteCount</code>是要移除的元素个数。如果有额外参数那些<code>item</code>会插入到被移除元素的位置上</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-string\">&#x27;Microsoft&#x27;</span>, <span class=\"hljs-string\">&#x27;Apple&#x27;</span>, <span class=\"hljs-string\">&#x27;Yahoo&#x27;</span>, <span class=\"hljs-string\">&#x27;AOL&#x27;</span>, <span class=\"hljs-string\">&#x27;Excite&#x27;</span>, <span class=\"hljs-string\">&#x27;Oracle&#x27;</span>];<br><span class=\"hljs-comment\">// 从索引2开始删除3个元素,然后再添加两个元素:</span><br>arr.splice(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&#x27;Google&#x27;</span>, <span class=\"hljs-string\">&#x27;Facebook&#x27;</span>); <span class=\"hljs-comment\">// 返回删除的元素 [&#x27;Yahoo&#x27;, &#x27;AOL&#x27;, &#x27;Excite&#x27;]</span><br>arr; <span class=\"hljs-comment\">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span><br><span class=\"hljs-comment\">// 只删除,不添加:</span><br>arr.splice(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// [&#x27;Google&#x27;, &#x27;Facebook&#x27;]</span><br>arr; <span class=\"hljs-comment\">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Oracle&#x27;]</span><br><span class=\"hljs-comment\">// 只添加,不删除:</span><br>arr.splice(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;Google&#x27;</span>, <span class=\"hljs-string\">&#x27;Facebook&#x27;</span>); <span class=\"hljs-comment\">// 返回[],因为没有删除任何元素</span><br>arr; <span class=\"hljs-comment\">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>map()</code>(ES5)<br>举例说明，比如我们有一个函数f(x)=x^2^，要把这个函数作用在一个数组[1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map实现如下:<br><img src=\"https://img-blog.csdnimg.cn/20200214165103406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">pow</span>(<span class=\"hljs-params\">x</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> x * x;<br>&#125;<br><span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>];<br><span class=\"hljs-keyword\">var</span> results = arr.map(pow); <span class=\"hljs-comment\">// [1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class=\"hljs-built_in\">console</span>.log(results);<br></code></pre></td></tr></table></figure></li>\n<li><p><code>filter()</code><br>它用于把Array的某些元素过滤掉，然后返回剩下的元素。<br>和<code>map()</code>类似，Array的<code>filter()</code>也接收一个函数。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>true</code>还是<code>false</code>决定保留还是丢弃该元素。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//删除偶数，保留奇数</span><br><span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">15</span>];<br><span class=\"hljs-keyword\">var</span> r = arr.filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> x % <span class=\"hljs-number\">2</span> !== <span class=\"hljs-number\">0</span>;<br>&#125;);<br>r; <span class=\"hljs-comment\">// [1, 5, 9, 15]</span><br></code></pre></td></tr></table></figure>\n<p>  <code>filter()</code>接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//去处Array的重复元素</span><br><span class=\"hljs-keyword\">var</span> r,arr = [<span class=\"hljs-string\">&#x27;apple&#x27;</span>, <span class=\"hljs-string\">&#x27;strawberry&#x27;</span>, <span class=\"hljs-string\">&#x27;banana&#x27;</span>, <br>\t<span class=\"hljs-string\">&#x27;pear&#x27;</span>, <span class=\"hljs-string\">&#x27;apple&#x27;</span>, <span class=\"hljs-string\">&#x27;orange&#x27;</span>, <span class=\"hljs-string\">&#x27;orange&#x27;</span>, <span class=\"hljs-string\">&#x27;strawberry&#x27;</span>];<br>r = arr.filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">element, index, self</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> self.indexOf(element) === index;<br>&#125;);<br></code></pre></td></tr></table></figure></li>\n<li><p><code>every()</code>与<code>some()</code><br><code>every()</code>方法像是数学中的量词 $\\forall$：当且仅当对数组中的所有元素调用判定函数都返回<code>true</code>，他才返回<code>true</code></p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-string\">&#x27;Apple&#x27;</span>, <span class=\"hljs-string\">&#x27;pear&#x27;</span>, <span class=\"hljs-string\">&#x27;orange&#x27;</span>];<br><span class=\"hljs-built_in\">console</span>.log(arr.every(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">s</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> s.length &gt; <span class=\"hljs-number\">0</span>;<br>&#125;)); <span class=\"hljs-comment\">// true, 因为每个元素都满足s.length&gt;0</span><br></code></pre></td></tr></table></figure>\n<p>  <code>some()</code>方法则像数学中的量词 $\\exists$：当数组中至少有一个元素调用判定函数返回<code>true</code>，他就返回<code>true</code>，否则返回<code>false</code></p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-string\">&#x27;Apple&#x27;</span>, <span class=\"hljs-string\">&#x27;pear&#x27;</span>, <span class=\"hljs-string\">&#x27;orange&#x27;</span>];<br>\t<span class=\"hljs-built_in\">console</span>.log(arr.every(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">s</span>) </span>&#123;<br>\t    <span class=\"hljs-keyword\">return</span> s.length &lt;<span class=\"hljs-number\">5</span>;<br>\t&#125;)); <span class=\"hljs-comment\">// true, 因为存在&#x27;pear&#x27;长度小于5</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>reduce()</code>和<code>reduceRight()</code><br>Array的<code>reduce()</code>把一个函数作用在这个Array的<code>[x1, x2, x3...]</code>上，这个函数必须接收两个参数，<code>reduce()</code>把结果继续和序列的下一个元素做累积计算，其效果就是：</p>\n  <figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs llvm\">[<span class=\"hljs-keyword\">x</span><span class=\"hljs-number\">1</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-keyword\">x</span><span class=\"hljs-number\">2</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-keyword\">x</span><span class=\"hljs-number\">3</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-keyword\">x</span><span class=\"hljs-number\">4</span>].reduce(f) <span class=\"hljs-operator\">=</span> f(f(f(<span class=\"hljs-keyword\">x</span><span class=\"hljs-number\">1</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-keyword\">x</span><span class=\"hljs-number\">2</span>)<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-keyword\">x</span><span class=\"hljs-number\">3</span>)<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-keyword\">x</span><span class=\"hljs-number\">4</span>)<br></code></pre></td></tr></table></figure>\n\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//用reduce求和</span><br><span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">9</span>];<br>arr.reduce(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x, y</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> x + y;<br>&#125;); <span class=\"hljs-comment\">// 25</span><br></code></pre></td></tr></table></figure>\n<p>  <code>reduceRight()</code>的原理相同，只是方向相反</p>\n</li>\n<li><p><code>find(function(currentValue, index, arr))</code>（ES6）、<code>findIndex(function(currentValue, index, arr))</code>（ES6）、<code>indexOf(item,start)</code>、<code>lastIndexOf(item,start)</code>和<code>includes(searchElement, fromIndex)</code><br><code>find()</code> 方法返回数组中满足提供的测试函数的第一个元素的值。<code>currentValue</code>必选参数，当前元素。<code>index</code>可选参数，当前元素索引。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> ages = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">18</span>, <span class=\"hljs-number\">20</span>];<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">checkAdult</span>(<span class=\"hljs-params\">age</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> age &gt;= <span class=\"hljs-number\">18</span>;<br>&#125;<br><span class=\"hljs-keyword\">var</span> value = ages.find(checkAdult);<br><span class=\"hljs-comment\">//18</span><br></code></pre></td></tr></table></figure>\n<p>  <code>findIndex()</code>方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回<code>-1</code></p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> ages = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">18</span>, <span class=\"hljs-number\">20</span>];<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">checkAdult</span>(<span class=\"hljs-params\">age</span>) </span>&#123;<br>\t    <span class=\"hljs-keyword\">return</span> age &gt;= <span class=\"hljs-number\">18</span>;<br>\t&#125;<br><span class=\"hljs-keyword\">var</span> value = ages.findIndex(checkAdult);<br>\t<span class=\"hljs-comment\">//2</span><br></code></pre></td></tr></table></figure>\n<p>  <code>indexOf()</code>方法返回在数组中可以找到给定元素的第一个索引，如果不存在，则返回<code>-1</code>，<code>item</code>是要找的元素，<code>start</code>是开始位置（可选，默认<code>0</code>）</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> fruits=[<span class=\"hljs-string\">&quot;Banana&quot;</span>,<span class=\"hljs-string\">&quot;Orange&quot;</span>,<span class=\"hljs-string\">&quot;Apple&quot;</span>,<span class=\"hljs-string\">&quot;Mango&quot;</span>,<span class=\"hljs-string\">&quot;Banana&quot;</span>,<span class=\"hljs-string\">&quot;Orange&quot;</span>,<span class=\"hljs-string\">&quot;Apple&quot;</span>];<br><span class=\"hljs-keyword\">var</span> a = fruits.indexOf(<span class=\"hljs-string\">&quot;Apple&quot;</span>,<span class=\"hljs-number\">4</span>);<span class=\"hljs-comment\">//6</span><br></code></pre></td></tr></table></figure>\n<p>  <code>lastIndexOf()</code> 方法可返回一个指定的元素在数组中最后出现的位置，从该字符串的后面向前查找。如果要检索的元素没有出现，则该方法返回 <code>-1</code></p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> fruits=[<span class=\"hljs-string\">&quot;Banana&quot;</span>,<span class=\"hljs-string\">&quot;Orange&quot;</span>,<span class=\"hljs-string\">&quot;Apple&quot;</span>,<span class=\"hljs-string\">&quot;Mango&quot;</span>,<span class=\"hljs-string\">&quot;Banana&quot;</span>,<span class=\"hljs-string\">&quot;Orange&quot;</span>,<span class=\"hljs-string\">&quot;Apple&quot;</span>];<br><span class=\"hljs-keyword\">var</span> a = fruits.lastIndexOf(<span class=\"hljs-string\">&quot;Apple&quot;</span>,<span class=\"hljs-number\">4</span>);<span class=\"hljs-comment\">//2</span><br></code></pre></td></tr></table></figure>\n<p>  <code>includes()</code> 方法用来判断一个数组是否包含一个指定的值，如果是返回 <code>true</code>，否则<code>false</code>。<code>searchElement</code> 必须参数，需要查找的元素值。<code>fromIndex</code> 可选参数，从该索引处开始查找</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].includes(<span class=\"hljs-number\">2</span>);     <span class=\"hljs-comment\">// true</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].includes(<span class=\"hljs-number\">4</span>);     <span class=\"hljs-comment\">// false</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].includes(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>);  <span class=\"hljs-comment\">// false</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>].includes(<span class=\"hljs-number\">3</span>, -<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// true</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">NaN</span>].includes(<span class=\"hljs-literal\">NaN</span>); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>Array.isArray(obj)</code><br>  isArray() 方法用于判断一个对象是否为数组。如果对象是数组返回 true，否则返回 false。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">Array</span>.isArray([]) ;<span class=\"hljs-comment\">// true</span><br>Arrray.isArray(&#123;&#125;);<span class=\"hljs-comment\">//false</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"类数组对象\"><a href=\"#类数组对象\" class=\"headerlink\" title=\"类数组对象\"></a>类数组对象</h2><p>JavaScript数组的有一些特性是其他对象没有的：</p>\n</li>\n<li><p>当有新的元素添加到数组时，自动更新length属性。</p>\n</li>\n<li><p>设置length为一个较小值将截断数组。</p>\n</li>\n<li><p>从Array.prototype 中级证一些有用的方法。</p>\n</li>\n<li><p>其类属性为‘Array’ </p>\n</li>\n</ul>\n"},{"title":"EventLoop理解","date":"2020-04-01T15:16:10.000Z","index_img":"/img/blogCovers/blog-post6.png","_content":"不多说，大家先看一段代码\n\n```javascript\nconsole.log('script start');\n\nsetTimeout(function() {\n  console.log('setTimeout');\n}, 0);\n\nPromise.resolve().then(function() {\n  console.log('promise1');\n}).then(function() {\n  console.log('promise2');\n});\n\nconsole.log('script end');\n```\n请问这段代码的打印顺序是什么\n\n正确的答案是：`script start`, `script end`, `promise1`, `promise2`, `setTimeout`。\n\n## 为什么会这样\n这就要引出事件循环了。可以看到，上面的代码中有几种任务种类，有`setTimeout`、`Promise`和可立即执行的`script代码`，事件循环可以理解为是一种规范，规定我们单线程的JavaScript以何种顺序去执行`js脚本`。\n\n在JavaScript中，任务被分为两种，一种宏任务（`MacroTask`）也叫`Task`，一种叫微任务（`MicroTask`）。这两种任务有各自的执行队列。\n先来几个概念：\n\n - Tasks：任务，有的地方称为MacroTask(宏任务)，以下几类任务被执行时会进入此队列：`script`代码、计时器（`setTimeout`、`setInterval`、`setImmediate`）、`I/O`、`UI Rendering`。\n - MicroTask：微任务，以下几类任务被执行时会进入此队列：`Process.nextTick`（`Node`）、`Promise`、`Object.observe`、`MutationObserver`\n\n分清楚以后，再说一下这两条队列的执行逻辑。一段代码开始执行总会先执行一个`Task`队列中的第一任务，在上例中，第一个`Task`是整个`script`代码，也就是说，代码开始执行时，将全部`script`代码放入`Task`队列中，JavaScript开始执行其中的代码。遇到同步任务时，如`console.log()`，JavaScript会将他放入执行栈，立即执行。遇到异步任务时，先不管他，让他自己执行，执行完毕后，该任务会向任务队列发出信号，根据他的任务类型，放入不同的队列，以便执行后续的回调函数。如`setTimeout`在`0s`后向Task队列发出信号，将`setTimeout`的回调函数放入`Task`队列中，位置在`script`代码之后。遇到`promise`时，同样先让他自己执行，当他执行完毕，向`MicroTask`队列发出信号，将他的回调函数放入`Microtask`队列。\n\n当第一个`Task`，即`script`全部代码执行完毕后，会先执行所有`MicroTask`队列中的任务，执行的逻辑与之前相同，遇到同步代码立即执行，异步代码待自行完成后，将各自回调函数加入相应队列。\n\n当所有微任务完成后，JavaScript才会执行`Task`队列中的下个任务，即`setTimeout`的回调函数`console.log('setTimeout');`，以此往复循环（Event Loop）。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200401161628154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n下面是示例代码运行的动图\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200401164245792.gif#pic_center)\n## 再来几个题，来巩固一下\n**题目：写出运行结果**\n\n```javascript\nsetTimeout(function(){\n    console.log(1);\n}, 0)\nnew Promise(function(resolve){\n    console.log(2);\n    resolve();\n    console.log(3);\n}).then(function(){\n    console.log(4);\n})\nconsole.log(5);\n\n```\n解析\n\n```\n// 解析：\n// 1. new Promise(fn)后，函数fn会立即执行；\n// 2. fn在执行过程中，由于调用了resolve，使得Promise立即转换为resolve状态，\n//    这也促使p.then(fn)中的函数fn被立即放入microTask队列中，因此fn将会在\n//    本轮事件循环的结束时执行，而不是下一轮事件循环的开始时执行；\n// 3. setTimeout属于macroTask，是在下一轮事件循环中执行；\n//答案：\n// 2 3 5 4 1\n```\n**题目：写出运行结果**\n\n```javascript\nPromise.resolve(1)\n  .then((res) => {\n    console.log(res);\n    return 2;\n  })\n  .catch((res) => {\n    console.log(res);\n    return 3;\n  })\n  .then((res) => {\n    console.log(res);\n  });\n\n```\n解析\n\n```\n// 解析：每次调用p.then或p.catch都会返回一个新的promise，\n//       从而实现了链式调用；第一个.then中未抛出异常，\n//       所以不会被.catch语句捕获，会正常进入第二个.then执行；\n// 答案：1 2\n```\n**题目：写出运行结果**\n```javascript\nnew Promise(resolve => { // p1\n    resolve(1);\n    \n    // p2\n    Promise.resolve().then(() => {\n      console.log(2); // t1\n    });\n\n    console.log(4)\n}).then(t => {\n  console.log(t); // t2\n});\n\nconsole.log(3);\n```\n解析\n\n```\n// 解析：\n// 1. new Promise(fn), fn 立即执行，所以先输出 4；\n// 2. p1和p2的Promise在执行then之前都已处于resolve状态，\n//    故按照then执行的先后顺序，将t1、t2放入microTask中等待执行；\n// 3. 完成执行console.log(3)后，macroTask执行结束，然后microTask\n//    中的任务t1、t2依次执行，所以输出3、2、1；\n// 答案：\n// 4 3 2 1\n```\n## 参考文献\n[https://juejin.im/post/5cf7857ff265da1bac4005b2](https://juejin.im/post/5cf7857ff265da1bac4005b2)\n[https://hongfanqie.github.io/tasks-microtasks-queues-and-schedules/](https://hongfanqie.github.io/tasks-microtasks-queues-and-schedules/)\n[https://zhuanlan.zhihu.com/p/55511602](https://zhuanlan.zhihu.com/p/55511602)","source":"_posts/eventLoop理解.md","raw":"---\ntitle: EventLoop理解\ndate: 2020-04-01 23:16:10\nindex_img: /img/blogCovers/blog-post6.png\ntags: [JavaScript, 异步编程]\ncategories: [学习笔记]\n---\n不多说，大家先看一段代码\n\n```javascript\nconsole.log('script start');\n\nsetTimeout(function() {\n  console.log('setTimeout');\n}, 0);\n\nPromise.resolve().then(function() {\n  console.log('promise1');\n}).then(function() {\n  console.log('promise2');\n});\n\nconsole.log('script end');\n```\n请问这段代码的打印顺序是什么\n\n正确的答案是：`script start`, `script end`, `promise1`, `promise2`, `setTimeout`。\n\n## 为什么会这样\n这就要引出事件循环了。可以看到，上面的代码中有几种任务种类，有`setTimeout`、`Promise`和可立即执行的`script代码`，事件循环可以理解为是一种规范，规定我们单线程的JavaScript以何种顺序去执行`js脚本`。\n\n在JavaScript中，任务被分为两种，一种宏任务（`MacroTask`）也叫`Task`，一种叫微任务（`MicroTask`）。这两种任务有各自的执行队列。\n先来几个概念：\n\n - Tasks：任务，有的地方称为MacroTask(宏任务)，以下几类任务被执行时会进入此队列：`script`代码、计时器（`setTimeout`、`setInterval`、`setImmediate`）、`I/O`、`UI Rendering`。\n - MicroTask：微任务，以下几类任务被执行时会进入此队列：`Process.nextTick`（`Node`）、`Promise`、`Object.observe`、`MutationObserver`\n\n分清楚以后，再说一下这两条队列的执行逻辑。一段代码开始执行总会先执行一个`Task`队列中的第一任务，在上例中，第一个`Task`是整个`script`代码，也就是说，代码开始执行时，将全部`script`代码放入`Task`队列中，JavaScript开始执行其中的代码。遇到同步任务时，如`console.log()`，JavaScript会将他放入执行栈，立即执行。遇到异步任务时，先不管他，让他自己执行，执行完毕后，该任务会向任务队列发出信号，根据他的任务类型，放入不同的队列，以便执行后续的回调函数。如`setTimeout`在`0s`后向Task队列发出信号，将`setTimeout`的回调函数放入`Task`队列中，位置在`script`代码之后。遇到`promise`时，同样先让他自己执行，当他执行完毕，向`MicroTask`队列发出信号，将他的回调函数放入`Microtask`队列。\n\n当第一个`Task`，即`script`全部代码执行完毕后，会先执行所有`MicroTask`队列中的任务，执行的逻辑与之前相同，遇到同步代码立即执行，异步代码待自行完成后，将各自回调函数加入相应队列。\n\n当所有微任务完成后，JavaScript才会执行`Task`队列中的下个任务，即`setTimeout`的回调函数`console.log('setTimeout');`，以此往复循环（Event Loop）。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200401161628154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n下面是示例代码运行的动图\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200401164245792.gif#pic_center)\n## 再来几个题，来巩固一下\n**题目：写出运行结果**\n\n```javascript\nsetTimeout(function(){\n    console.log(1);\n}, 0)\nnew Promise(function(resolve){\n    console.log(2);\n    resolve();\n    console.log(3);\n}).then(function(){\n    console.log(4);\n})\nconsole.log(5);\n\n```\n解析\n\n```\n// 解析：\n// 1. new Promise(fn)后，函数fn会立即执行；\n// 2. fn在执行过程中，由于调用了resolve，使得Promise立即转换为resolve状态，\n//    这也促使p.then(fn)中的函数fn被立即放入microTask队列中，因此fn将会在\n//    本轮事件循环的结束时执行，而不是下一轮事件循环的开始时执行；\n// 3. setTimeout属于macroTask，是在下一轮事件循环中执行；\n//答案：\n// 2 3 5 4 1\n```\n**题目：写出运行结果**\n\n```javascript\nPromise.resolve(1)\n  .then((res) => {\n    console.log(res);\n    return 2;\n  })\n  .catch((res) => {\n    console.log(res);\n    return 3;\n  })\n  .then((res) => {\n    console.log(res);\n  });\n\n```\n解析\n\n```\n// 解析：每次调用p.then或p.catch都会返回一个新的promise，\n//       从而实现了链式调用；第一个.then中未抛出异常，\n//       所以不会被.catch语句捕获，会正常进入第二个.then执行；\n// 答案：1 2\n```\n**题目：写出运行结果**\n```javascript\nnew Promise(resolve => { // p1\n    resolve(1);\n    \n    // p2\n    Promise.resolve().then(() => {\n      console.log(2); // t1\n    });\n\n    console.log(4)\n}).then(t => {\n  console.log(t); // t2\n});\n\nconsole.log(3);\n```\n解析\n\n```\n// 解析：\n// 1. new Promise(fn), fn 立即执行，所以先输出 4；\n// 2. p1和p2的Promise在执行then之前都已处于resolve状态，\n//    故按照then执行的先后顺序，将t1、t2放入microTask中等待执行；\n// 3. 完成执行console.log(3)后，macroTask执行结束，然后microTask\n//    中的任务t1、t2依次执行，所以输出3、2、1；\n// 答案：\n// 4 3 2 1\n```\n## 参考文献\n[https://juejin.im/post/5cf7857ff265da1bac4005b2](https://juejin.im/post/5cf7857ff265da1bac4005b2)\n[https://hongfanqie.github.io/tasks-microtasks-queues-and-schedules/](https://hongfanqie.github.io/tasks-microtasks-queues-and-schedules/)\n[https://zhuanlan.zhihu.com/p/55511602](https://zhuanlan.zhihu.com/p/55511602)","slug":"eventLoop理解","published":1,"updated":"2022-01-10T08:41:39.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckyo4lu6k0001nz692p6jg09c","content":"<p>不多说，大家先看一段代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;script start&#x27;</span>);<br><br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;setTimeout&#x27;</span>);<br>&#125;, <span class=\"hljs-number\">0</span>);<br><br><span class=\"hljs-built_in\">Promise</span>.resolve().then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;promise1&#x27;</span>);<br>&#125;).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;promise2&#x27;</span>);<br>&#125;);<br><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;script end&#x27;</span>);<br></code></pre></td></tr></table></figure>\n<p>请问这段代码的打印顺序是什么</p>\n<p>正确的答案是：<code>script start</code>, <code>script end</code>, <code>promise1</code>, <code>promise2</code>, <code>setTimeout</code>。</p>\n<h2 id=\"为什么会这样\"><a href=\"#为什么会这样\" class=\"headerlink\" title=\"为什么会这样\"></a>为什么会这样</h2><p>这就要引出事件循环了。可以看到，上面的代码中有几种任务种类，有<code>setTimeout</code>、<code>Promise</code>和可立即执行的<code>script代码</code>，事件循环可以理解为是一种规范，规定我们单线程的JavaScript以何种顺序去执行<code>js脚本</code>。</p>\n<p>在JavaScript中，任务被分为两种，一种宏任务（<code>MacroTask</code>）也叫<code>Task</code>，一种叫微任务（<code>MicroTask</code>）。这两种任务有各自的执行队列。<br>先来几个概念：</p>\n<ul>\n<li>Tasks：任务，有的地方称为MacroTask(宏任务)，以下几类任务被执行时会进入此队列：<code>script</code>代码、计时器（<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>）、<code>I/O</code>、<code>UI Rendering</code>。</li>\n<li>MicroTask：微任务，以下几类任务被执行时会进入此队列：<code>Process.nextTick</code>（<code>Node</code>）、<code>Promise</code>、<code>Object.observe</code>、<code>MutationObserver</code></li>\n</ul>\n<p>分清楚以后，再说一下这两条队列的执行逻辑。一段代码开始执行总会先执行一个<code>Task</code>队列中的第一任务，在上例中，第一个<code>Task</code>是整个<code>script</code>代码，也就是说，代码开始执行时，将全部<code>script</code>代码放入<code>Task</code>队列中，JavaScript开始执行其中的代码。遇到同步任务时，如<code>console.log()</code>，JavaScript会将他放入执行栈，立即执行。遇到异步任务时，先不管他，让他自己执行，执行完毕后，该任务会向任务队列发出信号，根据他的任务类型，放入不同的队列，以便执行后续的回调函数。如<code>setTimeout</code>在<code>0s</code>后向Task队列发出信号，将<code>setTimeout</code>的回调函数放入<code>Task</code>队列中，位置在<code>script</code>代码之后。遇到<code>promise</code>时，同样先让他自己执行，当他执行完毕，向<code>MicroTask</code>队列发出信号，将他的回调函数放入<code>Microtask</code>队列。</p>\n<p>当第一个<code>Task</code>，即<code>script</code>全部代码执行完毕后，会先执行所有<code>MicroTask</code>队列中的任务，执行的逻辑与之前相同，遇到同步代码立即执行，异步代码待自行完成后，将各自回调函数加入相应队列。</p>\n<p>当所有微任务完成后，JavaScript才会执行<code>Task</code>队列中的下个任务，即<code>setTimeout</code>的回调函数<code>console.log(&#39;setTimeout&#39;);</code>，以此往复循环（Event Loop）。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200401161628154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>下面是示例代码运行的动图<br><img src=\"https://img-blog.csdnimg.cn/20200401164245792.gif#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"再来几个题，来巩固一下\"><a href=\"#再来几个题，来巩固一下\" class=\"headerlink\" title=\"再来几个题，来巩固一下\"></a>再来几个题，来巩固一下</h2><p><strong>题目：写出运行结果</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>);<br>&#125;, <span class=\"hljs-number\">0</span>)<br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve</span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>);<br>    resolve();<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>);<br>&#125;).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">4</span>);<br>&#125;)<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">5</span>);<br><br></code></pre></td></tr></table></figure>\n<p>解析</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span> 解析：<br><span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">1</span>. new Promise(fn)后，函数fn会立即执行；<br><span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">2</span>. fn在执行过程中，由于调用了resolve，使得Promise立即转换为resolve状态，<br><span class=\"hljs-regexp\">//</span>    这也促使p.then(fn)中的函数fn被立即放入microTask队列中，因此fn将会在<br><span class=\"hljs-regexp\">//</span>    本轮事件循环的结束时执行，而不是下一轮事件循环的开始时执行；<br><span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">3</span>. setTimeout属于macroTask，是在下一轮事件循环中执行；<br><span class=\"hljs-regexp\">//</span>答案：<br><span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">5</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n<p><strong>题目：写出运行结果</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-number\">1</span>)<br>  .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(res);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span>;<br>  &#125;)<br>  .catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(res);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">3</span>;<br>  &#125;)<br>  .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(res);<br>  &#125;);<br><br></code></pre></td></tr></table></figure>\n<p>解析</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span> 解析：每次调用p.then或p.catch都会返回一个新的promise，<br><span class=\"hljs-regexp\">//</span>       从而实现了链式调用；第一个.then中未抛出异常，<br><span class=\"hljs-regexp\">//</span>       所以不会被.catch语句捕获，会正常进入第二个.then执行；<br><span class=\"hljs-regexp\">//</span> 答案：<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span><br></code></pre></td></tr></table></figure>\n<p><strong>题目：写出运行结果</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> &#123; <span class=\"hljs-comment\">// p1</span><br>    resolve(<span class=\"hljs-number\">1</span>);<br>    <br>    <span class=\"hljs-comment\">// p2</span><br>    <span class=\"hljs-built_in\">Promise</span>.resolve().then(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// t1</span><br>    &#125;);<br><br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">4</span>)<br>&#125;).then(<span class=\"hljs-function\"><span class=\"hljs-params\">t</span> =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(t); <span class=\"hljs-comment\">// t2</span><br>&#125;);<br><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>);<br></code></pre></td></tr></table></figure>\n<p>解析</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span> 解析：<br><span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">1</span>. new Promise(fn), fn 立即执行，所以先输出 <span class=\"hljs-number\">4</span>；<br><span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">2</span>. p1和p2的Promise在执行then之前都已处于resolve状态，<br><span class=\"hljs-regexp\">//</span>    故按照then执行的先后顺序，将t1、t2放入microTask中等待执行；<br><span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">3</span>. 完成执行console.log(<span class=\"hljs-number\">3</span>)后，macroTask执行结束，然后microTask<br><span class=\"hljs-regexp\">//</span>    中的任务t1、t2依次执行，所以输出<span class=\"hljs-number\">3</span>、<span class=\"hljs-number\">2</span>、<span class=\"hljs-number\">1</span>；<br><span class=\"hljs-regexp\">//</span> 答案：<br><span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://juejin.im/post/5cf7857ff265da1bac4005b2\">https://juejin.im/post/5cf7857ff265da1bac4005b2</a><br><a href=\"https://hongfanqie.github.io/tasks-microtasks-queues-and-schedules/\">https://hongfanqie.github.io/tasks-microtasks-queues-and-schedules/</a><br><a href=\"https://zhuanlan.zhihu.com/p/55511602\">https://zhuanlan.zhihu.com/p/55511602</a></p>\n","site":{"data":{}},"wordcount":2738,"excerpt":"","more":"<p>不多说，大家先看一段代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;script start&#x27;</span>);<br><br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;setTimeout&#x27;</span>);<br>&#125;, <span class=\"hljs-number\">0</span>);<br><br><span class=\"hljs-built_in\">Promise</span>.resolve().then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;promise1&#x27;</span>);<br>&#125;).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;promise2&#x27;</span>);<br>&#125;);<br><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;script end&#x27;</span>);<br></code></pre></td></tr></table></figure>\n<p>请问这段代码的打印顺序是什么</p>\n<p>正确的答案是：<code>script start</code>, <code>script end</code>, <code>promise1</code>, <code>promise2</code>, <code>setTimeout</code>。</p>\n<h2 id=\"为什么会这样\"><a href=\"#为什么会这样\" class=\"headerlink\" title=\"为什么会这样\"></a>为什么会这样</h2><p>这就要引出事件循环了。可以看到，上面的代码中有几种任务种类，有<code>setTimeout</code>、<code>Promise</code>和可立即执行的<code>script代码</code>，事件循环可以理解为是一种规范，规定我们单线程的JavaScript以何种顺序去执行<code>js脚本</code>。</p>\n<p>在JavaScript中，任务被分为两种，一种宏任务（<code>MacroTask</code>）也叫<code>Task</code>，一种叫微任务（<code>MicroTask</code>）。这两种任务有各自的执行队列。<br>先来几个概念：</p>\n<ul>\n<li>Tasks：任务，有的地方称为MacroTask(宏任务)，以下几类任务被执行时会进入此队列：<code>script</code>代码、计时器（<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>）、<code>I/O</code>、<code>UI Rendering</code>。</li>\n<li>MicroTask：微任务，以下几类任务被执行时会进入此队列：<code>Process.nextTick</code>（<code>Node</code>）、<code>Promise</code>、<code>Object.observe</code>、<code>MutationObserver</code></li>\n</ul>\n<p>分清楚以后，再说一下这两条队列的执行逻辑。一段代码开始执行总会先执行一个<code>Task</code>队列中的第一任务，在上例中，第一个<code>Task</code>是整个<code>script</code>代码，也就是说，代码开始执行时，将全部<code>script</code>代码放入<code>Task</code>队列中，JavaScript开始执行其中的代码。遇到同步任务时，如<code>console.log()</code>，JavaScript会将他放入执行栈，立即执行。遇到异步任务时，先不管他，让他自己执行，执行完毕后，该任务会向任务队列发出信号，根据他的任务类型，放入不同的队列，以便执行后续的回调函数。如<code>setTimeout</code>在<code>0s</code>后向Task队列发出信号，将<code>setTimeout</code>的回调函数放入<code>Task</code>队列中，位置在<code>script</code>代码之后。遇到<code>promise</code>时，同样先让他自己执行，当他执行完毕，向<code>MicroTask</code>队列发出信号，将他的回调函数放入<code>Microtask</code>队列。</p>\n<p>当第一个<code>Task</code>，即<code>script</code>全部代码执行完毕后，会先执行所有<code>MicroTask</code>队列中的任务，执行的逻辑与之前相同，遇到同步代码立即执行，异步代码待自行完成后，将各自回调函数加入相应队列。</p>\n<p>当所有微任务完成后，JavaScript才会执行<code>Task</code>队列中的下个任务，即<code>setTimeout</code>的回调函数<code>console.log(&#39;setTimeout&#39;);</code>，以此往复循环（Event Loop）。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200401161628154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>下面是示例代码运行的动图<br><img src=\"https://img-blog.csdnimg.cn/20200401164245792.gif#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"再来几个题，来巩固一下\"><a href=\"#再来几个题，来巩固一下\" class=\"headerlink\" title=\"再来几个题，来巩固一下\"></a>再来几个题，来巩固一下</h2><p><strong>题目：写出运行结果</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>);<br>&#125;, <span class=\"hljs-number\">0</span>)<br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve</span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>);<br>    resolve();<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>);<br>&#125;).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">4</span>);<br>&#125;)<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">5</span>);<br><br></code></pre></td></tr></table></figure>\n<p>解析</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span> 解析：<br><span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">1</span>. new Promise(fn)后，函数fn会立即执行；<br><span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">2</span>. fn在执行过程中，由于调用了resolve，使得Promise立即转换为resolve状态，<br><span class=\"hljs-regexp\">//</span>    这也促使p.then(fn)中的函数fn被立即放入microTask队列中，因此fn将会在<br><span class=\"hljs-regexp\">//</span>    本轮事件循环的结束时执行，而不是下一轮事件循环的开始时执行；<br><span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">3</span>. setTimeout属于macroTask，是在下一轮事件循环中执行；<br><span class=\"hljs-regexp\">//</span>答案：<br><span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">5</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n<p><strong>题目：写出运行结果</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-number\">1</span>)<br>  .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(res);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span>;<br>  &#125;)<br>  .catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(res);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">3</span>;<br>  &#125;)<br>  .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(res);<br>  &#125;);<br><br></code></pre></td></tr></table></figure>\n<p>解析</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span> 解析：每次调用p.then或p.catch都会返回一个新的promise，<br><span class=\"hljs-regexp\">//</span>       从而实现了链式调用；第一个.then中未抛出异常，<br><span class=\"hljs-regexp\">//</span>       所以不会被.catch语句捕获，会正常进入第二个.then执行；<br><span class=\"hljs-regexp\">//</span> 答案：<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span><br></code></pre></td></tr></table></figure>\n<p><strong>题目：写出运行结果</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> &#123; <span class=\"hljs-comment\">// p1</span><br>    resolve(<span class=\"hljs-number\">1</span>);<br>    <br>    <span class=\"hljs-comment\">// p2</span><br>    <span class=\"hljs-built_in\">Promise</span>.resolve().then(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// t1</span><br>    &#125;);<br><br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">4</span>)<br>&#125;).then(<span class=\"hljs-function\"><span class=\"hljs-params\">t</span> =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(t); <span class=\"hljs-comment\">// t2</span><br>&#125;);<br><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>);<br></code></pre></td></tr></table></figure>\n<p>解析</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span> 解析：<br><span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">1</span>. new Promise(fn), fn 立即执行，所以先输出 <span class=\"hljs-number\">4</span>；<br><span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">2</span>. p1和p2的Promise在执行then之前都已处于resolve状态，<br><span class=\"hljs-regexp\">//</span>    故按照then执行的先后顺序，将t1、t2放入microTask中等待执行；<br><span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">3</span>. 完成执行console.log(<span class=\"hljs-number\">3</span>)后，macroTask执行结束，然后microTask<br><span class=\"hljs-regexp\">//</span>    中的任务t1、t2依次执行，所以输出<span class=\"hljs-number\">3</span>、<span class=\"hljs-number\">2</span>、<span class=\"hljs-number\">1</span>；<br><span class=\"hljs-regexp\">//</span> 答案：<br><span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://juejin.im/post/5cf7857ff265da1bac4005b2\">https://juejin.im/post/5cf7857ff265da1bac4005b2</a><br><a href=\"https://hongfanqie.github.io/tasks-microtasks-queues-and-schedules/\">https://hongfanqie.github.io/tasks-microtasks-queues-and-schedules/</a><br><a href=\"https://zhuanlan.zhihu.com/p/55511602\">https://zhuanlan.zhihu.com/p/55511602</a></p>\n"},{"title":"Babel原理浅析(二)： 手写一个极简插件","date":"2021-04-09T15:16:10.000Z","index_img":"https://d33wubrfki0l68.cloudfront.net/7a197cfe44548cc1a3f581152af70a3051e11671/78df8/img/babel.svg","_content":"\n我们在[上文](https://luoluoqinghuan.cn/2021/04/01/howBabelWork_parser/)中已经了解到babel的第一步，将代码解析成AST，接下来的两步就比较好理解了，转换与生成。我再看最开始的代码。\n\n```javascript\nconst { parse } = require(\"./packages/babel-parser\");\nconst traverse = require(\"./packages/babel-traverse\").default;\nconst generate = require(\"./packages/babel-generator\").default;\n\nconst code = \"const square = n => n * n\";\n\n// parse the code -> ast\nconst ast = parse(code);\n\nconsole.log(`originAST: ${JSON.stringify(ast)}`);\n// transform the ast\ntraverse(ast, {\n  enter(path) {\n    if (path.node.type !== \"ArrowFunctionExpression\") return;\n\n    path.arrowFunctionToExpression({\n      allowInsertArrow: false,\n      noNewArrows: true,\n      specCompliant: false,\n    });\n  },\n});\n\nconsole.log(`newAST: ${JSON.stringify(ast)}`)\n// generate code <- ast\nconst output = generate(ast, code);\nconsole.log(output.code);\n// const square = function (n) {\n//     return n * n;\n//   };\n```\n\n转换这里的代码其实是`babel-plugin-transform-arrow-functions`的源码，作用是将箭头函数转换成普通函数，我们分别将转换前后的AST打印出来，比较看一下这个插件对AST做了什么。\n![astCompared](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/408772caac94408eb086119c22020f6c~tplv-k3u1fbpfcp-watermark.image?)\n\n转后的AST结构发生了变化，这就是转换阶段babel的作用，将源代码的AST按照[标准规范](https://github.com/estree/estree)转换成目标代码的AST。看到这儿，我们其实已经可以手写一个简单的插件来玩玩了。\n\n我们新建一个文件`replaceN2M.js`\n```javascript\nmodule.exports = function () {\n  return {\n    // visitor 遍历回调\n    visitor: {\n      // type === 'Identifier' step into\n      Identifier(path) {\n        // n -> m\n        if (path.isIdentifier({ name: \"n\" })) {\n          path.node.name = \"m\";\n        }\n      },\n      // type === 'BinaryExpression' step into\n      BinaryExpression(path) {\n        // * -> -\n        if (path.node.operator === \"*\") {\n          path.node.operator = \"-\";\n        }\n      },\n    },\n  };\n};\n```\n一个最简单的插件就完成了，它做了两件事，将所有变量`n`转换成`m`，将所有二元表达式的运算符`*`转换成`-`。\nbabel会深度优先遍历AST，期间会调用插件中的`visitor.method`，visitor里存放对AST的操作回调，`Identifier(){}`是指当前AST节点的`type === 'Identifier'`时，进入此函数，此时`path`为当前位置，`path.node`为此节点，那么我们就可以对node进行操作。\n\n我们新建一个文件`test2.js`，看下我们的插件是否起作用\n```javascript\nconst square = n => n * n\n```\n\n自定义的方法有两种方法进行调用，一种是直接使用babel编译命令，`npx babel --plugins ./replaceN2M.js test2.js`。第二种是，将我们的插件放进babel的配置文件里，在`babel.config.js`的plugin中添加`\"./replaceN2M\"`，现在整个plugin长这样。\n```javascript\nplugins: [\n      [\"@babel/proposal-object-rest-spread\", { useBuiltIns: true }],\n\n      convertESM ? \"@babel/proposal-export-namespace-from\" : null,\n      convertESM ? pluginImportMetaUrl : null,\n\n      pluginPackageJsonMacro,\n\n      process.env.STRIP_BABEL_8_FLAG && [\n        pluginToggleBabel8Breaking,\n        { breaking: bool(process.env.BABEL_8_BREAKING) },\n      ],\n      needsPolyfillsForOldNode && pluginPolyfillsOldNode,\n      \"./replaceN2M\",\n    ].filter(Boolean)\n```\n然后直接运行 `npx babel test2.js`即可，我们可以看到控制台输出了我们想要的结果，或者，让babel直接编译成文件`npx babel test2.js --out-dir ./ `，再打开`test2.js`看到文件内容已经是编译后的内容。\n\n写一个插件最大的难点在于对babelAPI的不熟悉以及对ECMA规范的不了解，如果要写一个复杂的插件，需要多看看类似插件的实现，强烈推荐[babel插件开发手册](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md#paths)，基本涵盖了开发插件所需要的所有知识。\n\n到这里，我的好奇心基本都已经打消了，转换后的AST怎么重新生成代码，这里就不深入研究了，感兴趣可以直接去看源码。\n### References\n\n[Babel插件开发入门指南](https://www.cnblogs.com/chyingp/p/how-to-write-a-babel-plugin.html)\n\n[Step-by-step guide for writing a custom babel transformation](https://lihautan.com/step-by-step-guide-for-writing-a-babel-transformation/)\n\n[Babel 插件开发手册](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md)","source":"_posts/howTransformBabelAst.md","raw":"---\ntitle: Babel原理浅析(二)： 手写一个极简插件\ndate: 2021-04-09 23:16:10\nindex_img: https://d33wubrfki0l68.cloudfront.net/7a197cfe44548cc1a3f581152af70a3051e11671/78df8/img/babel.svg\ntags: [JavaScript, Babel, 前端工程化]\ncategories: [源码解读]\n---\n\n我们在[上文](https://luoluoqinghuan.cn/2021/04/01/howBabelWork_parser/)中已经了解到babel的第一步，将代码解析成AST，接下来的两步就比较好理解了，转换与生成。我再看最开始的代码。\n\n```javascript\nconst { parse } = require(\"./packages/babel-parser\");\nconst traverse = require(\"./packages/babel-traverse\").default;\nconst generate = require(\"./packages/babel-generator\").default;\n\nconst code = \"const square = n => n * n\";\n\n// parse the code -> ast\nconst ast = parse(code);\n\nconsole.log(`originAST: ${JSON.stringify(ast)}`);\n// transform the ast\ntraverse(ast, {\n  enter(path) {\n    if (path.node.type !== \"ArrowFunctionExpression\") return;\n\n    path.arrowFunctionToExpression({\n      allowInsertArrow: false,\n      noNewArrows: true,\n      specCompliant: false,\n    });\n  },\n});\n\nconsole.log(`newAST: ${JSON.stringify(ast)}`)\n// generate code <- ast\nconst output = generate(ast, code);\nconsole.log(output.code);\n// const square = function (n) {\n//     return n * n;\n//   };\n```\n\n转换这里的代码其实是`babel-plugin-transform-arrow-functions`的源码，作用是将箭头函数转换成普通函数，我们分别将转换前后的AST打印出来，比较看一下这个插件对AST做了什么。\n![astCompared](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/408772caac94408eb086119c22020f6c~tplv-k3u1fbpfcp-watermark.image?)\n\n转后的AST结构发生了变化，这就是转换阶段babel的作用，将源代码的AST按照[标准规范](https://github.com/estree/estree)转换成目标代码的AST。看到这儿，我们其实已经可以手写一个简单的插件来玩玩了。\n\n我们新建一个文件`replaceN2M.js`\n```javascript\nmodule.exports = function () {\n  return {\n    // visitor 遍历回调\n    visitor: {\n      // type === 'Identifier' step into\n      Identifier(path) {\n        // n -> m\n        if (path.isIdentifier({ name: \"n\" })) {\n          path.node.name = \"m\";\n        }\n      },\n      // type === 'BinaryExpression' step into\n      BinaryExpression(path) {\n        // * -> -\n        if (path.node.operator === \"*\") {\n          path.node.operator = \"-\";\n        }\n      },\n    },\n  };\n};\n```\n一个最简单的插件就完成了，它做了两件事，将所有变量`n`转换成`m`，将所有二元表达式的运算符`*`转换成`-`。\nbabel会深度优先遍历AST，期间会调用插件中的`visitor.method`，visitor里存放对AST的操作回调，`Identifier(){}`是指当前AST节点的`type === 'Identifier'`时，进入此函数，此时`path`为当前位置，`path.node`为此节点，那么我们就可以对node进行操作。\n\n我们新建一个文件`test2.js`，看下我们的插件是否起作用\n```javascript\nconst square = n => n * n\n```\n\n自定义的方法有两种方法进行调用，一种是直接使用babel编译命令，`npx babel --plugins ./replaceN2M.js test2.js`。第二种是，将我们的插件放进babel的配置文件里，在`babel.config.js`的plugin中添加`\"./replaceN2M\"`，现在整个plugin长这样。\n```javascript\nplugins: [\n      [\"@babel/proposal-object-rest-spread\", { useBuiltIns: true }],\n\n      convertESM ? \"@babel/proposal-export-namespace-from\" : null,\n      convertESM ? pluginImportMetaUrl : null,\n\n      pluginPackageJsonMacro,\n\n      process.env.STRIP_BABEL_8_FLAG && [\n        pluginToggleBabel8Breaking,\n        { breaking: bool(process.env.BABEL_8_BREAKING) },\n      ],\n      needsPolyfillsForOldNode && pluginPolyfillsOldNode,\n      \"./replaceN2M\",\n    ].filter(Boolean)\n```\n然后直接运行 `npx babel test2.js`即可，我们可以看到控制台输出了我们想要的结果，或者，让babel直接编译成文件`npx babel test2.js --out-dir ./ `，再打开`test2.js`看到文件内容已经是编译后的内容。\n\n写一个插件最大的难点在于对babelAPI的不熟悉以及对ECMA规范的不了解，如果要写一个复杂的插件，需要多看看类似插件的实现，强烈推荐[babel插件开发手册](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md#paths)，基本涵盖了开发插件所需要的所有知识。\n\n到这里，我的好奇心基本都已经打消了，转换后的AST怎么重新生成代码，这里就不深入研究了，感兴趣可以直接去看源码。\n### References\n\n[Babel插件开发入门指南](https://www.cnblogs.com/chyingp/p/how-to-write-a-babel-plugin.html)\n\n[Step-by-step guide for writing a custom babel transformation](https://lihautan.com/step-by-step-guide-for-writing-a-babel-transformation/)\n\n[Babel 插件开发手册](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md)","slug":"howTransformBabelAst","published":1,"updated":"2025-06-10T04:39:28.845Z","_id":"ckyo4lu6l0003nz69fspg7s6k","comments":1,"layout":"post","photos":[],"link":"","content":"<p>我们在<a href=\"https://luoluoqinghuan.cn/2021/04/01/howBabelWork_parser/\">上文</a>中已经了解到babel的第一步，将代码解析成AST，接下来的两步就比较好理解了，转换与生成。我再看最开始的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> &#123; parse &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;./packages/babel-parser&quot;</span>);<br><span class=\"hljs-keyword\">const</span> traverse = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;./packages/babel-traverse&quot;</span>).default;<br><span class=\"hljs-keyword\">const</span> generate = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;./packages/babel-generator&quot;</span>).default;<br><br><span class=\"hljs-keyword\">const</span> code = <span class=\"hljs-string\">&quot;const square = n =&gt; n * n&quot;</span>;<br><br><span class=\"hljs-comment\">// parse the code -&gt; ast</span><br><span class=\"hljs-keyword\">const</span> ast = parse(code);<br><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`originAST: <span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">JSON</span>.stringify(ast)&#125;</span>`</span>);<br><span class=\"hljs-comment\">// transform the ast</span><br>traverse(ast, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">enter</span>(<span class=\"hljs-params\">path</span>)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (path.node.type !== <span class=\"hljs-string\">&quot;ArrowFunctionExpression&quot;</span>) <span class=\"hljs-keyword\">return</span>;<br><br>    path.arrowFunctionToExpression(&#123;<br>      <span class=\"hljs-attr\">allowInsertArrow</span>: <span class=\"hljs-literal\">false</span>,<br>      <span class=\"hljs-attr\">noNewArrows</span>: <span class=\"hljs-literal\">true</span>,<br>      <span class=\"hljs-attr\">specCompliant</span>: <span class=\"hljs-literal\">false</span>,<br>    &#125;);<br>  &#125;,<br>&#125;);<br><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`newAST: <span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">JSON</span>.stringify(ast)&#125;</span>`</span>)<br><span class=\"hljs-comment\">// generate code &lt;- ast</span><br><span class=\"hljs-keyword\">const</span> output = generate(ast, code);<br><span class=\"hljs-built_in\">console</span>.log(output.code);<br><span class=\"hljs-comment\">// const square = function (n) &#123;</span><br><span class=\"hljs-comment\">//     return n * n;</span><br><span class=\"hljs-comment\">//   &#125;;</span><br></code></pre></td></tr></table></figure>\n\n<p>转换这里的代码其实是<code>babel-plugin-transform-arrow-functions</code>的源码，作用是将箭头函数转换成普通函数，我们分别将转换前后的AST打印出来，比较看一下这个插件对AST做了什么。<br><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/408772caac94408eb086119c22020f6c~tplv-k3u1fbpfcp-watermark.image\" alt=\"astCompared\"></p>\n<p>转后的AST结构发生了变化，这就是转换阶段babel的作用，将源代码的AST按照<a href=\"https://github.com/estree/estree\">标准规范</a>转换成目标代码的AST。看到这儿，我们其实已经可以手写一个简单的插件来玩玩了。</p>\n<p>我们新建一个文件<code>replaceN2M.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> &#123;<br>    <span class=\"hljs-comment\">// visitor 遍历回调</span><br>    <span class=\"hljs-attr\">visitor</span>: &#123;<br>      <span class=\"hljs-comment\">// type === &#x27;Identifier&#x27; step into</span><br>      <span class=\"hljs-function\"><span class=\"hljs-title\">Identifier</span>(<span class=\"hljs-params\">path</span>)</span> &#123;<br>        <span class=\"hljs-comment\">// n -&gt; m</span><br>        <span class=\"hljs-keyword\">if</span> (path.isIdentifier(&#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;n&quot;</span> &#125;)) &#123;<br>          path.node.name = <span class=\"hljs-string\">&quot;m&quot;</span>;<br>        &#125;<br>      &#125;,<br>      <span class=\"hljs-comment\">// type === &#x27;BinaryExpression&#x27; step into</span><br>      <span class=\"hljs-function\"><span class=\"hljs-title\">BinaryExpression</span>(<span class=\"hljs-params\">path</span>)</span> &#123;<br>        <span class=\"hljs-comment\">// * -&gt; -</span><br>        <span class=\"hljs-keyword\">if</span> (path.node.operator === <span class=\"hljs-string\">&quot;*&quot;</span>) &#123;<br>          path.node.operator = <span class=\"hljs-string\">&quot;-&quot;</span>;<br>        &#125;<br>      &#125;,<br>    &#125;,<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>一个最简单的插件就完成了，它做了两件事，将所有变量<code>n</code>转换成<code>m</code>，将所有二元表达式的运算符<code>*</code>转换成<code>-</code>。<br>babel会深度优先遍历AST，期间会调用插件中的<code>visitor.method</code>，visitor里存放对AST的操作回调，<code>Identifier()&#123;&#125;</code>是指当前AST节点的<code>type === &#39;Identifier&#39;</code>时，进入此函数，此时<code>path</code>为当前位置，<code>path.node</code>为此节点，那么我们就可以对node进行操作。</p>\n<p>我们新建一个文件<code>test2.js</code>，看下我们的插件是否起作用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> square = <span class=\"hljs-function\"><span class=\"hljs-params\">n</span> =&gt;</span> n * n<br></code></pre></td></tr></table></figure>\n\n<p>自定义的方法有两种方法进行调用，一种是直接使用babel编译命令，<code>npx babel --plugins ./replaceN2M.js test2.js</code>。第二种是，将我们的插件放进babel的配置文件里，在<code>babel.config.js</code>的plugin中添加<code>&quot;./replaceN2M&quot;</code>，现在整个plugin长这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">plugins: [<br>      [<span class=\"hljs-string\">&quot;@babel/proposal-object-rest-spread&quot;</span>, &#123; <span class=\"hljs-attr\">useBuiltIns</span>: <span class=\"hljs-literal\">true</span> &#125;],<br><br>      convertESM ? <span class=\"hljs-string\">&quot;@babel/proposal-export-namespace-from&quot;</span> : <span class=\"hljs-literal\">null</span>,<br>      convertESM ? pluginImportMetaUrl : <span class=\"hljs-literal\">null</span>,<br><br>      pluginPackageJsonMacro,<br><br>      process.env.STRIP_BABEL_8_FLAG &amp;&amp; [<br>        pluginToggleBabel8Breaking,<br>        &#123; <span class=\"hljs-attr\">breaking</span>: bool(process.env.BABEL_8_BREAKING) &#125;,<br>      ],<br>      needsPolyfillsForOldNode &amp;&amp; pluginPolyfillsOldNode,<br>      <span class=\"hljs-string\">&quot;./replaceN2M&quot;</span>,<br>    ].filter(<span class=\"hljs-built_in\">Boolean</span>)<br></code></pre></td></tr></table></figure>\n<p>然后直接运行 <code>npx babel test2.js</code>即可，我们可以看到控制台输出了我们想要的结果，或者，让babel直接编译成文件<code>npx babel test2.js --out-dir ./ </code>，再打开<code>test2.js</code>看到文件内容已经是编译后的内容。</p>\n<p>写一个插件最大的难点在于对babelAPI的不熟悉以及对ECMA规范的不了解，如果要写一个复杂的插件，需要多看看类似插件的实现，强烈推荐<a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md#paths\">babel插件开发手册</a>，基本涵盖了开发插件所需要的所有知识。</p>\n<p>到这里，我的好奇心基本都已经打消了，转换后的AST怎么重新生成代码，这里就不深入研究了，感兴趣可以直接去看源码。</p>\n<h3 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h3><p><a href=\"https://www.cnblogs.com/chyingp/p/how-to-write-a-babel-plugin.html\">Babel插件开发入门指南</a></p>\n<p><a href=\"https://lihautan.com/step-by-step-guide-for-writing-a-babel-transformation/\">Step-by-step guide for writing a custom babel transformation</a></p>\n<p><a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md\">Babel 插件开发手册</a></p>\n","site":{"data":{}},"wordcount":2810,"excerpt":"","more":"<p>我们在<a href=\"https://luoluoqinghuan.cn/2021/04/01/howBabelWork_parser/\">上文</a>中已经了解到babel的第一步，将代码解析成AST，接下来的两步就比较好理解了，转换与生成。我再看最开始的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> &#123; parse &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;./packages/babel-parser&quot;</span>);<br><span class=\"hljs-keyword\">const</span> traverse = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;./packages/babel-traverse&quot;</span>).default;<br><span class=\"hljs-keyword\">const</span> generate = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;./packages/babel-generator&quot;</span>).default;<br><br><span class=\"hljs-keyword\">const</span> code = <span class=\"hljs-string\">&quot;const square = n =&gt; n * n&quot;</span>;<br><br><span class=\"hljs-comment\">// parse the code -&gt; ast</span><br><span class=\"hljs-keyword\">const</span> ast = parse(code);<br><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`originAST: <span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">JSON</span>.stringify(ast)&#125;</span>`</span>);<br><span class=\"hljs-comment\">// transform the ast</span><br>traverse(ast, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">enter</span>(<span class=\"hljs-params\">path</span>)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (path.node.type !== <span class=\"hljs-string\">&quot;ArrowFunctionExpression&quot;</span>) <span class=\"hljs-keyword\">return</span>;<br><br>    path.arrowFunctionToExpression(&#123;<br>      <span class=\"hljs-attr\">allowInsertArrow</span>: <span class=\"hljs-literal\">false</span>,<br>      <span class=\"hljs-attr\">noNewArrows</span>: <span class=\"hljs-literal\">true</span>,<br>      <span class=\"hljs-attr\">specCompliant</span>: <span class=\"hljs-literal\">false</span>,<br>    &#125;);<br>  &#125;,<br>&#125;);<br><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`newAST: <span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">JSON</span>.stringify(ast)&#125;</span>`</span>)<br><span class=\"hljs-comment\">// generate code &lt;- ast</span><br><span class=\"hljs-keyword\">const</span> output = generate(ast, code);<br><span class=\"hljs-built_in\">console</span>.log(output.code);<br><span class=\"hljs-comment\">// const square = function (n) &#123;</span><br><span class=\"hljs-comment\">//     return n * n;</span><br><span class=\"hljs-comment\">//   &#125;;</span><br></code></pre></td></tr></table></figure>\n\n<p>转换这里的代码其实是<code>babel-plugin-transform-arrow-functions</code>的源码，作用是将箭头函数转换成普通函数，我们分别将转换前后的AST打印出来，比较看一下这个插件对AST做了什么。<br><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/408772caac94408eb086119c22020f6c~tplv-k3u1fbpfcp-watermark.image\" alt=\"astCompared\"></p>\n<p>转后的AST结构发生了变化，这就是转换阶段babel的作用，将源代码的AST按照<a href=\"https://github.com/estree/estree\">标准规范</a>转换成目标代码的AST。看到这儿，我们其实已经可以手写一个简单的插件来玩玩了。</p>\n<p>我们新建一个文件<code>replaceN2M.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">module</span>.exports = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> &#123;<br>    <span class=\"hljs-comment\">// visitor 遍历回调</span><br>    <span class=\"hljs-attr\">visitor</span>: &#123;<br>      <span class=\"hljs-comment\">// type === &#x27;Identifier&#x27; step into</span><br>      <span class=\"hljs-function\"><span class=\"hljs-title\">Identifier</span>(<span class=\"hljs-params\">path</span>)</span> &#123;<br>        <span class=\"hljs-comment\">// n -&gt; m</span><br>        <span class=\"hljs-keyword\">if</span> (path.isIdentifier(&#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;n&quot;</span> &#125;)) &#123;<br>          path.node.name = <span class=\"hljs-string\">&quot;m&quot;</span>;<br>        &#125;<br>      &#125;,<br>      <span class=\"hljs-comment\">// type === &#x27;BinaryExpression&#x27; step into</span><br>      <span class=\"hljs-function\"><span class=\"hljs-title\">BinaryExpression</span>(<span class=\"hljs-params\">path</span>)</span> &#123;<br>        <span class=\"hljs-comment\">// * -&gt; -</span><br>        <span class=\"hljs-keyword\">if</span> (path.node.operator === <span class=\"hljs-string\">&quot;*&quot;</span>) &#123;<br>          path.node.operator = <span class=\"hljs-string\">&quot;-&quot;</span>;<br>        &#125;<br>      &#125;,<br>    &#125;,<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>一个最简单的插件就完成了，它做了两件事，将所有变量<code>n</code>转换成<code>m</code>，将所有二元表达式的运算符<code>*</code>转换成<code>-</code>。<br>babel会深度优先遍历AST，期间会调用插件中的<code>visitor.method</code>，visitor里存放对AST的操作回调，<code>Identifier()&#123;&#125;</code>是指当前AST节点的<code>type === &#39;Identifier&#39;</code>时，进入此函数，此时<code>path</code>为当前位置，<code>path.node</code>为此节点，那么我们就可以对node进行操作。</p>\n<p>我们新建一个文件<code>test2.js</code>，看下我们的插件是否起作用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> square = <span class=\"hljs-function\"><span class=\"hljs-params\">n</span> =&gt;</span> n * n<br></code></pre></td></tr></table></figure>\n\n<p>自定义的方法有两种方法进行调用，一种是直接使用babel编译命令，<code>npx babel --plugins ./replaceN2M.js test2.js</code>。第二种是，将我们的插件放进babel的配置文件里，在<code>babel.config.js</code>的plugin中添加<code>&quot;./replaceN2M&quot;</code>，现在整个plugin长这样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">plugins: [<br>      [<span class=\"hljs-string\">&quot;@babel/proposal-object-rest-spread&quot;</span>, &#123; <span class=\"hljs-attr\">useBuiltIns</span>: <span class=\"hljs-literal\">true</span> &#125;],<br><br>      convertESM ? <span class=\"hljs-string\">&quot;@babel/proposal-export-namespace-from&quot;</span> : <span class=\"hljs-literal\">null</span>,<br>      convertESM ? pluginImportMetaUrl : <span class=\"hljs-literal\">null</span>,<br><br>      pluginPackageJsonMacro,<br><br>      process.env.STRIP_BABEL_8_FLAG &amp;&amp; [<br>        pluginToggleBabel8Breaking,<br>        &#123; <span class=\"hljs-attr\">breaking</span>: bool(process.env.BABEL_8_BREAKING) &#125;,<br>      ],<br>      needsPolyfillsForOldNode &amp;&amp; pluginPolyfillsOldNode,<br>      <span class=\"hljs-string\">&quot;./replaceN2M&quot;</span>,<br>    ].filter(<span class=\"hljs-built_in\">Boolean</span>)<br></code></pre></td></tr></table></figure>\n<p>然后直接运行 <code>npx babel test2.js</code>即可，我们可以看到控制台输出了我们想要的结果，或者，让babel直接编译成文件<code>npx babel test2.js --out-dir ./ </code>，再打开<code>test2.js</code>看到文件内容已经是编译后的内容。</p>\n<p>写一个插件最大的难点在于对babelAPI的不熟悉以及对ECMA规范的不了解，如果要写一个复杂的插件，需要多看看类似插件的实现，强烈推荐<a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md#paths\">babel插件开发手册</a>，基本涵盖了开发插件所需要的所有知识。</p>\n<p>到这里，我的好奇心基本都已经打消了，转换后的AST怎么重新生成代码，这里就不深入研究了，感兴趣可以直接去看源码。</p>\n<h3 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h3><p><a href=\"https://www.cnblogs.com/chyingp/p/how-to-write-a-babel-plugin.html\">Babel插件开发入门指南</a></p>\n<p><a href=\"https://lihautan.com/step-by-step-guide-for-writing-a-babel-transformation/\">Step-by-step guide for writing a custom babel transformation</a></p>\n<p><a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md\">Babel 插件开发手册</a></p>\n"},{"title":"Babel原理浅析(一)：解析","date":"2021-04-01T15:16:10.000Z","index_img":"https://d33wubrfki0l68.cloudfront.net/7a197cfe44548cc1a3f581152af70a3051e11671/78df8/img/babel.svg","_content":"### 概述\nbabel可以将ECMAScript2015+的语法，编译成ES5的语法，如：\n```javascript\nconst square = n => n * n;\n```\n转换为\n```javascript\n\"use strict\";\n\nvar square = function square(n) {\n  return n * n;\n};\n```\n可以在[babel repl](https://babeljs.io/repl#?browsers=defaults%2C%20not%20ie%2011%2C%20not%20ie_mob%2011&build=&builtIns=false&corejs=3.6&spec=false&loose=false&code_lz=MYewdgzgLgBBCOBXAhgJwKYwLwzNgfLjAFS4DcAUEA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=true&fileSize=true&timeTravel=true&sourceType=module&lineWrap=true&presets=es2015%2Ces2016%2Ces2017&prettier=true&targets=&version=7.16.7&externalPlugins=&assumptions=%7B%7D)进行尝试。\n\n**babel是如何做到的呢**\n\n最自然的想法是这样，js代码实际上就是一长串字符串，babel是将一个字符串替换为另一种字符串，那我们写一个字符串替换的程序对这个字符串进行替换似乎就可以做到。\n\n但如果你下手去写，就会发现无从下手。首先这个替换规则必然非常复杂，正则替换的方式，会让整个正则表达式异常复杂。其次ES6中有一些复杂的语法糖，比如`class`，如何去实现呢，单纯替换是不好去做的。\n\n我们可能要借助一些数据结构(AST)去实现这件事。\n\nbabel用了三个运行阶段去做：**解析(parse)**、**转换(transform)**、**生成(generate)**\n\n我们可以在babel源码中调试看一下，先将babel仓库clone到本地，在babel根目录`build`一下。\n```bash\nyarn install\nnpm run build\n```\n新建文件test.js\n```javascript\nconst { parse } = require(\"./packages/babel-parser\");\nconst traverse = require(\"./packages/babel-traverse\").default;\nconst generate = require(\"./packages/babel-generator\").default;\n\nconst code = \"const square = n => n * n\";\n\n// parse the code -> ast\nconst ast = parse(code);\n\n// transform the ast\ntraverse(ast, {\n  enter(path) {\n    if (path.node.type !== \"ArrowFunctionExpression\") return;\n\n    path.arrowFunctionToExpression({\n      allowInsertArrow: false,\n      noNewArrows: true,\n      specCompliant: false,\n    });\n  },\n});\n\n// generate code <- ast\nconst output = generate(ast, code);\nconsole.log(output.code);\n// const square = function (n) {\n//     return n * n;\n//   };\n```\n运行一下这段代码，可以看到在控制台打印出了转换后的代码，`parse`、`traverse`、`generate`分别对应转换过程的三个阶段，下面我尝试讲解下这个三个具体过程。\n```javascript\ncode -> AST -> transformed AST -> transformed code\n```\n\n### 解析\n\n解析阶段分为两步，词法分析(lexical analysis)、语法分析(syntax analysis)，最终将一个js文件解析成为一棵抽象语法树(AST)。\n\n第一个术语出现了，什么是AST，如果你看过《VS CODE权威指南》，可能对这个词会有点印象，AST是一种n叉树表示的数据结构，包含分析源代码的所有必要信息（关键词，变量名，变量值等），是代码的一种抽象表示，方便开发者对代码进行转换操作，编译器可以将代码解析成AST，也可以根据AST重新生成代码，眼见为实，先来用babel的解析器生成一棵AST，这部分代码都在[babel/packages/babel-parser](https://github.com/babel/babel/tree/main/packages/babel-parser)中。\n\n\n我们在test.js中将ast打印出来\n```javascript \nconsole.log(ast)\n```\n可以看到babel解析器输出了AST。它非常的长，我们只有一行函数声明，它对应的AST竟然有近200行。我们去掉一些代码位置信息，分析一下这个精简版AST。\n```json\n{\n    \"type\": \"File\",\n    \"program\": {\n        \"type\": \"Program\",\n        \"sourceType\": \"script\",\n        \"body\": [\n            {\n                \"type\": \"VariableDeclaration\",\n                \"declarations\": [\n                    {\n                        \"type\": \"VariableDeclarator\",\n                        \"id\": {\n                            \"type\": \"Identifier\",\n                            \"name\": \"square\"\n                        },\n                        \"init\": {\n                            \"type\": \"ArrowFunctionExpression\",\n                            \"id\": null,\n                            \"generator\": false,\n                            \"async\": false,\n                            \"params\": [\n                                {\n                                    \"type\": \"Identifier\",\n                                    \"name\": \"n\"\n                                }\n                            ],\n                            \"body\": {\n                                \"type\": \"BinaryExpression\",\n                                \"left\": {\n                                    \"type\": \"Identifier\",\n                                    \"name\": \"n\"\n                                },\n                                \"operator\": \"*\",\n                                \"right\": {\n                                    \"type\": \"Identifier\",\n                                    \"name\": \"n\"\n                                }\n                            }\n                        }\n                    }\n                ],\n                \"kind\": \"const\"\n            }\n        ]\n    }\n}\n```\n每一个代码块都有一个type字段，标识这个代码块的类型，如`Program`程序、`VariableDeclaration`变量声明、`ArrowFunctionExpression`箭头函数、`BinaryExpression`二项式等，每个代码块的结构不是相同的，比如`BinaryExpression`的内容是`left`、`right`、`operator`，代表`n * n`，`ArrowFunctionExpression`的内容有`params`、`body`，代表`(...params) => body`。\n\n看到这，我们已经明白AST是个什么数据结构了\n+ n叉树。\n+ 每个节点包含至少两种信息，`type`节点类型、描述该类型所需要的信息（在后面的AST->code阶段，这些信息足够我们去重新生成代码）。\n\n笔者最近的工作是开发一个低代码平台，看到这个结构是非常亲切呀，跟我们平台底层配置项的数据结构可太像了，不了解低代码平台的的可以看下[这里](https://juejin.cn/post/6925306474524737543)，另外，我有突然想到[浏览器解析过程](https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#building_the_dom_tree)会将html文件、css文件解析为DOM树与CSSOM树，这两棵树也可能是AST。\n\n任何语言都可以被解析成AST，AST是各种语言解析编译运行过程中，都会有的中间产物，那么它是怎么生成的呢？\n*注：下面的过程为理论推演过程，跟babel的具体实现不完全相同*\n\n两步：**词法解析**、**语法解析**\n\n\n![lexicalAnalysis](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b17b20db033642368a0a4d69a2ddd737~tplv-k3u1fbpfcp-watermark.image?)\n\n词法解析（lexical analysis），顾名思义，是对单词本义的解析，首先扫描器（scanner）会对代码进行扫描操作，把代码分割成一个个有意义的词（lexemes），如：单词，标点等。`const square = n => n * n;`会被分割成`[const, squara, =, n, =, >, n, *, n]`。这个过程跟这段代码是用什么语言写的没有关系。随后标识器（tokenizer）会对lexemes进行释义，比如：`const`会被标识为关键字、`=, >`两个符号会标识为箭头，这个过程就与使用的语言有关了，`const`在js中会被标识为关键字，但在其他语言中就不一定。最后输出(tokens)为\n```javascript\n[\n    {\n        \"type\": \"Keyword\",\n        \"value\": \"const\"\n    },\n    {\n        \"type\": \"Identifier\",\n        \"value\": \"square\"\n    },\n    {\n        \"type\": \"Punctuator\",\n        \"value\": \"=\"\n    },\n    {\n        \"type\": \"Identifier\",\n        \"value\": \"n\"\n    },\n    {\n        \"type\": \"Punctuator\",\n        \"value\": \"=>\"\n    },\n    {\n        \"type\": \"Identifier\",\n        \"value\": \"n\"\n    },\n    {\n        \"type\": \"Punctuator\",\n        \"value\": \"*\"\n    },\n    {\n        \"type\": \"Identifier\",\n        \"value\": \"n\"\n    },\n    {\n        \"type\": \"Punctuator\",\n        \"value\": \";\"\n    }\n]\n```\n当我们有了tokens，就可以进行语法解析（syntax analysis）了，解析器（parser）会把tokens转换为一棵解析树（parse tree），也可以称之为具体语法树(CST, concrete syntax tree)\n![syntaxTree](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04039762baf24be6adbc2fc0c80da617~tplv-k3u1fbpfcp-watermark.image?)\n如果仔细看这棵CST，可以看到很多无用信息，比如，有很多节点只有一个子节点，那这种节点完全可以压缩去掉，因为它没有给我们提供额外的有用信息。\n![cstAfterCompress](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bbe883ca20c47bfbe50c741f734d6a3~tplv-k3u1fbpfcp-watermark.image?)\n压缩后继续来看这棵树，可以发现一些标点符号与操作符可以用n叉树本身的结构就可以代表，所以再来简化一下。\n![ast](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69b9d88e7e824353980fb4455607812e~tplv-k3u1fbpfcp-watermark.image?)\n得到了最终我们想要的结构，一棵非常抽象（相较于CST）、简化的AST。\n\n可以在[这个网站](https://esprima.org/demo/parse.html?code=const%20square%20%3D%20n%20%3D%3E%20n%20*%20n%3B%0A)，输入随便一段代码，看看对应的tokens与AST。\n\n得到AST后，我们就可以对AST进行操作，将其转换成我们想要的代码所对应的结构，这部分就是转换, 点击前往⬇️\n\n[Babel原理浅析(二): 手写一个极简插件](https://luoluoqinghuan.cn/2021/04/09/howTransformBabelAst/)\n\n### References\n[Leveling Up One’s Parsing Game With ASTs](https://medium.com/basecs/leveling-up-ones-parsing-game-with-asts-d7a6fc2400ff)\n\n[Babel under the hood](https://medium.com/@makk.bit/babel-under-the-hood-63e3fb961243)\n\n[Babel插件开发入门指南](https://www.cnblogs.com/chyingp/p/how-to-write-a-babel-plugin.html)\n\n[Step-by-step guide for writing a custom babel transformation](https://lihautan.com/step-by-step-guide-for-writing-a-babel-transformation/)\n\n[Babel 用户手册](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md)","source":"_posts/howBabelWork_parser.md","raw":"---\ntitle: Babel原理浅析(一)：解析\ndate: 2021-04-01 23:16:10\nindex_img: https://d33wubrfki0l68.cloudfront.net/7a197cfe44548cc1a3f581152af70a3051e11671/78df8/img/babel.svg\ntags: [JavaScript, Babel, 前端工程化]\ncategories: [源码解读]\n---\n### 概述\nbabel可以将ECMAScript2015+的语法，编译成ES5的语法，如：\n```javascript\nconst square = n => n * n;\n```\n转换为\n```javascript\n\"use strict\";\n\nvar square = function square(n) {\n  return n * n;\n};\n```\n可以在[babel repl](https://babeljs.io/repl#?browsers=defaults%2C%20not%20ie%2011%2C%20not%20ie_mob%2011&build=&builtIns=false&corejs=3.6&spec=false&loose=false&code_lz=MYewdgzgLgBBCOBXAhgJwKYwLwzNgfLjAFS4DcAUEA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=true&fileSize=true&timeTravel=true&sourceType=module&lineWrap=true&presets=es2015%2Ces2016%2Ces2017&prettier=true&targets=&version=7.16.7&externalPlugins=&assumptions=%7B%7D)进行尝试。\n\n**babel是如何做到的呢**\n\n最自然的想法是这样，js代码实际上就是一长串字符串，babel是将一个字符串替换为另一种字符串，那我们写一个字符串替换的程序对这个字符串进行替换似乎就可以做到。\n\n但如果你下手去写，就会发现无从下手。首先这个替换规则必然非常复杂，正则替换的方式，会让整个正则表达式异常复杂。其次ES6中有一些复杂的语法糖，比如`class`，如何去实现呢，单纯替换是不好去做的。\n\n我们可能要借助一些数据结构(AST)去实现这件事。\n\nbabel用了三个运行阶段去做：**解析(parse)**、**转换(transform)**、**生成(generate)**\n\n我们可以在babel源码中调试看一下，先将babel仓库clone到本地，在babel根目录`build`一下。\n```bash\nyarn install\nnpm run build\n```\n新建文件test.js\n```javascript\nconst { parse } = require(\"./packages/babel-parser\");\nconst traverse = require(\"./packages/babel-traverse\").default;\nconst generate = require(\"./packages/babel-generator\").default;\n\nconst code = \"const square = n => n * n\";\n\n// parse the code -> ast\nconst ast = parse(code);\n\n// transform the ast\ntraverse(ast, {\n  enter(path) {\n    if (path.node.type !== \"ArrowFunctionExpression\") return;\n\n    path.arrowFunctionToExpression({\n      allowInsertArrow: false,\n      noNewArrows: true,\n      specCompliant: false,\n    });\n  },\n});\n\n// generate code <- ast\nconst output = generate(ast, code);\nconsole.log(output.code);\n// const square = function (n) {\n//     return n * n;\n//   };\n```\n运行一下这段代码，可以看到在控制台打印出了转换后的代码，`parse`、`traverse`、`generate`分别对应转换过程的三个阶段，下面我尝试讲解下这个三个具体过程。\n```javascript\ncode -> AST -> transformed AST -> transformed code\n```\n\n### 解析\n\n解析阶段分为两步，词法分析(lexical analysis)、语法分析(syntax analysis)，最终将一个js文件解析成为一棵抽象语法树(AST)。\n\n第一个术语出现了，什么是AST，如果你看过《VS CODE权威指南》，可能对这个词会有点印象，AST是一种n叉树表示的数据结构，包含分析源代码的所有必要信息（关键词，变量名，变量值等），是代码的一种抽象表示，方便开发者对代码进行转换操作，编译器可以将代码解析成AST，也可以根据AST重新生成代码，眼见为实，先来用babel的解析器生成一棵AST，这部分代码都在[babel/packages/babel-parser](https://github.com/babel/babel/tree/main/packages/babel-parser)中。\n\n\n我们在test.js中将ast打印出来\n```javascript \nconsole.log(ast)\n```\n可以看到babel解析器输出了AST。它非常的长，我们只有一行函数声明，它对应的AST竟然有近200行。我们去掉一些代码位置信息，分析一下这个精简版AST。\n```json\n{\n    \"type\": \"File\",\n    \"program\": {\n        \"type\": \"Program\",\n        \"sourceType\": \"script\",\n        \"body\": [\n            {\n                \"type\": \"VariableDeclaration\",\n                \"declarations\": [\n                    {\n                        \"type\": \"VariableDeclarator\",\n                        \"id\": {\n                            \"type\": \"Identifier\",\n                            \"name\": \"square\"\n                        },\n                        \"init\": {\n                            \"type\": \"ArrowFunctionExpression\",\n                            \"id\": null,\n                            \"generator\": false,\n                            \"async\": false,\n                            \"params\": [\n                                {\n                                    \"type\": \"Identifier\",\n                                    \"name\": \"n\"\n                                }\n                            ],\n                            \"body\": {\n                                \"type\": \"BinaryExpression\",\n                                \"left\": {\n                                    \"type\": \"Identifier\",\n                                    \"name\": \"n\"\n                                },\n                                \"operator\": \"*\",\n                                \"right\": {\n                                    \"type\": \"Identifier\",\n                                    \"name\": \"n\"\n                                }\n                            }\n                        }\n                    }\n                ],\n                \"kind\": \"const\"\n            }\n        ]\n    }\n}\n```\n每一个代码块都有一个type字段，标识这个代码块的类型，如`Program`程序、`VariableDeclaration`变量声明、`ArrowFunctionExpression`箭头函数、`BinaryExpression`二项式等，每个代码块的结构不是相同的，比如`BinaryExpression`的内容是`left`、`right`、`operator`，代表`n * n`，`ArrowFunctionExpression`的内容有`params`、`body`，代表`(...params) => body`。\n\n看到这，我们已经明白AST是个什么数据结构了\n+ n叉树。\n+ 每个节点包含至少两种信息，`type`节点类型、描述该类型所需要的信息（在后面的AST->code阶段，这些信息足够我们去重新生成代码）。\n\n笔者最近的工作是开发一个低代码平台，看到这个结构是非常亲切呀，跟我们平台底层配置项的数据结构可太像了，不了解低代码平台的的可以看下[这里](https://juejin.cn/post/6925306474524737543)，另外，我有突然想到[浏览器解析过程](https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#building_the_dom_tree)会将html文件、css文件解析为DOM树与CSSOM树，这两棵树也可能是AST。\n\n任何语言都可以被解析成AST，AST是各种语言解析编译运行过程中，都会有的中间产物，那么它是怎么生成的呢？\n*注：下面的过程为理论推演过程，跟babel的具体实现不完全相同*\n\n两步：**词法解析**、**语法解析**\n\n\n![lexicalAnalysis](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b17b20db033642368a0a4d69a2ddd737~tplv-k3u1fbpfcp-watermark.image?)\n\n词法解析（lexical analysis），顾名思义，是对单词本义的解析，首先扫描器（scanner）会对代码进行扫描操作，把代码分割成一个个有意义的词（lexemes），如：单词，标点等。`const square = n => n * n;`会被分割成`[const, squara, =, n, =, >, n, *, n]`。这个过程跟这段代码是用什么语言写的没有关系。随后标识器（tokenizer）会对lexemes进行释义，比如：`const`会被标识为关键字、`=, >`两个符号会标识为箭头，这个过程就与使用的语言有关了，`const`在js中会被标识为关键字，但在其他语言中就不一定。最后输出(tokens)为\n```javascript\n[\n    {\n        \"type\": \"Keyword\",\n        \"value\": \"const\"\n    },\n    {\n        \"type\": \"Identifier\",\n        \"value\": \"square\"\n    },\n    {\n        \"type\": \"Punctuator\",\n        \"value\": \"=\"\n    },\n    {\n        \"type\": \"Identifier\",\n        \"value\": \"n\"\n    },\n    {\n        \"type\": \"Punctuator\",\n        \"value\": \"=>\"\n    },\n    {\n        \"type\": \"Identifier\",\n        \"value\": \"n\"\n    },\n    {\n        \"type\": \"Punctuator\",\n        \"value\": \"*\"\n    },\n    {\n        \"type\": \"Identifier\",\n        \"value\": \"n\"\n    },\n    {\n        \"type\": \"Punctuator\",\n        \"value\": \";\"\n    }\n]\n```\n当我们有了tokens，就可以进行语法解析（syntax analysis）了，解析器（parser）会把tokens转换为一棵解析树（parse tree），也可以称之为具体语法树(CST, concrete syntax tree)\n![syntaxTree](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04039762baf24be6adbc2fc0c80da617~tplv-k3u1fbpfcp-watermark.image?)\n如果仔细看这棵CST，可以看到很多无用信息，比如，有很多节点只有一个子节点，那这种节点完全可以压缩去掉，因为它没有给我们提供额外的有用信息。\n![cstAfterCompress](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bbe883ca20c47bfbe50c741f734d6a3~tplv-k3u1fbpfcp-watermark.image?)\n压缩后继续来看这棵树，可以发现一些标点符号与操作符可以用n叉树本身的结构就可以代表，所以再来简化一下。\n![ast](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69b9d88e7e824353980fb4455607812e~tplv-k3u1fbpfcp-watermark.image?)\n得到了最终我们想要的结构，一棵非常抽象（相较于CST）、简化的AST。\n\n可以在[这个网站](https://esprima.org/demo/parse.html?code=const%20square%20%3D%20n%20%3D%3E%20n%20*%20n%3B%0A)，输入随便一段代码，看看对应的tokens与AST。\n\n得到AST后，我们就可以对AST进行操作，将其转换成我们想要的代码所对应的结构，这部分就是转换, 点击前往⬇️\n\n[Babel原理浅析(二): 手写一个极简插件](https://luoluoqinghuan.cn/2021/04/09/howTransformBabelAst/)\n\n### References\n[Leveling Up One’s Parsing Game With ASTs](https://medium.com/basecs/leveling-up-ones-parsing-game-with-asts-d7a6fc2400ff)\n\n[Babel under the hood](https://medium.com/@makk.bit/babel-under-the-hood-63e3fb961243)\n\n[Babel插件开发入门指南](https://www.cnblogs.com/chyingp/p/how-to-write-a-babel-plugin.html)\n\n[Step-by-step guide for writing a custom babel transformation](https://lihautan.com/step-by-step-guide-for-writing-a-babel-transformation/)\n\n[Babel 用户手册](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md)","slug":"howBabelWork_parser","published":1,"updated":"2025-06-10T04:39:28.845Z","_id":"ckyo4lu6n0005nz6925a4df9f","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>babel可以将ECMAScript2015+的语法，编译成ES5的语法，如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> square = <span class=\"hljs-function\"><span class=\"hljs-params\">n</span> =&gt;</span> n * n;<br></code></pre></td></tr></table></figure>\n<p>转换为</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-meta\">&quot;use strict&quot;</span>;<br><br><span class=\"hljs-keyword\">var</span> square = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">square</span>(<span class=\"hljs-params\">n</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> n * n;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>可以在<a href=\"https://babeljs.io/repl#?browsers=defaults%2C%20not%20ie%2011%2C%20not%20ie_mob%2011&build=&builtIns=false&corejs=3.6&spec=false&loose=false&code_lz=MYewdgzgLgBBCOBXAhgJwKYwLwzNgfLjAFS4DcAUEA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=true&fileSize=true&timeTravel=true&sourceType=module&lineWrap=true&presets=es2015%2Ces2016%2Ces2017&prettier=true&targets=&version=7.16.7&externalPlugins=&assumptions=%7B%7D\">babel repl</a>进行尝试。</p>\n<p><strong>babel是如何做到的呢</strong></p>\n<p>最自然的想法是这样，js代码实际上就是一长串字符串，babel是将一个字符串替换为另一种字符串，那我们写一个字符串替换的程序对这个字符串进行替换似乎就可以做到。</p>\n<p>但如果你下手去写，就会发现无从下手。首先这个替换规则必然非常复杂，正则替换的方式，会让整个正则表达式异常复杂。其次ES6中有一些复杂的语法糖，比如<code>class</code>，如何去实现呢，单纯替换是不好去做的。</p>\n<p>我们可能要借助一些数据结构(AST)去实现这件事。</p>\n<p>babel用了三个运行阶段去做：<strong>解析(parse)<strong>、</strong>转换(transform)<strong>、</strong>生成(generate)</strong></p>\n<p>我们可以在babel源码中调试看一下，先将babel仓库clone到本地，在babel根目录<code>build</code>一下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn install<br>npm run build<br></code></pre></td></tr></table></figure>\n<p>新建文件test.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> &#123; parse &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;./packages/babel-parser&quot;</span>);<br><span class=\"hljs-keyword\">const</span> traverse = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;./packages/babel-traverse&quot;</span>).default;<br><span class=\"hljs-keyword\">const</span> generate = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;./packages/babel-generator&quot;</span>).default;<br><br><span class=\"hljs-keyword\">const</span> code = <span class=\"hljs-string\">&quot;const square = n =&gt; n * n&quot;</span>;<br><br><span class=\"hljs-comment\">// parse the code -&gt; ast</span><br><span class=\"hljs-keyword\">const</span> ast = parse(code);<br><br><span class=\"hljs-comment\">// transform the ast</span><br>traverse(ast, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">enter</span>(<span class=\"hljs-params\">path</span>)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (path.node.type !== <span class=\"hljs-string\">&quot;ArrowFunctionExpression&quot;</span>) <span class=\"hljs-keyword\">return</span>;<br><br>    path.arrowFunctionToExpression(&#123;<br>      <span class=\"hljs-attr\">allowInsertArrow</span>: <span class=\"hljs-literal\">false</span>,<br>      <span class=\"hljs-attr\">noNewArrows</span>: <span class=\"hljs-literal\">true</span>,<br>      <span class=\"hljs-attr\">specCompliant</span>: <span class=\"hljs-literal\">false</span>,<br>    &#125;);<br>  &#125;,<br>&#125;);<br><br><span class=\"hljs-comment\">// generate code &lt;- ast</span><br><span class=\"hljs-keyword\">const</span> output = generate(ast, code);<br><span class=\"hljs-built_in\">console</span>.log(output.code);<br><span class=\"hljs-comment\">// const square = function (n) &#123;</span><br><span class=\"hljs-comment\">//     return n * n;</span><br><span class=\"hljs-comment\">//   &#125;;</span><br></code></pre></td></tr></table></figure>\n<p>运行一下这段代码，可以看到在控制台打印出了转换后的代码，<code>parse</code>、<code>traverse</code>、<code>generate</code>分别对应转换过程的三个阶段，下面我尝试讲解下这个三个具体过程。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">code -&gt; AST -&gt; transformed AST -&gt; transformed code<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>解析阶段分为两步，词法分析(lexical analysis)、语法分析(syntax analysis)，最终将一个js文件解析成为一棵抽象语法树(AST)。</p>\n<p>第一个术语出现了，什么是AST，如果你看过《VS CODE权威指南》，可能对这个词会有点印象，AST是一种n叉树表示的数据结构，包含分析源代码的所有必要信息（关键词，变量名，变量值等），是代码的一种抽象表示，方便开发者对代码进行转换操作，编译器可以将代码解析成AST，也可以根据AST重新生成代码，眼见为实，先来用babel的解析器生成一棵AST，这部分代码都在<a href=\"https://github.com/babel/babel/tree/main/packages/babel-parser\">babel/packages/babel-parser</a>中。</p>\n<p>我们在test.js中将ast打印出来</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">console</span>.log(ast)<br></code></pre></td></tr></table></figure>\n<p>可以看到babel解析器输出了AST。它非常的长，我们只有一行函数声明，它对应的AST竟然有近200行。我们去掉一些代码位置信息，分析一下这个精简版AST。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\">&#123;<br>    <span class=\"hljs-attr\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;File&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;program&quot;</span>: &#123;<br>        <span class=\"hljs-attr\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Program&quot;</span>,<br>        <span class=\"hljs-attr\">&quot;sourceType&quot;</span>: <span class=\"hljs-string\">&quot;script&quot;</span>,<br>        <span class=\"hljs-attr\">&quot;body&quot;</span>: [<br>            &#123;<br>                <span class=\"hljs-attr\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;VariableDeclaration&quot;</span>,<br>                <span class=\"hljs-attr\">&quot;declarations&quot;</span>: [<br>                    &#123;<br>                        <span class=\"hljs-attr\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;VariableDeclarator&quot;</span>,<br>                        <span class=\"hljs-attr\">&quot;id&quot;</span>: &#123;<br>                            <span class=\"hljs-attr\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Identifier&quot;</span>,<br>                            <span class=\"hljs-attr\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;square&quot;</span><br>                        &#125;,<br>                        <span class=\"hljs-attr\">&quot;init&quot;</span>: &#123;<br>                            <span class=\"hljs-attr\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;ArrowFunctionExpression&quot;</span>,<br>                            <span class=\"hljs-attr\">&quot;id&quot;</span>: <span class=\"hljs-literal\">null</span>,<br>                            <span class=\"hljs-attr\">&quot;generator&quot;</span>: <span class=\"hljs-literal\">false</span>,<br>                            <span class=\"hljs-attr\">&quot;async&quot;</span>: <span class=\"hljs-literal\">false</span>,<br>                            <span class=\"hljs-attr\">&quot;params&quot;</span>: [<br>                                &#123;<br>                                    <span class=\"hljs-attr\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Identifier&quot;</span>,<br>                                    <span class=\"hljs-attr\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;n&quot;</span><br>                                &#125;<br>                            ],<br>                            <span class=\"hljs-attr\">&quot;body&quot;</span>: &#123;<br>                                <span class=\"hljs-attr\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;BinaryExpression&quot;</span>,<br>                                <span class=\"hljs-attr\">&quot;left&quot;</span>: &#123;<br>                                    <span class=\"hljs-attr\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Identifier&quot;</span>,<br>                                    <span class=\"hljs-attr\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;n&quot;</span><br>                                &#125;,<br>                                <span class=\"hljs-attr\">&quot;operator&quot;</span>: <span class=\"hljs-string\">&quot;*&quot;</span>,<br>                                <span class=\"hljs-attr\">&quot;right&quot;</span>: &#123;<br>                                    <span class=\"hljs-attr\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Identifier&quot;</span>,<br>                                    <span class=\"hljs-attr\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;n&quot;</span><br>                                &#125;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                ],<br>                <span class=\"hljs-attr\">&quot;kind&quot;</span>: <span class=\"hljs-string\">&quot;const&quot;</span><br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>每一个代码块都有一个type字段，标识这个代码块的类型，如<code>Program</code>程序、<code>VariableDeclaration</code>变量声明、<code>ArrowFunctionExpression</code>箭头函数、<code>BinaryExpression</code>二项式等，每个代码块的结构不是相同的，比如<code>BinaryExpression</code>的内容是<code>left</code>、<code>right</code>、<code>operator</code>，代表<code>n * n</code>，<code>ArrowFunctionExpression</code>的内容有<code>params</code>、<code>body</code>，代表<code>(...params) =&gt; body</code>。</p>\n<p>看到这，我们已经明白AST是个什么数据结构了</p>\n<ul>\n<li>n叉树。</li>\n<li>每个节点包含至少两种信息，<code>type</code>节点类型、描述该类型所需要的信息（在后面的AST-&gt;code阶段，这些信息足够我们去重新生成代码）。</li>\n</ul>\n<p>笔者最近的工作是开发一个低代码平台，看到这个结构是非常亲切呀，跟我们平台底层配置项的数据结构可太像了，不了解低代码平台的的可以看下<a href=\"https://juejin.cn/post/6925306474524737543\">这里</a>，另外，我有突然想到<a href=\"https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#building_the_dom_tree\">浏览器解析过程</a>会将html文件、css文件解析为DOM树与CSSOM树，这两棵树也可能是AST。</p>\n<p>任何语言都可以被解析成AST，AST是各种语言解析编译运行过程中，都会有的中间产物，那么它是怎么生成的呢？<br><em>注：下面的过程为理论推演过程，跟babel的具体实现不完全相同</em></p>\n<p>两步：<strong>词法解析</strong>、<strong>语法解析</strong></p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b17b20db033642368a0a4d69a2ddd737~tplv-k3u1fbpfcp-watermark.image\" alt=\"lexicalAnalysis\"></p>\n<p>词法解析（lexical analysis），顾名思义，是对单词本义的解析，首先扫描器（scanner）会对代码进行扫描操作，把代码分割成一个个有意义的词（lexemes），如：单词，标点等。<code>const square = n =&gt; n * n;</code>会被分割成<code>[const, squara, =, n, =, &gt;, n, *, n]</code>。这个过程跟这段代码是用什么语言写的没有关系。随后标识器（tokenizer）会对lexemes进行释义，比如：<code>const</code>会被标识为关键字、<code>=, &gt;</code>两个符号会标识为箭头，这个过程就与使用的语言有关了，<code>const</code>在js中会被标识为关键字，但在其他语言中就不一定。最后输出(tokens)为</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[<br>    &#123;<br>        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Keyword&quot;</span>,<br>        <span class=\"hljs-string\">&quot;value&quot;</span>: <span class=\"hljs-string\">&quot;const&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Identifier&quot;</span>,<br>        <span class=\"hljs-string\">&quot;value&quot;</span>: <span class=\"hljs-string\">&quot;square&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Punctuator&quot;</span>,<br>        <span class=\"hljs-string\">&quot;value&quot;</span>: <span class=\"hljs-string\">&quot;=&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Identifier&quot;</span>,<br>        <span class=\"hljs-string\">&quot;value&quot;</span>: <span class=\"hljs-string\">&quot;n&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Punctuator&quot;</span>,<br>        <span class=\"hljs-string\">&quot;value&quot;</span>: <span class=\"hljs-string\">&quot;=&gt;&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Identifier&quot;</span>,<br>        <span class=\"hljs-string\">&quot;value&quot;</span>: <span class=\"hljs-string\">&quot;n&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Punctuator&quot;</span>,<br>        <span class=\"hljs-string\">&quot;value&quot;</span>: <span class=\"hljs-string\">&quot;*&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Identifier&quot;</span>,<br>        <span class=\"hljs-string\">&quot;value&quot;</span>: <span class=\"hljs-string\">&quot;n&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Punctuator&quot;</span>,<br>        <span class=\"hljs-string\">&quot;value&quot;</span>: <span class=\"hljs-string\">&quot;;&quot;</span><br>    &#125;<br>]<br></code></pre></td></tr></table></figure>\n<p>当我们有了tokens，就可以进行语法解析（syntax analysis）了，解析器（parser）会把tokens转换为一棵解析树（parse tree），也可以称之为具体语法树(CST, concrete syntax tree)<br><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04039762baf24be6adbc2fc0c80da617~tplv-k3u1fbpfcp-watermark.image\" alt=\"syntaxTree\"><br>如果仔细看这棵CST，可以看到很多无用信息，比如，有很多节点只有一个子节点，那这种节点完全可以压缩去掉，因为它没有给我们提供额外的有用信息。<br><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bbe883ca20c47bfbe50c741f734d6a3~tplv-k3u1fbpfcp-watermark.image\" alt=\"cstAfterCompress\"><br>压缩后继续来看这棵树，可以发现一些标点符号与操作符可以用n叉树本身的结构就可以代表，所以再来简化一下。<br><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69b9d88e7e824353980fb4455607812e~tplv-k3u1fbpfcp-watermark.image\" alt=\"ast\"><br>得到了最终我们想要的结构，一棵非常抽象（相较于CST）、简化的AST。</p>\n<p>可以在<a href=\"https://esprima.org/demo/parse.html?code=const%20square%20=%20n%20=%3E%20n%20*%20n;%0A\">这个网站</a>，输入随便一段代码，看看对应的tokens与AST。</p>\n<p>得到AST后，我们就可以对AST进行操作，将其转换成我们想要的代码所对应的结构，这部分就是转换, 点击前往⬇️</p>\n<p><a href=\"https://luoluoqinghuan.cn/2021/04/09/howTransformBabelAst/\">Babel原理浅析(二): 手写一个极简插件</a></p>\n<h3 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h3><p><a href=\"https://medium.com/basecs/leveling-up-ones-parsing-game-with-asts-d7a6fc2400ff\">Leveling Up One’s Parsing Game With ASTs</a></p>\n<p><a href=\"https://medium.com/@makk.bit/babel-under-the-hood-63e3fb961243\">Babel under the hood</a></p>\n<p><a href=\"https://www.cnblogs.com/chyingp/p/how-to-write-a-babel-plugin.html\">Babel插件开发入门指南</a></p>\n<p><a href=\"https://lihautan.com/step-by-step-guide-for-writing-a-babel-transformation/\">Step-by-step guide for writing a custom babel transformation</a></p>\n<p><a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md\">Babel 用户手册</a></p>\n","site":{"data":{}},"wordcount":5071,"excerpt":"","more":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>babel可以将ECMAScript2015+的语法，编译成ES5的语法，如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> square = <span class=\"hljs-function\"><span class=\"hljs-params\">n</span> =&gt;</span> n * n;<br></code></pre></td></tr></table></figure>\n<p>转换为</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-meta\">&quot;use strict&quot;</span>;<br><br><span class=\"hljs-keyword\">var</span> square = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">square</span>(<span class=\"hljs-params\">n</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> n * n;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>可以在<a href=\"https://babeljs.io/repl#?browsers=defaults%2C%20not%20ie%2011%2C%20not%20ie_mob%2011&build=&builtIns=false&corejs=3.6&spec=false&loose=false&code_lz=MYewdgzgLgBBCOBXAhgJwKYwLwzNgfLjAFS4DcAUEA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=true&fileSize=true&timeTravel=true&sourceType=module&lineWrap=true&presets=es2015%2Ces2016%2Ces2017&prettier=true&targets=&version=7.16.7&externalPlugins=&assumptions=%7B%7D\">babel repl</a>进行尝试。</p>\n<p><strong>babel是如何做到的呢</strong></p>\n<p>最自然的想法是这样，js代码实际上就是一长串字符串，babel是将一个字符串替换为另一种字符串，那我们写一个字符串替换的程序对这个字符串进行替换似乎就可以做到。</p>\n<p>但如果你下手去写，就会发现无从下手。首先这个替换规则必然非常复杂，正则替换的方式，会让整个正则表达式异常复杂。其次ES6中有一些复杂的语法糖，比如<code>class</code>，如何去实现呢，单纯替换是不好去做的。</p>\n<p>我们可能要借助一些数据结构(AST)去实现这件事。</p>\n<p>babel用了三个运行阶段去做：<strong>解析(parse)<strong>、</strong>转换(transform)<strong>、</strong>生成(generate)</strong></p>\n<p>我们可以在babel源码中调试看一下，先将babel仓库clone到本地，在babel根目录<code>build</code>一下。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">yarn install<br>npm run build<br></code></pre></td></tr></table></figure>\n<p>新建文件test.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> &#123; parse &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;./packages/babel-parser&quot;</span>);<br><span class=\"hljs-keyword\">const</span> traverse = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;./packages/babel-traverse&quot;</span>).default;<br><span class=\"hljs-keyword\">const</span> generate = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;./packages/babel-generator&quot;</span>).default;<br><br><span class=\"hljs-keyword\">const</span> code = <span class=\"hljs-string\">&quot;const square = n =&gt; n * n&quot;</span>;<br><br><span class=\"hljs-comment\">// parse the code -&gt; ast</span><br><span class=\"hljs-keyword\">const</span> ast = parse(code);<br><br><span class=\"hljs-comment\">// transform the ast</span><br>traverse(ast, &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">enter</span>(<span class=\"hljs-params\">path</span>)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (path.node.type !== <span class=\"hljs-string\">&quot;ArrowFunctionExpression&quot;</span>) <span class=\"hljs-keyword\">return</span>;<br><br>    path.arrowFunctionToExpression(&#123;<br>      <span class=\"hljs-attr\">allowInsertArrow</span>: <span class=\"hljs-literal\">false</span>,<br>      <span class=\"hljs-attr\">noNewArrows</span>: <span class=\"hljs-literal\">true</span>,<br>      <span class=\"hljs-attr\">specCompliant</span>: <span class=\"hljs-literal\">false</span>,<br>    &#125;);<br>  &#125;,<br>&#125;);<br><br><span class=\"hljs-comment\">// generate code &lt;- ast</span><br><span class=\"hljs-keyword\">const</span> output = generate(ast, code);<br><span class=\"hljs-built_in\">console</span>.log(output.code);<br><span class=\"hljs-comment\">// const square = function (n) &#123;</span><br><span class=\"hljs-comment\">//     return n * n;</span><br><span class=\"hljs-comment\">//   &#125;;</span><br></code></pre></td></tr></table></figure>\n<p>运行一下这段代码，可以看到在控制台打印出了转换后的代码，<code>parse</code>、<code>traverse</code>、<code>generate</code>分别对应转换过程的三个阶段，下面我尝试讲解下这个三个具体过程。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">code -&gt; AST -&gt; transformed AST -&gt; transformed code<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>解析阶段分为两步，词法分析(lexical analysis)、语法分析(syntax analysis)，最终将一个js文件解析成为一棵抽象语法树(AST)。</p>\n<p>第一个术语出现了，什么是AST，如果你看过《VS CODE权威指南》，可能对这个词会有点印象，AST是一种n叉树表示的数据结构，包含分析源代码的所有必要信息（关键词，变量名，变量值等），是代码的一种抽象表示，方便开发者对代码进行转换操作，编译器可以将代码解析成AST，也可以根据AST重新生成代码，眼见为实，先来用babel的解析器生成一棵AST，这部分代码都在<a href=\"https://github.com/babel/babel/tree/main/packages/babel-parser\">babel/packages/babel-parser</a>中。</p>\n<p>我们在test.js中将ast打印出来</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">console</span>.log(ast)<br></code></pre></td></tr></table></figure>\n<p>可以看到babel解析器输出了AST。它非常的长，我们只有一行函数声明，它对应的AST竟然有近200行。我们去掉一些代码位置信息，分析一下这个精简版AST。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\">&#123;<br>    <span class=\"hljs-attr\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;File&quot;</span>,<br>    <span class=\"hljs-attr\">&quot;program&quot;</span>: &#123;<br>        <span class=\"hljs-attr\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Program&quot;</span>,<br>        <span class=\"hljs-attr\">&quot;sourceType&quot;</span>: <span class=\"hljs-string\">&quot;script&quot;</span>,<br>        <span class=\"hljs-attr\">&quot;body&quot;</span>: [<br>            &#123;<br>                <span class=\"hljs-attr\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;VariableDeclaration&quot;</span>,<br>                <span class=\"hljs-attr\">&quot;declarations&quot;</span>: [<br>                    &#123;<br>                        <span class=\"hljs-attr\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;VariableDeclarator&quot;</span>,<br>                        <span class=\"hljs-attr\">&quot;id&quot;</span>: &#123;<br>                            <span class=\"hljs-attr\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Identifier&quot;</span>,<br>                            <span class=\"hljs-attr\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;square&quot;</span><br>                        &#125;,<br>                        <span class=\"hljs-attr\">&quot;init&quot;</span>: &#123;<br>                            <span class=\"hljs-attr\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;ArrowFunctionExpression&quot;</span>,<br>                            <span class=\"hljs-attr\">&quot;id&quot;</span>: <span class=\"hljs-literal\">null</span>,<br>                            <span class=\"hljs-attr\">&quot;generator&quot;</span>: <span class=\"hljs-literal\">false</span>,<br>                            <span class=\"hljs-attr\">&quot;async&quot;</span>: <span class=\"hljs-literal\">false</span>,<br>                            <span class=\"hljs-attr\">&quot;params&quot;</span>: [<br>                                &#123;<br>                                    <span class=\"hljs-attr\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Identifier&quot;</span>,<br>                                    <span class=\"hljs-attr\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;n&quot;</span><br>                                &#125;<br>                            ],<br>                            <span class=\"hljs-attr\">&quot;body&quot;</span>: &#123;<br>                                <span class=\"hljs-attr\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;BinaryExpression&quot;</span>,<br>                                <span class=\"hljs-attr\">&quot;left&quot;</span>: &#123;<br>                                    <span class=\"hljs-attr\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Identifier&quot;</span>,<br>                                    <span class=\"hljs-attr\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;n&quot;</span><br>                                &#125;,<br>                                <span class=\"hljs-attr\">&quot;operator&quot;</span>: <span class=\"hljs-string\">&quot;*&quot;</span>,<br>                                <span class=\"hljs-attr\">&quot;right&quot;</span>: &#123;<br>                                    <span class=\"hljs-attr\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Identifier&quot;</span>,<br>                                    <span class=\"hljs-attr\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;n&quot;</span><br>                                &#125;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                ],<br>                <span class=\"hljs-attr\">&quot;kind&quot;</span>: <span class=\"hljs-string\">&quot;const&quot;</span><br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>每一个代码块都有一个type字段，标识这个代码块的类型，如<code>Program</code>程序、<code>VariableDeclaration</code>变量声明、<code>ArrowFunctionExpression</code>箭头函数、<code>BinaryExpression</code>二项式等，每个代码块的结构不是相同的，比如<code>BinaryExpression</code>的内容是<code>left</code>、<code>right</code>、<code>operator</code>，代表<code>n * n</code>，<code>ArrowFunctionExpression</code>的内容有<code>params</code>、<code>body</code>，代表<code>(...params) =&gt; body</code>。</p>\n<p>看到这，我们已经明白AST是个什么数据结构了</p>\n<ul>\n<li>n叉树。</li>\n<li>每个节点包含至少两种信息，<code>type</code>节点类型、描述该类型所需要的信息（在后面的AST-&gt;code阶段，这些信息足够我们去重新生成代码）。</li>\n</ul>\n<p>笔者最近的工作是开发一个低代码平台，看到这个结构是非常亲切呀，跟我们平台底层配置项的数据结构可太像了，不了解低代码平台的的可以看下<a href=\"https://juejin.cn/post/6925306474524737543\">这里</a>，另外，我有突然想到<a href=\"https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work#building_the_dom_tree\">浏览器解析过程</a>会将html文件、css文件解析为DOM树与CSSOM树，这两棵树也可能是AST。</p>\n<p>任何语言都可以被解析成AST，AST是各种语言解析编译运行过程中，都会有的中间产物，那么它是怎么生成的呢？<br><em>注：下面的过程为理论推演过程，跟babel的具体实现不完全相同</em></p>\n<p>两步：<strong>词法解析</strong>、<strong>语法解析</strong></p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b17b20db033642368a0a4d69a2ddd737~tplv-k3u1fbpfcp-watermark.image\" alt=\"lexicalAnalysis\"></p>\n<p>词法解析（lexical analysis），顾名思义，是对单词本义的解析，首先扫描器（scanner）会对代码进行扫描操作，把代码分割成一个个有意义的词（lexemes），如：单词，标点等。<code>const square = n =&gt; n * n;</code>会被分割成<code>[const, squara, =, n, =, &gt;, n, *, n]</code>。这个过程跟这段代码是用什么语言写的没有关系。随后标识器（tokenizer）会对lexemes进行释义，比如：<code>const</code>会被标识为关键字、<code>=, &gt;</code>两个符号会标识为箭头，这个过程就与使用的语言有关了，<code>const</code>在js中会被标识为关键字，但在其他语言中就不一定。最后输出(tokens)为</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[<br>    &#123;<br>        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Keyword&quot;</span>,<br>        <span class=\"hljs-string\">&quot;value&quot;</span>: <span class=\"hljs-string\">&quot;const&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Identifier&quot;</span>,<br>        <span class=\"hljs-string\">&quot;value&quot;</span>: <span class=\"hljs-string\">&quot;square&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Punctuator&quot;</span>,<br>        <span class=\"hljs-string\">&quot;value&quot;</span>: <span class=\"hljs-string\">&quot;=&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Identifier&quot;</span>,<br>        <span class=\"hljs-string\">&quot;value&quot;</span>: <span class=\"hljs-string\">&quot;n&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Punctuator&quot;</span>,<br>        <span class=\"hljs-string\">&quot;value&quot;</span>: <span class=\"hljs-string\">&quot;=&gt;&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Identifier&quot;</span>,<br>        <span class=\"hljs-string\">&quot;value&quot;</span>: <span class=\"hljs-string\">&quot;n&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Punctuator&quot;</span>,<br>        <span class=\"hljs-string\">&quot;value&quot;</span>: <span class=\"hljs-string\">&quot;*&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Identifier&quot;</span>,<br>        <span class=\"hljs-string\">&quot;value&quot;</span>: <span class=\"hljs-string\">&quot;n&quot;</span><br>    &#125;,<br>    &#123;<br>        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;Punctuator&quot;</span>,<br>        <span class=\"hljs-string\">&quot;value&quot;</span>: <span class=\"hljs-string\">&quot;;&quot;</span><br>    &#125;<br>]<br></code></pre></td></tr></table></figure>\n<p>当我们有了tokens，就可以进行语法解析（syntax analysis）了，解析器（parser）会把tokens转换为一棵解析树（parse tree），也可以称之为具体语法树(CST, concrete syntax tree)<br><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04039762baf24be6adbc2fc0c80da617~tplv-k3u1fbpfcp-watermark.image\" alt=\"syntaxTree\"><br>如果仔细看这棵CST，可以看到很多无用信息，比如，有很多节点只有一个子节点，那这种节点完全可以压缩去掉，因为它没有给我们提供额外的有用信息。<br><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bbe883ca20c47bfbe50c741f734d6a3~tplv-k3u1fbpfcp-watermark.image\" alt=\"cstAfterCompress\"><br>压缩后继续来看这棵树，可以发现一些标点符号与操作符可以用n叉树本身的结构就可以代表，所以再来简化一下。<br><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69b9d88e7e824353980fb4455607812e~tplv-k3u1fbpfcp-watermark.image\" alt=\"ast\"><br>得到了最终我们想要的结构，一棵非常抽象（相较于CST）、简化的AST。</p>\n<p>可以在<a href=\"https://esprima.org/demo/parse.html?code=const%20square%20=%20n%20=%3E%20n%20*%20n;%0A\">这个网站</a>，输入随便一段代码，看看对应的tokens与AST。</p>\n<p>得到AST后，我们就可以对AST进行操作，将其转换成我们想要的代码所对应的结构，这部分就是转换, 点击前往⬇️</p>\n<p><a href=\"https://luoluoqinghuan.cn/2021/04/09/howTransformBabelAst/\">Babel原理浅析(二): 手写一个极简插件</a></p>\n<h3 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h3><p><a href=\"https://medium.com/basecs/leveling-up-ones-parsing-game-with-asts-d7a6fc2400ff\">Leveling Up One’s Parsing Game With ASTs</a></p>\n<p><a href=\"https://medium.com/@makk.bit/babel-under-the-hood-63e3fb961243\">Babel under the hood</a></p>\n<p><a href=\"https://www.cnblogs.com/chyingp/p/how-to-write-a-babel-plugin.html\">Babel插件开发入门指南</a></p>\n<p><a href=\"https://lihautan.com/step-by-step-guide-for-writing-a-babel-transformation/\">Step-by-step guide for writing a custom babel transformation</a></p>\n<p><a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md\">Babel 用户手册</a></p>\n"},{"title":"promise详解(promise.all实现、promise.race实现)","date":"2020-03-10T15:08:45.000Z","index_img":"/img/blogCovers/blog-post1.jpg","_content":"## promise解决了什么问题\nJavaScript是单线程的，所以我们要用一些异步编程方案来实现异步。\n回调函数就是其中的一种方案，比如说在node中写读取一个文件，使用回调函数这是没有问题的。\n\n```javascript\nfs.readFile('/etc/passwd', function (err, data) {\n  if (err) throw err;\n  console.log(data);\n});\n```\n但如果新的需求是必须先读取A文件，才能读取B文件\n\n```javascript\nfs.readFile(fileA, function (err, data) {\n\tfs.readFile(fileB, function (err, data) {\t\n  \t\t//...\n  \t\t})\n});\n```\n不难想象，如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为\"回调地狱\"（callback hell）。\n而`promise`就是为了解决这个问题而生的\n## 什么是promise\n它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载，改成纵向加载。采用Promise，连续读取多个文件，写法如下。\n\n```javascript\nvar readFile = require('fs-readfile-promise');\nreadFile(fileA)//读取文件A\n.then(function(data){//如果读取成功则执行该函数，打印数据\n  console.log(data.toString());\n}).then(function(){//如果打印成功，则开始读取文件B\n  return readFile(fileB);\n}).then(function(data){//如果文件B读取成功，则打印文件B的数据\n  console.log(data.toString());\n}).catch(function(err) {//过程中发生任何错误则捕获，打印该错误\n  console.log(err);\n});\n```\n上面代码中，我使用了 `fs-readfile-promise` 模块，它的作用就是返回一个 Promise 版本的 `readFile` 函数。Promise 提供 `then` 方法加载回调函数，`catch`方法捕捉执行过程中抛出的错误。看起来清爽多了\n再来看一段伪代码\n\n```javascript\n//传统写法（层层嵌套，可读性差）：\nstep1(function (value1) { \n  step2(value1, function(value2) { \n    step3(value2, function(value3) { \n      step4(value3, function(value4) { // ... });\n     }); \n  });\n});\n\n//Promises的写法（清晰舒服）：\n(new Promise(step1))\n  .then(step2)\n  .then(step3)\n  .catch(step4);\n```\npromise对象，充当异步操作与回调函数之间的中介，将异步编程大大简化了。\n\n\n### Promise 的状态\n\n等待（`pending`）：初始状态。\n已完成（`fulfilled`）：意味着操作成功完成。\n已失败（`rejected`）：意味着操作失败。\n\nPromise对象的状态只可能处于这三种之一，它的状态改变只可能是两种可能：从 Pending 变为 `fulfilled` 和从 `Pending` 变为 `Rejected`。一旦状态发生改变，就不会再变，这也是`Promise[承诺]`这个名字的由来。\n### promise的使用\n再来看一个简单的例子\n```javascript\nfunction getNumber(num){\n  return new Promise(function(resolve,reject){//返回一个promise对象\n      if(num > 5){\n        resolve(num)//如果数字大于5则，执行resolve\n      }else{\n        reject('数字太小')}//否则执行reject\n  })\n}\nfunction printData(data){\n    console.log('resolve');\n    console.log(data);\n  }\nfunction printError(data){\n\tconsole.log('reject');\n    console.log(data);\n}\ngetNumber(4).then(printData).catch(printError);//reject 4\ngetNumber(6).then(printData).catch(printError);//resolve 6\n```\n当`promise`执行了`resolve`语句（模拟异步操作执行成功），那么`promise`的状态就回变为`resolve`，可以使用`then`方法，调用传入的回调函数，而回调函数的参数就是`resolve`中返回的数据。\n\n相反\n\npromise执行了`reject`语句（模拟异步操作执行失败），那么promise的状态就回变为`reject`，可以使用`catch`方法，调用传入的回调函数，而回调函数的参数就是reject中返回的数据。\n\n### promise的其他方法\n#### promise.all\n`Promise.all(iterable)` 方法返回一个 `Promise` 实例，此实例在 `iterable` 参数内所有的 `promise` 都“`完成（resolved）`”或参数中不包含 `promise` 时回调`完成（resolve）`；如果参数中  `promise` 有一个`失败（rejected）`，此实例回调`失败（reject）`，失败原因的是第一个失败 `promise` 的结果\n\n将两个promise对象拼成一个数组传进`all`方法。看有没有失败，有一个失败的，则整个`all`方法产生的promise对象失败。\n\n只要有一个失败了，这个promise就失败，结果为第一个失败的结果。如果都成了，就返回全部成功的结果。\n\n```javascript\nconst p1 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve('hello');\n}, 1000);\n})\nconst p2 = new Promise((resolve, reject) => {\n    resolve(1);\n  })\n Promise.all([p1,p2]).then(//传入的是两个promise对象\n    result=>console.log(result)\n  ).catch(\n    e=>console.log(e)        \n  )// Array(2) [\"hello\", 1]\n```\n将因为两个`promise`对象的状态都是已完成，所以返回的是数组，包含着两个`promise`的回调参数\n在看另外一个例子\n\n```javascript\nconst p1 = new Promise((resolve, reject) => {\n        resolve('第一个任务');\n})\nconst p2 = new Promise((resolve,reject) =>{\n    setTimeout(() => {\n        reject('第二个任务')\n    }, 1000);\n})\nconst p3 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        reject('第三个任务');    \n    }, 500);\n  })\nPromise.all([p1,p2,p3]).then(\n    result=>console.log(result)\n  ).catch(\n    e=>console.log(e)        \n  )//第三个任务\n```\n执行结果打印的是第三个任务，细品这段代码就能明白`Promise.all`干的是啥了\n#### `promise.all`的实现\n\n```javascript\n/** 仅考虑 promises 传入的是数组的情况时 */\nPromise.all = function (promise) {\n\tlet promises = Array.from(promise)//将iterator转换为数组\n    return new Promise((resolve, reject) => {\n        if (promises.length === 0) {//如果数组长度为0则返回空数组\n            resolve([]);\n        } else {\n            let result = [];//存放已成功的异步操作\n            let index = 0;//记录已成功的操作数\n            for (let i = 0;  i < promises.length; i++ ) {\n                Promise.resolve(promises[i])//执行每一个promise\n                \t.then(data => {\n                    \tresult[i] = data;\n                    \tif (++index === promises.length) {\n                        //所有的 promises 状态都是 fulfilled，promise.all返回的实例才变成 fulfilled 态\n                       \t resolve(result);\n                    }\n                }, err => {\n                    reject(err);\n                    return;\n                });\n            }\n        }\n    });\n}\n```\n#### `Promise.race()`\n`Promise.race(iterable)` 方法返回一个 `promise`，一旦迭代器中的某个`promise`解决或拒绝，返回的 `promise`就会解决或拒绝\n举个例子\n\n```javascript\nconst p1 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n         resolve('第一个任务');\n    }, 200);\n})\nconst p2 = new Promise((resolve,reject) =>{\n    setTimeout(() => {\n        reject('第二个任务')\n    }, 1000);\n})\nconst p3 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve('第三个任务');    \n    }, 500);\n  })\nPromise.all([p1,p2,p3]).then(\n    result=>console.log(result)\n  ).catch(\n    e=>console.log(e)        \n  )//第一个任务\n```\n只要其中一个实例先改变状态，状态就跟着改变将率先改变的`Promise`返回值传递给回调函数，大白话：看谁快\n#### `Promise.race()`实现\n\n```javascript\nvar race = function(promise) {\n\tlet promises = Array.from(promise)\n    return new Promise(function(resolve, reject) {\n        for (var i = 0; i < promises.length; i++) {\n       \t\t Promise.resolve(promises[i]).then(data => {\n\t\t\t\tresolve(data);\n       \t\t\t }, err => {\n          \t\t\treturn reject(err)\n        })\n      }\n    })\n  }\n```\n#### `Promise.resolve()`和`Promise.reject()`\n\n```javascript\n// Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected\nconst p = Promise.reject('出错了');\n// 等同于\nconst p = new Promise((resolve, reject) => reject('出错了'))\n\np.then(null, function (s) {\n  console.log(s)      // 出错了\n});\n```\n\n```javascript\nPromise.resolve('foo')\n// 等价于\nnew Promise(resolve => resolve('foo'))\n```\n","source":"_posts/promise详解.md","raw":"---\ntitle: promise详解(promise.all实现、promise.race实现)\ndate: 2020-03-10 23:08:45\ntags: [JavaScript, 异步编程]\nindex_img: /img/blogCovers/blog-post1.jpg\ncategories: [学习笔记]\n---\n## promise解决了什么问题\nJavaScript是单线程的，所以我们要用一些异步编程方案来实现异步。\n回调函数就是其中的一种方案，比如说在node中写读取一个文件，使用回调函数这是没有问题的。\n\n```javascript\nfs.readFile('/etc/passwd', function (err, data) {\n  if (err) throw err;\n  console.log(data);\n});\n```\n但如果新的需求是必须先读取A文件，才能读取B文件\n\n```javascript\nfs.readFile(fileA, function (err, data) {\n\tfs.readFile(fileB, function (err, data) {\t\n  \t\t//...\n  \t\t})\n});\n```\n不难想象，如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为\"回调地狱\"（callback hell）。\n而`promise`就是为了解决这个问题而生的\n## 什么是promise\n它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载，改成纵向加载。采用Promise，连续读取多个文件，写法如下。\n\n```javascript\nvar readFile = require('fs-readfile-promise');\nreadFile(fileA)//读取文件A\n.then(function(data){//如果读取成功则执行该函数，打印数据\n  console.log(data.toString());\n}).then(function(){//如果打印成功，则开始读取文件B\n  return readFile(fileB);\n}).then(function(data){//如果文件B读取成功，则打印文件B的数据\n  console.log(data.toString());\n}).catch(function(err) {//过程中发生任何错误则捕获，打印该错误\n  console.log(err);\n});\n```\n上面代码中，我使用了 `fs-readfile-promise` 模块，它的作用就是返回一个 Promise 版本的 `readFile` 函数。Promise 提供 `then` 方法加载回调函数，`catch`方法捕捉执行过程中抛出的错误。看起来清爽多了\n再来看一段伪代码\n\n```javascript\n//传统写法（层层嵌套，可读性差）：\nstep1(function (value1) { \n  step2(value1, function(value2) { \n    step3(value2, function(value3) { \n      step4(value3, function(value4) { // ... });\n     }); \n  });\n});\n\n//Promises的写法（清晰舒服）：\n(new Promise(step1))\n  .then(step2)\n  .then(step3)\n  .catch(step4);\n```\npromise对象，充当异步操作与回调函数之间的中介，将异步编程大大简化了。\n\n\n### Promise 的状态\n\n等待（`pending`）：初始状态。\n已完成（`fulfilled`）：意味着操作成功完成。\n已失败（`rejected`）：意味着操作失败。\n\nPromise对象的状态只可能处于这三种之一，它的状态改变只可能是两种可能：从 Pending 变为 `fulfilled` 和从 `Pending` 变为 `Rejected`。一旦状态发生改变，就不会再变，这也是`Promise[承诺]`这个名字的由来。\n### promise的使用\n再来看一个简单的例子\n```javascript\nfunction getNumber(num){\n  return new Promise(function(resolve,reject){//返回一个promise对象\n      if(num > 5){\n        resolve(num)//如果数字大于5则，执行resolve\n      }else{\n        reject('数字太小')}//否则执行reject\n  })\n}\nfunction printData(data){\n    console.log('resolve');\n    console.log(data);\n  }\nfunction printError(data){\n\tconsole.log('reject');\n    console.log(data);\n}\ngetNumber(4).then(printData).catch(printError);//reject 4\ngetNumber(6).then(printData).catch(printError);//resolve 6\n```\n当`promise`执行了`resolve`语句（模拟异步操作执行成功），那么`promise`的状态就回变为`resolve`，可以使用`then`方法，调用传入的回调函数，而回调函数的参数就是`resolve`中返回的数据。\n\n相反\n\npromise执行了`reject`语句（模拟异步操作执行失败），那么promise的状态就回变为`reject`，可以使用`catch`方法，调用传入的回调函数，而回调函数的参数就是reject中返回的数据。\n\n### promise的其他方法\n#### promise.all\n`Promise.all(iterable)` 方法返回一个 `Promise` 实例，此实例在 `iterable` 参数内所有的 `promise` 都“`完成（resolved）`”或参数中不包含 `promise` 时回调`完成（resolve）`；如果参数中  `promise` 有一个`失败（rejected）`，此实例回调`失败（reject）`，失败原因的是第一个失败 `promise` 的结果\n\n将两个promise对象拼成一个数组传进`all`方法。看有没有失败，有一个失败的，则整个`all`方法产生的promise对象失败。\n\n只要有一个失败了，这个promise就失败，结果为第一个失败的结果。如果都成了，就返回全部成功的结果。\n\n```javascript\nconst p1 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve('hello');\n}, 1000);\n})\nconst p2 = new Promise((resolve, reject) => {\n    resolve(1);\n  })\n Promise.all([p1,p2]).then(//传入的是两个promise对象\n    result=>console.log(result)\n  ).catch(\n    e=>console.log(e)        \n  )// Array(2) [\"hello\", 1]\n```\n将因为两个`promise`对象的状态都是已完成，所以返回的是数组，包含着两个`promise`的回调参数\n在看另外一个例子\n\n```javascript\nconst p1 = new Promise((resolve, reject) => {\n        resolve('第一个任务');\n})\nconst p2 = new Promise((resolve,reject) =>{\n    setTimeout(() => {\n        reject('第二个任务')\n    }, 1000);\n})\nconst p3 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        reject('第三个任务');    \n    }, 500);\n  })\nPromise.all([p1,p2,p3]).then(\n    result=>console.log(result)\n  ).catch(\n    e=>console.log(e)        \n  )//第三个任务\n```\n执行结果打印的是第三个任务，细品这段代码就能明白`Promise.all`干的是啥了\n#### `promise.all`的实现\n\n```javascript\n/** 仅考虑 promises 传入的是数组的情况时 */\nPromise.all = function (promise) {\n\tlet promises = Array.from(promise)//将iterator转换为数组\n    return new Promise((resolve, reject) => {\n        if (promises.length === 0) {//如果数组长度为0则返回空数组\n            resolve([]);\n        } else {\n            let result = [];//存放已成功的异步操作\n            let index = 0;//记录已成功的操作数\n            for (let i = 0;  i < promises.length; i++ ) {\n                Promise.resolve(promises[i])//执行每一个promise\n                \t.then(data => {\n                    \tresult[i] = data;\n                    \tif (++index === promises.length) {\n                        //所有的 promises 状态都是 fulfilled，promise.all返回的实例才变成 fulfilled 态\n                       \t resolve(result);\n                    }\n                }, err => {\n                    reject(err);\n                    return;\n                });\n            }\n        }\n    });\n}\n```\n#### `Promise.race()`\n`Promise.race(iterable)` 方法返回一个 `promise`，一旦迭代器中的某个`promise`解决或拒绝，返回的 `promise`就会解决或拒绝\n举个例子\n\n```javascript\nconst p1 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n         resolve('第一个任务');\n    }, 200);\n})\nconst p2 = new Promise((resolve,reject) =>{\n    setTimeout(() => {\n        reject('第二个任务')\n    }, 1000);\n})\nconst p3 = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve('第三个任务');    \n    }, 500);\n  })\nPromise.all([p1,p2,p3]).then(\n    result=>console.log(result)\n  ).catch(\n    e=>console.log(e)        \n  )//第一个任务\n```\n只要其中一个实例先改变状态，状态就跟着改变将率先改变的`Promise`返回值传递给回调函数，大白话：看谁快\n#### `Promise.race()`实现\n\n```javascript\nvar race = function(promise) {\n\tlet promises = Array.from(promise)\n    return new Promise(function(resolve, reject) {\n        for (var i = 0; i < promises.length; i++) {\n       \t\t Promise.resolve(promises[i]).then(data => {\n\t\t\t\tresolve(data);\n       \t\t\t }, err => {\n          \t\t\treturn reject(err)\n        })\n      }\n    })\n  }\n```\n#### `Promise.resolve()`和`Promise.reject()`\n\n```javascript\n// Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected\nconst p = Promise.reject('出错了');\n// 等同于\nconst p = new Promise((resolve, reject) => reject('出错了'))\n\np.then(null, function (s) {\n  console.log(s)      // 出错了\n});\n```\n\n```javascript\nPromise.resolve('foo')\n// 等价于\nnew Promise(resolve => resolve('foo'))\n```\n","slug":"promise详解","published":1,"updated":"2022-01-10T08:41:39.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckyo4lu6o0008nz696ewge9pz","content":"<h2 id=\"promise解决了什么问题\"><a href=\"#promise解决了什么问题\" class=\"headerlink\" title=\"promise解决了什么问题\"></a>promise解决了什么问题</h2><p>JavaScript是单线程的，所以我们要用一些异步编程方案来实现异步。<br>回调函数就是其中的一种方案，比如说在node中写读取一个文件，使用回调函数这是没有问题的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">fs.readFile(<span class=\"hljs-string\">&#x27;/etc/passwd&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, data</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;<br>  <span class=\"hljs-built_in\">console</span>.log(data);<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>但如果新的需求是必须先读取A文件，才能读取B文件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">fs.readFile(fileA, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, data</span>) </span>&#123;<br>\tfs.readFile(fileB, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, data</span>) </span>&#123;\t<br>  \t\t<span class=\"hljs-comment\">//...</span><br>  \t\t&#125;)<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>不难想象，如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为”回调地狱”（callback hell）。<br>而<code>promise</code>就是为了解决这个问题而生的</p>\n<h2 id=\"什么是promise\"><a href=\"#什么是promise\" class=\"headerlink\" title=\"什么是promise\"></a>什么是promise</h2><p>它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载，改成纵向加载。采用Promise，连续读取多个文件，写法如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> readFile = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;fs-readfile-promise&#x27;</span>);<br>readFile(fileA)<span class=\"hljs-comment\">//读取文件A</span><br>.then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data</span>)</span>&#123;<span class=\"hljs-comment\">//如果读取成功则执行该函数，打印数据</span><br>  <span class=\"hljs-built_in\">console</span>.log(data.toString());<br>&#125;).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<span class=\"hljs-comment\">//如果打印成功，则开始读取文件B</span><br>  <span class=\"hljs-keyword\">return</span> readFile(fileB);<br>&#125;).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data</span>)</span>&#123;<span class=\"hljs-comment\">//如果文件B读取成功，则打印文件B的数据</span><br>  <span class=\"hljs-built_in\">console</span>.log(data.toString());<br>&#125;).catch(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>) </span>&#123;<span class=\"hljs-comment\">//过程中发生任何错误则捕获，打印该错误</span><br>  <span class=\"hljs-built_in\">console</span>.log(err);<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>上面代码中，我使用了 <code>fs-readfile-promise</code> 模块，它的作用就是返回一个 Promise 版本的 <code>readFile</code> 函数。Promise 提供 <code>then</code> 方法加载回调函数，<code>catch</code>方法捕捉执行过程中抛出的错误。看起来清爽多了<br>再来看一段伪代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//传统写法（层层嵌套，可读性差）：</span><br>step1(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value1</span>) </span>&#123; <br>  step2(value1, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value2</span>) </span>&#123; <br>    step3(value2, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value3</span>) </span>&#123; <br>      step4(value3, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value4</span>) </span>&#123; <span class=\"hljs-comment\">// ... &#125;);</span><br>     &#125;); <br>  &#125;);<br>&#125;);<br><br><span class=\"hljs-comment\">//Promises的写法（清晰舒服）：</span><br>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(step1))<br>  .then(step2)<br>  .then(step3)<br>  .catch(step4);<br></code></pre></td></tr></table></figure>\n<p>promise对象，充当异步操作与回调函数之间的中介，将异步编程大大简化了。</p>\n<h3 id=\"Promise-的状态\"><a href=\"#Promise-的状态\" class=\"headerlink\" title=\"Promise 的状态\"></a>Promise 的状态</h3><p>等待（<code>pending</code>）：初始状态。<br>已完成（<code>fulfilled</code>）：意味着操作成功完成。<br>已失败（<code>rejected</code>）：意味着操作失败。</p>\n<p>Promise对象的状态只可能处于这三种之一，它的状态改变只可能是两种可能：从 Pending 变为 <code>fulfilled</code> 和从 <code>Pending</code> 变为 <code>Rejected</code>。一旦状态发生改变，就不会再变，这也是<code>Promise[承诺]</code>这个名字的由来。</p>\n<h3 id=\"promise的使用\"><a href=\"#promise的使用\" class=\"headerlink\" title=\"promise的使用\"></a>promise的使用</h3><p>再来看一个简单的例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getNumber</span>(<span class=\"hljs-params\">num</span>)</span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve,reject</span>)</span>&#123;<span class=\"hljs-comment\">//返回一个promise对象</span><br>      <span class=\"hljs-keyword\">if</span>(num &gt; <span class=\"hljs-number\">5</span>)&#123;<br>        resolve(num)<span class=\"hljs-comment\">//如果数字大于5则，执行resolve</span><br>      &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        reject(<span class=\"hljs-string\">&#x27;数字太小&#x27;</span>)&#125;<span class=\"hljs-comment\">//否则执行reject</span><br>  &#125;)<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">printData</span>(<span class=\"hljs-params\">data</span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;resolve&#x27;</span>);<br>    <span class=\"hljs-built_in\">console</span>.log(data);<br>  &#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">printError</span>(<span class=\"hljs-params\">data</span>)</span>&#123;<br>\t<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;reject&#x27;</span>);<br>    <span class=\"hljs-built_in\">console</span>.log(data);<br>&#125;<br>getNumber(<span class=\"hljs-number\">4</span>).then(printData).catch(printError);<span class=\"hljs-comment\">//reject 4</span><br>getNumber(<span class=\"hljs-number\">6</span>).then(printData).catch(printError);<span class=\"hljs-comment\">//resolve 6</span><br></code></pre></td></tr></table></figure>\n<p>当<code>promise</code>执行了<code>resolve</code>语句（模拟异步操作执行成功），那么<code>promise</code>的状态就回变为<code>resolve</code>，可以使用<code>then</code>方法，调用传入的回调函数，而回调函数的参数就是<code>resolve</code>中返回的数据。</p>\n<p>相反</p>\n<p>promise执行了<code>reject</code>语句（模拟异步操作执行失败），那么promise的状态就回变为<code>reject</code>，可以使用<code>catch</code>方法，调用传入的回调函数，而回调函数的参数就是reject中返回的数据。</p>\n<h3 id=\"promise的其他方法\"><a href=\"#promise的其他方法\" class=\"headerlink\" title=\"promise的其他方法\"></a>promise的其他方法</h3><h4 id=\"promise-all\"><a href=\"#promise-all\" class=\"headerlink\" title=\"promise.all\"></a>promise.all</h4><p><code>Promise.all(iterable)</code> 方法返回一个 <code>Promise</code> 实例，此实例在 <code>iterable</code> 参数内所有的 <code>promise</code> 都“<code>完成（resolved）</code>”或参数中不包含 <code>promise</code> 时回调<code>完成（resolve）</code>；如果参数中  <code>promise</code> 有一个<code>失败（rejected）</code>，此实例回调<code>失败（reject）</code>，失败原因的是第一个失败 <code>promise</code> 的结果</p>\n<p>将两个promise对象拼成一个数组传进<code>all</code>方法。看有没有失败，有一个失败的，则整个<code>all</code>方法产生的promise对象失败。</p>\n<p>只要有一个失败了，这个promise就失败，结果为第一个失败的结果。如果都成了，就返回全部成功的结果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        resolve(<span class=\"hljs-string\">&#x27;hello&#x27;</span>);<br>&#125;, <span class=\"hljs-number\">1000</span>);<br>&#125;)<br><span class=\"hljs-keyword\">const</span> p2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>    resolve(<span class=\"hljs-number\">1</span>);<br>  &#125;)<br> <span class=\"hljs-built_in\">Promise</span>.all([p1,p2]).then(<span class=\"hljs-comment\">//传入的是两个promise对象</span><br>    <span class=\"hljs-function\"><span class=\"hljs-params\">result</span>=&gt;</span><span class=\"hljs-built_in\">console</span>.log(result)<br>  ).catch(<br>    <span class=\"hljs-function\"><span class=\"hljs-params\">e</span>=&gt;</span><span class=\"hljs-built_in\">console</span>.log(e)        <br>  )<span class=\"hljs-comment\">// Array(2) [&quot;hello&quot;, 1]</span><br></code></pre></td></tr></table></figure>\n<p>将因为两个<code>promise</code>对象的状态都是已完成，所以返回的是数组，包含着两个<code>promise</code>的回调参数<br>在看另外一个例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>        resolve(<span class=\"hljs-string\">&#x27;第一个任务&#x27;</span>);<br>&#125;)<br><span class=\"hljs-keyword\">const</span> p2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve,reject</span>) =&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        reject(<span class=\"hljs-string\">&#x27;第二个任务&#x27;</span>)<br>    &#125;, <span class=\"hljs-number\">1000</span>);<br>&#125;)<br><span class=\"hljs-keyword\">const</span> p3 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        reject(<span class=\"hljs-string\">&#x27;第三个任务&#x27;</span>);    <br>    &#125;, <span class=\"hljs-number\">500</span>);<br>  &#125;)<br><span class=\"hljs-built_in\">Promise</span>.all([p1,p2,p3]).then(<br>    <span class=\"hljs-function\"><span class=\"hljs-params\">result</span>=&gt;</span><span class=\"hljs-built_in\">console</span>.log(result)<br>  ).catch(<br>    <span class=\"hljs-function\"><span class=\"hljs-params\">e</span>=&gt;</span><span class=\"hljs-built_in\">console</span>.log(e)        <br>  )<span class=\"hljs-comment\">//第三个任务</span><br></code></pre></td></tr></table></figure>\n<p>执行结果打印的是第三个任务，细品这段代码就能明白<code>Promise.all</code>干的是啥了</p>\n<h4 id=\"promise-all的实现\"><a href=\"#promise-all的实现\" class=\"headerlink\" title=\"promise.all的实现\"></a><code>promise.all</code>的实现</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/** 仅考虑 promises 传入的是数组的情况时 */</span><br><span class=\"hljs-built_in\">Promise</span>.all = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">promise</span>) </span>&#123;<br>\t<span class=\"hljs-keyword\">let</span> promises = <span class=\"hljs-built_in\">Array</span>.from(promise)<span class=\"hljs-comment\">//将iterator转换为数组</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (promises.length === <span class=\"hljs-number\">0</span>) &#123;<span class=\"hljs-comment\">//如果数组长度为0则返回空数组</span><br>            resolve([]);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">let</span> result = [];<span class=\"hljs-comment\">//存放已成功的异步操作</span><br>            <span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//记录已成功的操作数</span><br>            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>;  i &lt; promises.length; i++ ) &#123;<br>                <span class=\"hljs-built_in\">Promise</span>.resolve(promises[i])<span class=\"hljs-comment\">//执行每一个promise</span><br>                \t.then(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> &#123;<br>                    \tresult[i] = data;<br>                    \t<span class=\"hljs-keyword\">if</span> (++index === promises.length) &#123;<br>                        <span class=\"hljs-comment\">//所有的 promises 状态都是 fulfilled，promise.all返回的实例才变成 fulfilled 态</span><br>                       \t resolve(result);<br>                    &#125;<br>                &#125;, <span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> &#123;<br>                    reject(err);<br>                    <span class=\"hljs-keyword\">return</span>;<br>                &#125;);<br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a><code>Promise.race()</code></h4><p><code>Promise.race(iterable)</code> 方法返回一个 <code>promise</code>，一旦迭代器中的某个<code>promise</code>解决或拒绝，返回的 <code>promise</code>就会解决或拒绝<br>举个例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>         resolve(<span class=\"hljs-string\">&#x27;第一个任务&#x27;</span>);<br>    &#125;, <span class=\"hljs-number\">200</span>);<br>&#125;)<br><span class=\"hljs-keyword\">const</span> p2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve,reject</span>) =&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        reject(<span class=\"hljs-string\">&#x27;第二个任务&#x27;</span>)<br>    &#125;, <span class=\"hljs-number\">1000</span>);<br>&#125;)<br><span class=\"hljs-keyword\">const</span> p3 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        resolve(<span class=\"hljs-string\">&#x27;第三个任务&#x27;</span>);    <br>    &#125;, <span class=\"hljs-number\">500</span>);<br>  &#125;)<br><span class=\"hljs-built_in\">Promise</span>.all([p1,p2,p3]).then(<br>    <span class=\"hljs-function\"><span class=\"hljs-params\">result</span>=&gt;</span><span class=\"hljs-built_in\">console</span>.log(result)<br>  ).catch(<br>    <span class=\"hljs-function\"><span class=\"hljs-params\">e</span>=&gt;</span><span class=\"hljs-built_in\">console</span>.log(e)        <br>  )<span class=\"hljs-comment\">//第一个任务</span><br></code></pre></td></tr></table></figure>\n<p>只要其中一个实例先改变状态，状态就跟着改变将率先改变的<code>Promise</code>返回值传递给回调函数，大白话：看谁快</p>\n<h4 id=\"Promise-race-实现\"><a href=\"#Promise-race-实现\" class=\"headerlink\" title=\"Promise.race()实现\"></a><code>Promise.race()</code>实现</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> race = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">promise</span>) </span>&#123;<br>\t<span class=\"hljs-keyword\">let</span> promises = <span class=\"hljs-built_in\">Array</span>.from(promise)<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; promises.length; i++) &#123;<br>       \t\t <span class=\"hljs-built_in\">Promise</span>.resolve(promises[i]).then(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> &#123;<br>\t\t\t\tresolve(data);<br>       \t\t\t &#125;, <span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> &#123;<br>          \t\t\t<span class=\"hljs-keyword\">return</span> reject(err)<br>        &#125;)<br>      &#125;<br>    &#125;)<br>  &#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"Promise-resolve-和Promise-reject\"><a href=\"#Promise-resolve-和Promise-reject\" class=\"headerlink\" title=\"Promise.resolve()和Promise.reject()\"></a><code>Promise.resolve()</code>和<code>Promise.reject()</code></h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected</span><br><span class=\"hljs-keyword\">const</span> p = <span class=\"hljs-built_in\">Promise</span>.reject(<span class=\"hljs-string\">&#x27;出错了&#x27;</span>);<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">const</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> reject(<span class=\"hljs-string\">&#x27;出错了&#x27;</span>))<br><br>p.then(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">s</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(s)      <span class=\"hljs-comment\">// 出错了</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br><span class=\"hljs-comment\">// 等价于</span><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> resolve(<span class=\"hljs-string\">&#x27;foo&#x27;</span>))<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":5359,"excerpt":"","more":"<h2 id=\"promise解决了什么问题\"><a href=\"#promise解决了什么问题\" class=\"headerlink\" title=\"promise解决了什么问题\"></a>promise解决了什么问题</h2><p>JavaScript是单线程的，所以我们要用一些异步编程方案来实现异步。<br>回调函数就是其中的一种方案，比如说在node中写读取一个文件，使用回调函数这是没有问题的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">fs.readFile(<span class=\"hljs-string\">&#x27;/etc/passwd&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, data</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;<br>  <span class=\"hljs-built_in\">console</span>.log(data);<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>但如果新的需求是必须先读取A文件，才能读取B文件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">fs.readFile(fileA, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, data</span>) </span>&#123;<br>\tfs.readFile(fileB, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, data</span>) </span>&#123;\t<br>  \t\t<span class=\"hljs-comment\">//...</span><br>  \t\t&#125;)<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>不难想象，如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为”回调地狱”（callback hell）。<br>而<code>promise</code>就是为了解决这个问题而生的</p>\n<h2 id=\"什么是promise\"><a href=\"#什么是promise\" class=\"headerlink\" title=\"什么是promise\"></a>什么是promise</h2><p>它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载，改成纵向加载。采用Promise，连续读取多个文件，写法如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> readFile = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;fs-readfile-promise&#x27;</span>);<br>readFile(fileA)<span class=\"hljs-comment\">//读取文件A</span><br>.then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data</span>)</span>&#123;<span class=\"hljs-comment\">//如果读取成功则执行该函数，打印数据</span><br>  <span class=\"hljs-built_in\">console</span>.log(data.toString());<br>&#125;).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>&#123;<span class=\"hljs-comment\">//如果打印成功，则开始读取文件B</span><br>  <span class=\"hljs-keyword\">return</span> readFile(fileB);<br>&#125;).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data</span>)</span>&#123;<span class=\"hljs-comment\">//如果文件B读取成功，则打印文件B的数据</span><br>  <span class=\"hljs-built_in\">console</span>.log(data.toString());<br>&#125;).catch(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>) </span>&#123;<span class=\"hljs-comment\">//过程中发生任何错误则捕获，打印该错误</span><br>  <span class=\"hljs-built_in\">console</span>.log(err);<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>上面代码中，我使用了 <code>fs-readfile-promise</code> 模块，它的作用就是返回一个 Promise 版本的 <code>readFile</code> 函数。Promise 提供 <code>then</code> 方法加载回调函数，<code>catch</code>方法捕捉执行过程中抛出的错误。看起来清爽多了<br>再来看一段伪代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//传统写法（层层嵌套，可读性差）：</span><br>step1(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value1</span>) </span>&#123; <br>  step2(value1, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value2</span>) </span>&#123; <br>    step3(value2, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value3</span>) </span>&#123; <br>      step4(value3, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value4</span>) </span>&#123; <span class=\"hljs-comment\">// ... &#125;);</span><br>     &#125;); <br>  &#125;);<br>&#125;);<br><br><span class=\"hljs-comment\">//Promises的写法（清晰舒服）：</span><br>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(step1))<br>  .then(step2)<br>  .then(step3)<br>  .catch(step4);<br></code></pre></td></tr></table></figure>\n<p>promise对象，充当异步操作与回调函数之间的中介，将异步编程大大简化了。</p>\n<h3 id=\"Promise-的状态\"><a href=\"#Promise-的状态\" class=\"headerlink\" title=\"Promise 的状态\"></a>Promise 的状态</h3><p>等待（<code>pending</code>）：初始状态。<br>已完成（<code>fulfilled</code>）：意味着操作成功完成。<br>已失败（<code>rejected</code>）：意味着操作失败。</p>\n<p>Promise对象的状态只可能处于这三种之一，它的状态改变只可能是两种可能：从 Pending 变为 <code>fulfilled</code> 和从 <code>Pending</code> 变为 <code>Rejected</code>。一旦状态发生改变，就不会再变，这也是<code>Promise[承诺]</code>这个名字的由来。</p>\n<h3 id=\"promise的使用\"><a href=\"#promise的使用\" class=\"headerlink\" title=\"promise的使用\"></a>promise的使用</h3><p>再来看一个简单的例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getNumber</span>(<span class=\"hljs-params\">num</span>)</span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve,reject</span>)</span>&#123;<span class=\"hljs-comment\">//返回一个promise对象</span><br>      <span class=\"hljs-keyword\">if</span>(num &gt; <span class=\"hljs-number\">5</span>)&#123;<br>        resolve(num)<span class=\"hljs-comment\">//如果数字大于5则，执行resolve</span><br>      &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        reject(<span class=\"hljs-string\">&#x27;数字太小&#x27;</span>)&#125;<span class=\"hljs-comment\">//否则执行reject</span><br>  &#125;)<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">printData</span>(<span class=\"hljs-params\">data</span>)</span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;resolve&#x27;</span>);<br>    <span class=\"hljs-built_in\">console</span>.log(data);<br>  &#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">printError</span>(<span class=\"hljs-params\">data</span>)</span>&#123;<br>\t<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;reject&#x27;</span>);<br>    <span class=\"hljs-built_in\">console</span>.log(data);<br>&#125;<br>getNumber(<span class=\"hljs-number\">4</span>).then(printData).catch(printError);<span class=\"hljs-comment\">//reject 4</span><br>getNumber(<span class=\"hljs-number\">6</span>).then(printData).catch(printError);<span class=\"hljs-comment\">//resolve 6</span><br></code></pre></td></tr></table></figure>\n<p>当<code>promise</code>执行了<code>resolve</code>语句（模拟异步操作执行成功），那么<code>promise</code>的状态就回变为<code>resolve</code>，可以使用<code>then</code>方法，调用传入的回调函数，而回调函数的参数就是<code>resolve</code>中返回的数据。</p>\n<p>相反</p>\n<p>promise执行了<code>reject</code>语句（模拟异步操作执行失败），那么promise的状态就回变为<code>reject</code>，可以使用<code>catch</code>方法，调用传入的回调函数，而回调函数的参数就是reject中返回的数据。</p>\n<h3 id=\"promise的其他方法\"><a href=\"#promise的其他方法\" class=\"headerlink\" title=\"promise的其他方法\"></a>promise的其他方法</h3><h4 id=\"promise-all\"><a href=\"#promise-all\" class=\"headerlink\" title=\"promise.all\"></a>promise.all</h4><p><code>Promise.all(iterable)</code> 方法返回一个 <code>Promise</code> 实例，此实例在 <code>iterable</code> 参数内所有的 <code>promise</code> 都“<code>完成（resolved）</code>”或参数中不包含 <code>promise</code> 时回调<code>完成（resolve）</code>；如果参数中  <code>promise</code> 有一个<code>失败（rejected）</code>，此实例回调<code>失败（reject）</code>，失败原因的是第一个失败 <code>promise</code> 的结果</p>\n<p>将两个promise对象拼成一个数组传进<code>all</code>方法。看有没有失败，有一个失败的，则整个<code>all</code>方法产生的promise对象失败。</p>\n<p>只要有一个失败了，这个promise就失败，结果为第一个失败的结果。如果都成了，就返回全部成功的结果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        resolve(<span class=\"hljs-string\">&#x27;hello&#x27;</span>);<br>&#125;, <span class=\"hljs-number\">1000</span>);<br>&#125;)<br><span class=\"hljs-keyword\">const</span> p2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>    resolve(<span class=\"hljs-number\">1</span>);<br>  &#125;)<br> <span class=\"hljs-built_in\">Promise</span>.all([p1,p2]).then(<span class=\"hljs-comment\">//传入的是两个promise对象</span><br>    <span class=\"hljs-function\"><span class=\"hljs-params\">result</span>=&gt;</span><span class=\"hljs-built_in\">console</span>.log(result)<br>  ).catch(<br>    <span class=\"hljs-function\"><span class=\"hljs-params\">e</span>=&gt;</span><span class=\"hljs-built_in\">console</span>.log(e)        <br>  )<span class=\"hljs-comment\">// Array(2) [&quot;hello&quot;, 1]</span><br></code></pre></td></tr></table></figure>\n<p>将因为两个<code>promise</code>对象的状态都是已完成，所以返回的是数组，包含着两个<code>promise</code>的回调参数<br>在看另外一个例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>        resolve(<span class=\"hljs-string\">&#x27;第一个任务&#x27;</span>);<br>&#125;)<br><span class=\"hljs-keyword\">const</span> p2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve,reject</span>) =&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        reject(<span class=\"hljs-string\">&#x27;第二个任务&#x27;</span>)<br>    &#125;, <span class=\"hljs-number\">1000</span>);<br>&#125;)<br><span class=\"hljs-keyword\">const</span> p3 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        reject(<span class=\"hljs-string\">&#x27;第三个任务&#x27;</span>);    <br>    &#125;, <span class=\"hljs-number\">500</span>);<br>  &#125;)<br><span class=\"hljs-built_in\">Promise</span>.all([p1,p2,p3]).then(<br>    <span class=\"hljs-function\"><span class=\"hljs-params\">result</span>=&gt;</span><span class=\"hljs-built_in\">console</span>.log(result)<br>  ).catch(<br>    <span class=\"hljs-function\"><span class=\"hljs-params\">e</span>=&gt;</span><span class=\"hljs-built_in\">console</span>.log(e)        <br>  )<span class=\"hljs-comment\">//第三个任务</span><br></code></pre></td></tr></table></figure>\n<p>执行结果打印的是第三个任务，细品这段代码就能明白<code>Promise.all</code>干的是啥了</p>\n<h4 id=\"promise-all的实现\"><a href=\"#promise-all的实现\" class=\"headerlink\" title=\"promise.all的实现\"></a><code>promise.all</code>的实现</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/** 仅考虑 promises 传入的是数组的情况时 */</span><br><span class=\"hljs-built_in\">Promise</span>.all = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">promise</span>) </span>&#123;<br>\t<span class=\"hljs-keyword\">let</span> promises = <span class=\"hljs-built_in\">Array</span>.from(promise)<span class=\"hljs-comment\">//将iterator转换为数组</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (promises.length === <span class=\"hljs-number\">0</span>) &#123;<span class=\"hljs-comment\">//如果数组长度为0则返回空数组</span><br>            resolve([]);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">let</span> result = [];<span class=\"hljs-comment\">//存放已成功的异步操作</span><br>            <span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//记录已成功的操作数</span><br>            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>;  i &lt; promises.length; i++ ) &#123;<br>                <span class=\"hljs-built_in\">Promise</span>.resolve(promises[i])<span class=\"hljs-comment\">//执行每一个promise</span><br>                \t.then(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> &#123;<br>                    \tresult[i] = data;<br>                    \t<span class=\"hljs-keyword\">if</span> (++index === promises.length) &#123;<br>                        <span class=\"hljs-comment\">//所有的 promises 状态都是 fulfilled，promise.all返回的实例才变成 fulfilled 态</span><br>                       \t resolve(result);<br>                    &#125;<br>                &#125;, <span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> &#123;<br>                    reject(err);<br>                    <span class=\"hljs-keyword\">return</span>;<br>                &#125;);<br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a><code>Promise.race()</code></h4><p><code>Promise.race(iterable)</code> 方法返回一个 <code>promise</code>，一旦迭代器中的某个<code>promise</code>解决或拒绝，返回的 <code>promise</code>就会解决或拒绝<br>举个例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>         resolve(<span class=\"hljs-string\">&#x27;第一个任务&#x27;</span>);<br>    &#125;, <span class=\"hljs-number\">200</span>);<br>&#125;)<br><span class=\"hljs-keyword\">const</span> p2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve,reject</span>) =&gt;</span>&#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        reject(<span class=\"hljs-string\">&#x27;第二个任务&#x27;</span>)<br>    &#125;, <span class=\"hljs-number\">1000</span>);<br>&#125;)<br><span class=\"hljs-keyword\">const</span> p3 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        resolve(<span class=\"hljs-string\">&#x27;第三个任务&#x27;</span>);    <br>    &#125;, <span class=\"hljs-number\">500</span>);<br>  &#125;)<br><span class=\"hljs-built_in\">Promise</span>.all([p1,p2,p3]).then(<br>    <span class=\"hljs-function\"><span class=\"hljs-params\">result</span>=&gt;</span><span class=\"hljs-built_in\">console</span>.log(result)<br>  ).catch(<br>    <span class=\"hljs-function\"><span class=\"hljs-params\">e</span>=&gt;</span><span class=\"hljs-built_in\">console</span>.log(e)        <br>  )<span class=\"hljs-comment\">//第一个任务</span><br></code></pre></td></tr></table></figure>\n<p>只要其中一个实例先改变状态，状态就跟着改变将率先改变的<code>Promise</code>返回值传递给回调函数，大白话：看谁快</p>\n<h4 id=\"Promise-race-实现\"><a href=\"#Promise-race-实现\" class=\"headerlink\" title=\"Promise.race()实现\"></a><code>Promise.race()</code>实现</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> race = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">promise</span>) </span>&#123;<br>\t<span class=\"hljs-keyword\">let</span> promises = <span class=\"hljs-built_in\">Array</span>.from(promise)<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; promises.length; i++) &#123;<br>       \t\t <span class=\"hljs-built_in\">Promise</span>.resolve(promises[i]).then(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> &#123;<br>\t\t\t\tresolve(data);<br>       \t\t\t &#125;, <span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> &#123;<br>          \t\t\t<span class=\"hljs-keyword\">return</span> reject(err)<br>        &#125;)<br>      &#125;<br>    &#125;)<br>  &#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"Promise-resolve-和Promise-reject\"><a href=\"#Promise-resolve-和Promise-reject\" class=\"headerlink\" title=\"Promise.resolve()和Promise.reject()\"></a><code>Promise.resolve()</code>和<code>Promise.reject()</code></h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected</span><br><span class=\"hljs-keyword\">const</span> p = <span class=\"hljs-built_in\">Promise</span>.reject(<span class=\"hljs-string\">&#x27;出错了&#x27;</span>);<br><span class=\"hljs-comment\">// 等同于</span><br><span class=\"hljs-keyword\">const</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> reject(<span class=\"hljs-string\">&#x27;出错了&#x27;</span>))<br><br>p.then(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">s</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(s)      <span class=\"hljs-comment\">// 出错了</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)<br><span class=\"hljs-comment\">// 等价于</span><br><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> resolve(<span class=\"hljs-string\">&#x27;foo&#x27;</span>))<br></code></pre></td></tr></table></figure>\n"},{"title":"Vue实战：实现一个博客系统","date":"2020-04-19T15:18:57.000Z","index_img":"/img/blogCovers/blog-post2.png","_content":"最近想结合所学写一个项目，最后决定写一个博客系统，使用的技术栈为：\n\n前端：Vue Vue-router element-ui \n\n后端：express moogose jsonwebtoken\n\n使用了vue-cli搭建项目\n\n**仓库地址**： [https://github.com/RichDavidMu/vue-blog-master](https://github.com/RichDavidMu/vue-blog-master)\n\n主页：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200425201447403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n\n\n文章详情页：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200425201518158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n后台管理页面：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020042520155361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n\n文章编辑页：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200425201617476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n\n\nmarkdown实时预览：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200425201638341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n","source":"_posts/vue实战-博客系统.md","raw":"---\ntitle: Vue实战：实现一个博客系统\ndate: 2020-04-19 23:18:57\nindex_img: /img/blogCovers/blog-post2.png\ntags: [Vue, Webpack]\ncategories: [项目实战]\n---\n最近想结合所学写一个项目，最后决定写一个博客系统，使用的技术栈为：\n\n前端：Vue Vue-router element-ui \n\n后端：express moogose jsonwebtoken\n\n使用了vue-cli搭建项目\n\n**仓库地址**： [https://github.com/RichDavidMu/vue-blog-master](https://github.com/RichDavidMu/vue-blog-master)\n\n主页：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200425201447403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n\n\n文章详情页：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200425201518158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n后台管理页面：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020042520155361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n\n文章编辑页：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200425201617476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n\n\nmarkdown实时预览：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200425201638341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n","slug":"vue实战-博客系统","published":1,"updated":"2022-01-23T04:00:54.275Z","_id":"ckyo4lu6q000anz69168hh4v4","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近想结合所学写一个项目，最后决定写一个博客系统，使用的技术栈为：</p>\n<p>前端：Vue Vue-router element-ui </p>\n<p>后端：express moogose jsonwebtoken</p>\n<p>使用了vue-cli搭建项目</p>\n<p><strong>仓库地址</strong>： <a href=\"https://github.com/RichDavidMu/vue-blog-master\">https://github.com/RichDavidMu/vue-blog-master</a></p>\n<p>主页：<br><img src=\"https://img-blog.csdnimg.cn/20200425201447403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>文章详情页：<br><img src=\"https://img-blog.csdnimg.cn/20200425201518158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>后台管理页面：<br><img src=\"https://img-blog.csdnimg.cn/2020042520155361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>文章编辑页：<br><img src=\"https://img-blog.csdnimg.cn/20200425201617476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>markdown实时预览：<br><img src=\"https://img-blog.csdnimg.cn/20200425201638341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"wordcount":188,"excerpt":"","more":"<p>最近想结合所学写一个项目，最后决定写一个博客系统，使用的技术栈为：</p>\n<p>前端：Vue Vue-router element-ui </p>\n<p>后端：express moogose jsonwebtoken</p>\n<p>使用了vue-cli搭建项目</p>\n<p><strong>仓库地址</strong>： <a href=\"https://github.com/RichDavidMu/vue-blog-master\">https://github.com/RichDavidMu/vue-blog-master</a></p>\n<p>主页：<br><img src=\"https://img-blog.csdnimg.cn/20200425201447403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>文章详情页：<br><img src=\"https://img-blog.csdnimg.cn/20200425201518158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>后台管理页面：<br><img src=\"https://img-blog.csdnimg.cn/2020042520155361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>文章编辑页：<br><img src=\"https://img-blog.csdnimg.cn/20200425201617476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>markdown实时预览：<br><img src=\"https://img-blog.csdnimg.cn/20200425201638341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n"},{"title":"Vue实战：知乎日报2.0","date":"2020-03-22T15:11:56.000Z","index_img":"/img/blogCovers/blog-post4.jpg","_content":"\n因为书中的代码比较久远，许多接口、webpack配置都已更新，但这个项目还是很好玩的，本文的代码都是相对于原书代码的补充。\n完整代码:[https://github.com/RichDavidMu/zhihuDaily](https://github.com/RichDavidMu/zhihuDaily)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200326213059175.gif#pic_center)\n## webpack配置\n虽然最新的webpack已经是4.0版本。但与书中的webpack2大多能兼容，只有几个地方稍有变化\n###### vue-loader\nvue-loader@15.x 版本相较之前需要增加一些配置\n\n```javascript\n//webpack.config.js\nconst VueLoaderPlugin = require('vue-loader/lib/plugin');\n{...}\n\tplugins:[new VueLoaderPlugin()]\n{...}\n```\n###### mini-css-extract-plugin\nwebpack4中建议使用mini-css-extract-plugin，而不是extract-text-webpack-plugin。\n\n```javascript\n//webpack.config.js\nconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");\n{...}\n{\n   test:/\\.css$/,\n    use:[\n        {\n            loader: MiniCssExtractPlugin.loader\n        },\n        'css-loader'\n    ]\n}\n{...}\nnew MiniCssExtractPlugin({\n            filename: \"[name].css\",\n            chunkFilename: \"[id].css\"\n        })\n```\n###### 遇到的一个坑\n因为这是一个单页应用，所以在写css的时候，我把他们全部写在app.vue文件中，这样在打包的时候，会自动的在打包后样式中加上属性选择器，就像这样\n\n```\n.daily-item[data-v-186c01a3]:hover{\n    background: #e3e8ee;\n}\n```\n然后坑来了，因为用的html-webpack-plugin自动生成html文件，而他的模板文件中的body、html元素不会自动生成相应的属性，打开控制台看一下Element\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200326220121432.png)\n可以看到body，html元素均没有属性选择器，而写在vue文件的元素有，这样，我们在app.vue中的有关`<html><body>`的样式均无法生效。\n解决：新建一个style.css文件，在main.js中引用，将body、html的样式写在里面，这样打包后的样式不会被加上属性选择器。\n## 热门栏目功能\n因为书中的主题日报所用的api已经无效，看了一下这篇文章 [日报 API 分析](https://blog.csdn.net/fanpeihua123/article/details/51210499)，使用postman把里面的接口都试了一下，发现栏目的api可用，虽然是内容已经停止更新了，但作为练习的话，影响不大。\n**首先建立一个section的代理服务器**，用来转发数据，解决跨域限制\n\n```javascript\n//proxy.js\nconst http = require('http');\nconst request = require('request');\n\nconst hostname = '127.0.0.1';\nconst sectionPort= 8012;\nconst sectionServer = http.createServer((req, res) => {\n    const url = 'http://news-at.zhihu.com/api/3' + req.url;\n    const options = {\n        url: url\n    };\n    function callback (error, response, body) {\n        if (!error && response.statusCode === 200) {\n            // 设置编码类型，否则中文会显示为乱码\n            res.setHeader('Content-Type', 'text/plain;charset=UTF-8');\n            // 设置所有域允许跨域\n            res.setHeader('Access-Control-Allow-Origin', '*');\n            // 返回代理后的内容\n            res.end(body);\n        }\n    }\n    request.get(options, callback);\n});\nsectionServer.listen(sectionPort, hostname, () => {\n    console.log(`栏目代理运行在 http://${hostname}:${sectionPort}/`)\n});\n```\n**增加相应的ajax模块**\n\n```javascript\n//util.js\nimport axios from 'axios';\n\nconst Util = {\n    sectionPath:'http://127.0.0.1:8012/'\n};\n// Ajax 通用配置\nUtil.ajaxSection = axios.create({\n    baseURL: Util.sectionPath\n});\n// 添加响应拦截器\nUtil.ajaxStories.interceptors.response.use(res => {\n    return res.data;\n});\nexport default Util;\n```\n写上栏目的html结构，在data中加入我们需要维护的数据\n```javascript\n//app.vue\n<template>\n<div>\n    <div class=\"daily\">\n        <div class=\"daily-menu\">\n        ...\n        <div class=\"daily-menu-item\"\n            :class=\"{on:type==='section'}\"\n            @click=\"showSection = !showSection\">热门栏目</div>\n            <ul v-show=\"showSection\">\n                <li v-for=\"item in sections\">\n                    <a :class=\"{on: item.id === sectionId && type === 'section'}\"\n                    @click=\"handleToSection(item.id)\">{{ item.name}}</a>\n                </li>\n            </ul>\n        </div>\n    </div>\n     <div class=\"daily-list\" ref=\"list\">\n     ...\n     <template v-if=\"type === 'section'\">\n                <item v-for=\"item in list\"\n                      :data=\"item\"\n                      :key=\"item.id\"\n                    @click.native=\"handleClick(item.id)\"></item>\n            </template>\n        </div>\n         <daily-article :id=\"articleId\" :type=\"this.type\"></daily-article>\n    </div>\n</div>\n</template>\n<script>\nexport default {\n data(){\n            return {\n                sections:[],//保存栏目目录\n                showSection:false,//是否显示所有栏目\n                type:'recommend',\n                sectionId:0,//保存栏目id\n                list:[],//保存访问栏目的所有文章\n                sectionTime:0,//本次请求的时间戳\n                           }\n        }\n    }\n        </script>\n```\n定义一个method，当点击栏目时，访问栏目api，获得栏目列表，并将数据写入data中\n\n```javascript\nmethods:{\n            getSections(){\n                $.ajaxSection.get('sections').then(res =>{\n                    this.sections = res.data;\n                })\n            }\n        }\n```\n当点击具体某个栏目时，中间栏要显示该栏目的文章列表，定义一个method，当调用这哥method时，访问api，将数据写入data，DOM的改变让Vue去做\n\n```javascript\nhandleToSection(id){\n                this.type = 'section';\n                this.sectionId = id;\n                this.list = [];\n                $.ajaxSection.get('section/'+id).then(res=>{\n                    this.sectionTime = res.timestamp;\n                    this.list = res.stories;\n                })\n            }\n```\n为中间栏添加scroll事件\n\n```javascript\nmounted() {\n\tconst $list = this.$refs.list;\n\t$list.addEventListener('scroll',()=>{\n                if(this.isloading) return;\n                if($list.scrollTop + document.body.clientHeight >= $list.scrollHeight-100){\n                    if(this.type === 'recommend') {\n                        this.dailyTime -=86400000;\n                        this.getRecommendList();\n                    }else{\n                        this.getSectionList()\n                    }\n                }\n            });\n}\n```\n\n下拉中间栏到底，自动加载更多数据\n\n```javascript\ngetSectionList(){\n                this.isloading = true;\n                $.ajaxSection.get('section/' +this.sectionId+`/before/${this.sectionTime}`).then(res=>{\n                    this.sectionTime= res.timestamp;\n                    for (const value of res.stories){\n                        this.list.push(value);\n                    }\n                    this.isloading=false;\n                })\n            }\n```\n## 栏目文章详情组件\n一开始只是把日报的组件拿来用，发现直接用v-html转换的页面太难看。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200327123440199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n正好栏目api提供了对应文章的知乎页面的url\n\n```\n{\n    \"timestamp\": 1463148001,\n    \"stories\": [\n        {\n            \"image_hue\": \"0x3779b3\",\n            \"title\": \"深夜惊奇 · 要穿内衣\",\n            \"url\": \"https://daily.zhihu.com/story/8387524\",\n            \"date\": \"20160601\",\n            \"display_date\": \"6 月 1 日\",\n            \"images\": [\n                \"http://pic3.zhimg.com/91125c9aebcab1c84f58ce4f8779551e.jpg\"\n            ],\n            \"id\": 8387524\n        },\n```\n可以看到上面的stories中url就是文章对应知乎页面了，可以用一个`<iframe>`直接显示这个页面。但是为了尽量少动代码，还是将知乎的html源码保存下来，用v-html直接显示\n**增加一个stories代理服务器**，与之前类似\n\n```javascript\n//proxy.js\nconst storiesServer = http.createServer((req, res) => {\n    const url = 'https://daily.zhihu.com/story' + req.url;\n    const options = {\n        url: url\n    };\n\n    function callback (error, response, body) {\n        //......\n        }\n    }\n    request.get(options, callback);\n});\nstoriesServer.listen(storiesPort, hostname, () => {\n    console.log(`栏目故事代理运行在 http://${hostname}:${storiesPort}/`)\n});\n```\n相应的ajax模块\n\n```javascript\n//util.js\nimport axios from 'axios';\n\nconst Util = {\n   //...\n    storiesPath:'http://127.0.0.1:8013/'\n};\nUtil.ajaxStories = axios.create({\n    baseURL:Util.storiesPath\n})\nUtil.ajaxStories.interceptors.response.use(res => {\n    return res.data;\n});\n```\n##### daily-article组件\nprops中增加一个参数type，接受父组件的信息，现在显示哪一部分，使用watch监控id与type，当他们发生改变时，调用相应方法\n\n```javascript\n//daily-article.vue\n<template>\n    <div class=\"daily-article\">\n        <div v-if=\"this.type === 'recommend'\" class=\"daily-article-title\">{{ data.title }}</div>\n        <div v-if=\"this.type === 'recommend'\" class=\"daily-article-content\" v-html=\"data.body\"></div>\n        <div v-if=\"this.type === 'section'\" v-html=\"this.htmlData\"></div>\n        <div class=\"daily-comments\" v-show=\"comments.length\">         \n                <!--...-->\n        </div>\n    </div>\n</template>\n<script>\n{...}\nprops:{\n\t type:{\n\t                type:String,\n\t                default:'recommend'\n\t            }\n\t        },\n\t data(){\n            return{\n\t            htmlData:''\n\t            }\n        },\n        watch:{\n            type(val){//类型发生变化，清空数据\n                this.data={},\n                this.comments=[],\n                this.htmlData=''\n            },\n            id(val){//文章id变化，更新文章数据\n                if (this.type==='recommend'&&val) {\n                    this.getArticle();\n                }else {\n                    this.getStores()\n                }\n            }\n        }\n```\n\n```javascript\ngetStores(){//获得html源码，将里面的图片换成代理地址\n              $.ajaxStories.get(`${this.id}`).then(res=>{\n                  res =res.replace(/src=\"http/g,'src=\"' + $.imgPath+'http');\n                  res =res.replace(/src=\"https/g,'src=\"' + $.imgPath + 'https');\n                   this.htmlData = res;\n                    this.getComments();\n              })\n            }\n```\n本以为大功告成了，打开网页发现并没有显示文章，上来就是评论\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020032712353950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n\n打开控制台看到\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200327123608340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n看起来好像是css文件被跨域限制了，无法引用。那就用之前图片的代理服务器转发一下就好了。\n\n```javascript\n//daily-article.vue\nmethods:{\n            getStores(){\n              $.ajaxStories.get(`${this.id}`).then(res=>{\n              res =res.replace(/href=\"http/g,'href=\"' + $.imgPath+'http');\n              res =res.replace(/href=\"https/g,'href=\"' + $.imgPath + 'https');\n})\n            }\n```\n再打开网页，确实没问题了，但是这个知乎app的提醒很烦，把它去掉。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200327124025380.png#pic_center)\n在html里找他的类名，在后面加上display：none\n\n```javascript\n//daily-article.vue\nmethods:{\n            getStores(){\n              $.ajaxStories.get(`${this.id}`).then(res=>{\n              res =res.replace(/ZhihuDailyOIABanner\"/,'ZhihuDailyOIABanner\" style=\"display:none;\"')\n              })\n            }\n```\n完工\n","source":"_posts/vue实战-知乎日报.md","raw":"---\ntitle: Vue实战：知乎日报2.0\ndate: 2020-03-22 23:11:56\nindex_img: /img/blogCovers/blog-post4.jpg\ntags: [Vue, Webpack]\ncategories: [项目实战]\n---\n\n因为书中的代码比较久远，许多接口、webpack配置都已更新，但这个项目还是很好玩的，本文的代码都是相对于原书代码的补充。\n完整代码:[https://github.com/RichDavidMu/zhihuDaily](https://github.com/RichDavidMu/zhihuDaily)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200326213059175.gif#pic_center)\n## webpack配置\n虽然最新的webpack已经是4.0版本。但与书中的webpack2大多能兼容，只有几个地方稍有变化\n###### vue-loader\nvue-loader@15.x 版本相较之前需要增加一些配置\n\n```javascript\n//webpack.config.js\nconst VueLoaderPlugin = require('vue-loader/lib/plugin');\n{...}\n\tplugins:[new VueLoaderPlugin()]\n{...}\n```\n###### mini-css-extract-plugin\nwebpack4中建议使用mini-css-extract-plugin，而不是extract-text-webpack-plugin。\n\n```javascript\n//webpack.config.js\nconst MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");\n{...}\n{\n   test:/\\.css$/,\n    use:[\n        {\n            loader: MiniCssExtractPlugin.loader\n        },\n        'css-loader'\n    ]\n}\n{...}\nnew MiniCssExtractPlugin({\n            filename: \"[name].css\",\n            chunkFilename: \"[id].css\"\n        })\n```\n###### 遇到的一个坑\n因为这是一个单页应用，所以在写css的时候，我把他们全部写在app.vue文件中，这样在打包的时候，会自动的在打包后样式中加上属性选择器，就像这样\n\n```\n.daily-item[data-v-186c01a3]:hover{\n    background: #e3e8ee;\n}\n```\n然后坑来了，因为用的html-webpack-plugin自动生成html文件，而他的模板文件中的body、html元素不会自动生成相应的属性，打开控制台看一下Element\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200326220121432.png)\n可以看到body，html元素均没有属性选择器，而写在vue文件的元素有，这样，我们在app.vue中的有关`<html><body>`的样式均无法生效。\n解决：新建一个style.css文件，在main.js中引用，将body、html的样式写在里面，这样打包后的样式不会被加上属性选择器。\n## 热门栏目功能\n因为书中的主题日报所用的api已经无效，看了一下这篇文章 [日报 API 分析](https://blog.csdn.net/fanpeihua123/article/details/51210499)，使用postman把里面的接口都试了一下，发现栏目的api可用，虽然是内容已经停止更新了，但作为练习的话，影响不大。\n**首先建立一个section的代理服务器**，用来转发数据，解决跨域限制\n\n```javascript\n//proxy.js\nconst http = require('http');\nconst request = require('request');\n\nconst hostname = '127.0.0.1';\nconst sectionPort= 8012;\nconst sectionServer = http.createServer((req, res) => {\n    const url = 'http://news-at.zhihu.com/api/3' + req.url;\n    const options = {\n        url: url\n    };\n    function callback (error, response, body) {\n        if (!error && response.statusCode === 200) {\n            // 设置编码类型，否则中文会显示为乱码\n            res.setHeader('Content-Type', 'text/plain;charset=UTF-8');\n            // 设置所有域允许跨域\n            res.setHeader('Access-Control-Allow-Origin', '*');\n            // 返回代理后的内容\n            res.end(body);\n        }\n    }\n    request.get(options, callback);\n});\nsectionServer.listen(sectionPort, hostname, () => {\n    console.log(`栏目代理运行在 http://${hostname}:${sectionPort}/`)\n});\n```\n**增加相应的ajax模块**\n\n```javascript\n//util.js\nimport axios from 'axios';\n\nconst Util = {\n    sectionPath:'http://127.0.0.1:8012/'\n};\n// Ajax 通用配置\nUtil.ajaxSection = axios.create({\n    baseURL: Util.sectionPath\n});\n// 添加响应拦截器\nUtil.ajaxStories.interceptors.response.use(res => {\n    return res.data;\n});\nexport default Util;\n```\n写上栏目的html结构，在data中加入我们需要维护的数据\n```javascript\n//app.vue\n<template>\n<div>\n    <div class=\"daily\">\n        <div class=\"daily-menu\">\n        ...\n        <div class=\"daily-menu-item\"\n            :class=\"{on:type==='section'}\"\n            @click=\"showSection = !showSection\">热门栏目</div>\n            <ul v-show=\"showSection\">\n                <li v-for=\"item in sections\">\n                    <a :class=\"{on: item.id === sectionId && type === 'section'}\"\n                    @click=\"handleToSection(item.id)\">{{ item.name}}</a>\n                </li>\n            </ul>\n        </div>\n    </div>\n     <div class=\"daily-list\" ref=\"list\">\n     ...\n     <template v-if=\"type === 'section'\">\n                <item v-for=\"item in list\"\n                      :data=\"item\"\n                      :key=\"item.id\"\n                    @click.native=\"handleClick(item.id)\"></item>\n            </template>\n        </div>\n         <daily-article :id=\"articleId\" :type=\"this.type\"></daily-article>\n    </div>\n</div>\n</template>\n<script>\nexport default {\n data(){\n            return {\n                sections:[],//保存栏目目录\n                showSection:false,//是否显示所有栏目\n                type:'recommend',\n                sectionId:0,//保存栏目id\n                list:[],//保存访问栏目的所有文章\n                sectionTime:0,//本次请求的时间戳\n                           }\n        }\n    }\n        </script>\n```\n定义一个method，当点击栏目时，访问栏目api，获得栏目列表，并将数据写入data中\n\n```javascript\nmethods:{\n            getSections(){\n                $.ajaxSection.get('sections').then(res =>{\n                    this.sections = res.data;\n                })\n            }\n        }\n```\n当点击具体某个栏目时，中间栏要显示该栏目的文章列表，定义一个method，当调用这哥method时，访问api，将数据写入data，DOM的改变让Vue去做\n\n```javascript\nhandleToSection(id){\n                this.type = 'section';\n                this.sectionId = id;\n                this.list = [];\n                $.ajaxSection.get('section/'+id).then(res=>{\n                    this.sectionTime = res.timestamp;\n                    this.list = res.stories;\n                })\n            }\n```\n为中间栏添加scroll事件\n\n```javascript\nmounted() {\n\tconst $list = this.$refs.list;\n\t$list.addEventListener('scroll',()=>{\n                if(this.isloading) return;\n                if($list.scrollTop + document.body.clientHeight >= $list.scrollHeight-100){\n                    if(this.type === 'recommend') {\n                        this.dailyTime -=86400000;\n                        this.getRecommendList();\n                    }else{\n                        this.getSectionList()\n                    }\n                }\n            });\n}\n```\n\n下拉中间栏到底，自动加载更多数据\n\n```javascript\ngetSectionList(){\n                this.isloading = true;\n                $.ajaxSection.get('section/' +this.sectionId+`/before/${this.sectionTime}`).then(res=>{\n                    this.sectionTime= res.timestamp;\n                    for (const value of res.stories){\n                        this.list.push(value);\n                    }\n                    this.isloading=false;\n                })\n            }\n```\n## 栏目文章详情组件\n一开始只是把日报的组件拿来用，发现直接用v-html转换的页面太难看。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200327123440199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n正好栏目api提供了对应文章的知乎页面的url\n\n```\n{\n    \"timestamp\": 1463148001,\n    \"stories\": [\n        {\n            \"image_hue\": \"0x3779b3\",\n            \"title\": \"深夜惊奇 · 要穿内衣\",\n            \"url\": \"https://daily.zhihu.com/story/8387524\",\n            \"date\": \"20160601\",\n            \"display_date\": \"6 月 1 日\",\n            \"images\": [\n                \"http://pic3.zhimg.com/91125c9aebcab1c84f58ce4f8779551e.jpg\"\n            ],\n            \"id\": 8387524\n        },\n```\n可以看到上面的stories中url就是文章对应知乎页面了，可以用一个`<iframe>`直接显示这个页面。但是为了尽量少动代码，还是将知乎的html源码保存下来，用v-html直接显示\n**增加一个stories代理服务器**，与之前类似\n\n```javascript\n//proxy.js\nconst storiesServer = http.createServer((req, res) => {\n    const url = 'https://daily.zhihu.com/story' + req.url;\n    const options = {\n        url: url\n    };\n\n    function callback (error, response, body) {\n        //......\n        }\n    }\n    request.get(options, callback);\n});\nstoriesServer.listen(storiesPort, hostname, () => {\n    console.log(`栏目故事代理运行在 http://${hostname}:${storiesPort}/`)\n});\n```\n相应的ajax模块\n\n```javascript\n//util.js\nimport axios from 'axios';\n\nconst Util = {\n   //...\n    storiesPath:'http://127.0.0.1:8013/'\n};\nUtil.ajaxStories = axios.create({\n    baseURL:Util.storiesPath\n})\nUtil.ajaxStories.interceptors.response.use(res => {\n    return res.data;\n});\n```\n##### daily-article组件\nprops中增加一个参数type，接受父组件的信息，现在显示哪一部分，使用watch监控id与type，当他们发生改变时，调用相应方法\n\n```javascript\n//daily-article.vue\n<template>\n    <div class=\"daily-article\">\n        <div v-if=\"this.type === 'recommend'\" class=\"daily-article-title\">{{ data.title }}</div>\n        <div v-if=\"this.type === 'recommend'\" class=\"daily-article-content\" v-html=\"data.body\"></div>\n        <div v-if=\"this.type === 'section'\" v-html=\"this.htmlData\"></div>\n        <div class=\"daily-comments\" v-show=\"comments.length\">         \n                <!--...-->\n        </div>\n    </div>\n</template>\n<script>\n{...}\nprops:{\n\t type:{\n\t                type:String,\n\t                default:'recommend'\n\t            }\n\t        },\n\t data(){\n            return{\n\t            htmlData:''\n\t            }\n        },\n        watch:{\n            type(val){//类型发生变化，清空数据\n                this.data={},\n                this.comments=[],\n                this.htmlData=''\n            },\n            id(val){//文章id变化，更新文章数据\n                if (this.type==='recommend'&&val) {\n                    this.getArticle();\n                }else {\n                    this.getStores()\n                }\n            }\n        }\n```\n\n```javascript\ngetStores(){//获得html源码，将里面的图片换成代理地址\n              $.ajaxStories.get(`${this.id}`).then(res=>{\n                  res =res.replace(/src=\"http/g,'src=\"' + $.imgPath+'http');\n                  res =res.replace(/src=\"https/g,'src=\"' + $.imgPath + 'https');\n                   this.htmlData = res;\n                    this.getComments();\n              })\n            }\n```\n本以为大功告成了，打开网页发现并没有显示文章，上来就是评论\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020032712353950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n\n打开控制台看到\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200327123608340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n看起来好像是css文件被跨域限制了，无法引用。那就用之前图片的代理服务器转发一下就好了。\n\n```javascript\n//daily-article.vue\nmethods:{\n            getStores(){\n              $.ajaxStories.get(`${this.id}`).then(res=>{\n              res =res.replace(/href=\"http/g,'href=\"' + $.imgPath+'http');\n              res =res.replace(/href=\"https/g,'href=\"' + $.imgPath + 'https');\n})\n            }\n```\n再打开网页，确实没问题了，但是这个知乎app的提醒很烦，把它去掉。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200327124025380.png#pic_center)\n在html里找他的类名，在后面加上display：none\n\n```javascript\n//daily-article.vue\nmethods:{\n            getStores(){\n              $.ajaxStories.get(`${this.id}`).then(res=>{\n              res =res.replace(/ZhihuDailyOIABanner\"/,'ZhihuDailyOIABanner\" style=\"display:none;\"')\n              })\n            }\n```\n完工\n","slug":"vue实战-知乎日报","published":1,"updated":"2022-01-23T04:00:54.275Z","_id":"ckyo4lu6z000znz69awtr7b95","comments":1,"layout":"post","photos":[],"link":"","content":"<p>因为书中的代码比较久远，许多接口、webpack配置都已更新，但这个项目还是很好玩的，本文的代码都是相对于原书代码的补充。<br>完整代码:<a href=\"https://github.com/RichDavidMu/zhihuDaily\">https://github.com/RichDavidMu/zhihuDaily</a></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200326213059175.gif#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"webpack配置\"><a href=\"#webpack配置\" class=\"headerlink\" title=\"webpack配置\"></a>webpack配置</h2><p>虽然最新的webpack已经是4.0版本。但与书中的webpack2大多能兼容，只有几个地方稍有变化</p>\n<h6 id=\"vue-loader\"><a href=\"#vue-loader\" class=\"headerlink\" title=\"vue-loader\"></a>vue-loader</h6><p><a href=\"mailto:&#x76;&#x75;&#101;&#45;&#108;&#x6f;&#97;&#100;&#101;&#x72;&#x40;&#x31;&#53;&#x2e;&#120;\">&#x76;&#x75;&#101;&#45;&#108;&#x6f;&#97;&#100;&#101;&#x72;&#x40;&#x31;&#53;&#x2e;&#120;</a> 版本相较之前需要增加一些配置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//webpack.config.js</span><br><span class=\"hljs-keyword\">const</span> VueLoaderPlugin = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;vue-loader/lib/plugin&#x27;</span>);<br>&#123;...&#125;<br>\t<span class=\"hljs-attr\">plugins</span>:[<span class=\"hljs-keyword\">new</span> VueLoaderPlugin()]<br>&#123;...&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"mini-css-extract-plugin\"><a href=\"#mini-css-extract-plugin\" class=\"headerlink\" title=\"mini-css-extract-plugin\"></a>mini-css-extract-plugin</h6><p>webpack4中建议使用mini-css-extract-plugin，而不是extract-text-webpack-plugin。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//webpack.config.js</span><br><span class=\"hljs-keyword\">const</span> MiniCssExtractPlugin = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;mini-css-extract-plugin&quot;</span>);<br>&#123;...&#125;<br>&#123;<br>   <span class=\"hljs-attr\">test</span>:<span class=\"hljs-regexp\">/\\.css$/</span>,<br>    use:[<br>        &#123;<br>            <span class=\"hljs-attr\">loader</span>: MiniCssExtractPlugin.loader<br>        &#125;,<br>        <span class=\"hljs-string\">&#x27;css-loader&#x27;</span><br>    ]<br>&#125;<br>&#123;...&#125;<br><span class=\"hljs-keyword\">new</span> MiniCssExtractPlugin(&#123;<br>            <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&quot;[name].css&quot;</span>,<br>            <span class=\"hljs-attr\">chunkFilename</span>: <span class=\"hljs-string\">&quot;[id].css&quot;</span><br>        &#125;)<br></code></pre></td></tr></table></figure>\n<h6 id=\"遇到的一个坑\"><a href=\"#遇到的一个坑\" class=\"headerlink\" title=\"遇到的一个坑\"></a>遇到的一个坑</h6><p>因为这是一个单页应用，所以在写css的时候，我把他们全部写在app.vue文件中，这样在打包的时候，会自动的在打包后样式中加上属性选择器，就像这样</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.daily-item</span><span class=\"hljs-selector-attr\">[data-v-186c01a3]</span><span class=\"hljs-selector-pseudo\">:hover</span>&#123;<br>    <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#e3e8ee</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>然后坑来了，因为用的html-webpack-plugin自动生成html文件，而他的模板文件中的body、html元素不会自动生成相应的属性，打开控制台看一下Element<br><img src=\"https://img-blog.csdnimg.cn/20200326220121432.png\" alt=\"在这里插入图片描述\"><br>可以看到body，html元素均没有属性选择器，而写在vue文件的元素有，这样，我们在app.vue中的有关<code>&lt;html&gt;&lt;body&gt;</code>的样式均无法生效。<br>解决：新建一个style.css文件，在main.js中引用，将body、html的样式写在里面，这样打包后的样式不会被加上属性选择器。</p>\n<h2 id=\"热门栏目功能\"><a href=\"#热门栏目功能\" class=\"headerlink\" title=\"热门栏目功能\"></a>热门栏目功能</h2><p>因为书中的主题日报所用的api已经无效，看了一下这篇文章 <a href=\"https://blog.csdn.net/fanpeihua123/article/details/51210499\">日报 API 分析</a>，使用postman把里面的接口都试了一下，发现栏目的api可用，虽然是内容已经停止更新了，但作为练习的话，影响不大。<br><strong>首先建立一个section的代理服务器</strong>，用来转发数据，解决跨域限制</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//proxy.js</span><br><span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;http&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> request = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;request&#x27;</span>);<br><br><span class=\"hljs-keyword\">const</span> hostname = <span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>;<br><span class=\"hljs-keyword\">const</span> sectionPort= <span class=\"hljs-number\">8012</span>;<br><span class=\"hljs-keyword\">const</span> sectionServer = http.createServer(<span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> url = <span class=\"hljs-string\">&#x27;http://news-at.zhihu.com/api/3&#x27;</span> + req.url;<br>    <span class=\"hljs-keyword\">const</span> options = &#123;<br>        <span class=\"hljs-attr\">url</span>: url<br>    &#125;;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">callback</span> (<span class=\"hljs-params\">error, response, body</span>) </span>&#123;<br>        <span class=\"hljs-keyword\">if</span> (!error &amp;&amp; response.statusCode === <span class=\"hljs-number\">200</span>) &#123;<br>            <span class=\"hljs-comment\">// 设置编码类型，否则中文会显示为乱码</span><br>            res.setHeader(<span class=\"hljs-string\">&#x27;Content-Type&#x27;</span>, <span class=\"hljs-string\">&#x27;text/plain;charset=UTF-8&#x27;</span>);<br>            <span class=\"hljs-comment\">// 设置所有域允许跨域</span><br>            res.setHeader(<span class=\"hljs-string\">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class=\"hljs-string\">&#x27;*&#x27;</span>);<br>            <span class=\"hljs-comment\">// 返回代理后的内容</span><br>            res.end(body);<br>        &#125;<br>    &#125;<br>    request.get(options, callback);<br>&#125;);<br>sectionServer.listen(sectionPort, hostname, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`栏目代理运行在 http://<span class=\"hljs-subst\">$&#123;hostname&#125;</span>:<span class=\"hljs-subst\">$&#123;sectionPort&#125;</span>/`</span>)<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p><strong>增加相应的ajax模块</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//util.js</span><br><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;axios&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> Util = &#123;<br>    <span class=\"hljs-attr\">sectionPath</span>:<span class=\"hljs-string\">&#x27;http://127.0.0.1:8012/&#x27;</span><br>&#125;;<br><span class=\"hljs-comment\">// Ajax 通用配置</span><br>Util.ajaxSection = axios.create(&#123;<br>    <span class=\"hljs-attr\">baseURL</span>: Util.sectionPath<br>&#125;);<br><span class=\"hljs-comment\">// 添加响应拦截器</span><br>Util.ajaxStories.interceptors.response.use(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> res.data;<br>&#125;);<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> Util;<br></code></pre></td></tr></table></figure>\n<p>写上栏目的html结构，在data中加入我们需要维护的数据</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//app.vue</span><br>&lt;template&gt;<br><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;daily&quot;</span>&gt;</span></span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;daily-menu&quot;</span>&gt;</span></span><br><span class=\"xml\">        ...</span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;daily-menu-item&quot;</span></span></span><br><span class=\"hljs-tag\"><span class=\"xml\">            <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">&quot;&#123;on:type===&#x27;section&#x27;&#125;&quot;</span></span></span><br><span class=\"hljs-tag\"><span class=\"xml\">            @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">&quot;showSection = !showSection&quot;</span>&gt;</span>热门栏目<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">v-show</span>=<span class=\"hljs-string\">&quot;showSection&quot;</span>&gt;</span></span><br><span class=\"xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">&quot;item in sections&quot;</span>&gt;</span></span><br><span class=\"xml\">                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">&quot;&#123;on: item.id === sectionId &amp;&amp; type === &#x27;section&#x27;&#125;&quot;</span></span></span><br><span class=\"hljs-tag\"><span class=\"xml\">                    @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">&quot;handleToSection(item.id)&quot;</span>&gt;</span>&#123;&#123; item.name&#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></span><br><span class=\"xml\">                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span><br><span class=\"xml\">            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;daily-list&quot;</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">&quot;list&quot;</span>&gt;</span></span><br><span class=\"xml\">     ...</span><br><span class=\"xml\">     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">&quot;type === &#x27;section&#x27;&quot;</span>&gt;</span></span><br><span class=\"xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">item</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">&quot;item in list&quot;</span></span></span><br><span class=\"hljs-tag\"><span class=\"xml\">                      <span class=\"hljs-attr\">:data</span>=<span class=\"hljs-string\">&quot;item&quot;</span></span></span><br><span class=\"hljs-tag\"><span class=\"xml\">                      <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">&quot;item.id&quot;</span></span></span><br><span class=\"hljs-tag\"><span class=\"xml\">                    @<span class=\"hljs-attr\">click.native</span>=<span class=\"hljs-string\">&quot;handleClick(item.id)&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">item</span>&gt;</span></span><br><span class=\"xml\">            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">         <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">daily-article</span> <span class=\"hljs-attr\">:id</span>=<span class=\"hljs-string\">&quot;articleId&quot;</span> <span class=\"hljs-attr\">:type</span>=<span class=\"hljs-string\">&quot;this.type&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">daily-article</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>&lt;/div&gt;<br>&lt;/template&gt;<br><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"javascript\"><span class=\"xml\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;</span></span><br><span class=\"javascript\"><span class=\"xml\"> <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span></span><br><span class=\"javascript\"><span class=\"xml\">            <span class=\"hljs-keyword\">return</span> &#123;</span></span><br><span class=\"javascript\"><span class=\"xml\">                <span class=\"hljs-attr\">sections</span>:[],<span class=\"hljs-comment\">//保存栏目目录</span></span></span><br><span class=\"javascript\"><span class=\"xml\">                <span class=\"hljs-attr\">showSection</span>:<span class=\"hljs-literal\">false</span>,<span class=\"hljs-comment\">//是否显示所有栏目</span></span></span><br><span class=\"javascript\"><span class=\"xml\">                <span class=\"hljs-attr\">type</span>:<span class=\"hljs-string\">&#x27;recommend&#x27;</span>,</span></span><br><span class=\"javascript\"><span class=\"xml\">                <span class=\"hljs-attr\">sectionId</span>:<span class=\"hljs-number\">0</span>,<span class=\"hljs-comment\">//保存栏目id</span></span></span><br><span class=\"javascript\"><span class=\"xml\">                <span class=\"hljs-attr\">list</span>:[],<span class=\"hljs-comment\">//保存访问栏目的所有文章</span></span></span><br><span class=\"javascript\"><span class=\"xml\">                <span class=\"hljs-attr\">sectionTime</span>:<span class=\"hljs-number\">0</span>,<span class=\"hljs-comment\">//本次请求的时间戳</span></span></span><br><span class=\"javascript\"><span class=\"xml\">                           &#125;</span></span><br><span class=\"javascript\"><span class=\"xml\">        &#125;</span></span><br><span class=\"javascript\"><span class=\"xml\">    &#125;</span></span><br><span class=\"javascript\"><span class=\"xml\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n<p>定义一个method，当点击栏目时，访问栏目api，获得栏目列表，并将数据写入data中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">methods:&#123;<br>            <span class=\"hljs-function\"><span class=\"hljs-title\">getSections</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>                $.ajaxSection.get(<span class=\"hljs-string\">&#x27;sections&#x27;</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span>&#123;<br>                    <span class=\"hljs-built_in\">this</span>.sections = res.data;<br>                &#125;)<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure>\n<p>当点击具体某个栏目时，中间栏要显示该栏目的文章列表，定义一个method，当调用这哥method时，访问api，将数据写入data，DOM的改变让Vue去做</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-title\">handleToSection</span>(<span class=\"hljs-params\">id</span>)</span>&#123;<br>                <span class=\"hljs-built_in\">this</span>.type = <span class=\"hljs-string\">&#x27;section&#x27;</span>;<br>                <span class=\"hljs-built_in\">this</span>.sectionId = id;<br>                <span class=\"hljs-built_in\">this</span>.list = [];<br>                $.ajaxSection.get(<span class=\"hljs-string\">&#x27;section/&#x27;</span>+id).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span>&#123;<br>                    <span class=\"hljs-built_in\">this</span>.sectionTime = res.timestamp;<br>                    <span class=\"hljs-built_in\">this</span>.list = res.stories;<br>                &#125;)<br>            &#125;<br></code></pre></td></tr></table></figure>\n<p>为中间栏添加scroll事件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-title\">mounted</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>\t<span class=\"hljs-keyword\">const</span> $list = <span class=\"hljs-built_in\">this</span>.$refs.list;<br>\t$list.addEventListener(<span class=\"hljs-string\">&#x27;scroll&#x27;</span>,<span class=\"hljs-function\">()=&gt;</span>&#123;<br>                <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">this</span>.isloading) <span class=\"hljs-keyword\">return</span>;<br>                <span class=\"hljs-keyword\">if</span>($list.scrollTop + <span class=\"hljs-built_in\">document</span>.body.clientHeight &gt;= $list.scrollHeight-<span class=\"hljs-number\">100</span>)&#123;<br>                    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">this</span>.type === <span class=\"hljs-string\">&#x27;recommend&#x27;</span>) &#123;<br>                        <span class=\"hljs-built_in\">this</span>.dailyTime -=<span class=\"hljs-number\">86400000</span>;<br>                        <span class=\"hljs-built_in\">this</span>.getRecommendList();<br>                    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>                        <span class=\"hljs-built_in\">this</span>.getSectionList()<br>                    &#125;<br>                &#125;<br>            &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>下拉中间栏到底，自动加载更多数据</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-title\">getSectionList</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>                <span class=\"hljs-built_in\">this</span>.isloading = <span class=\"hljs-literal\">true</span>;<br>                $.ajaxSection.get(<span class=\"hljs-string\">&#x27;section/&#x27;</span> +<span class=\"hljs-built_in\">this</span>.sectionId+<span class=\"hljs-string\">`/before/<span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">this</span>.sectionTime&#125;</span>`</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span>&#123;<br>                    <span class=\"hljs-built_in\">this</span>.sectionTime= res.timestamp;<br>                    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> value <span class=\"hljs-keyword\">of</span> res.stories)&#123;<br>                        <span class=\"hljs-built_in\">this</span>.list.push(value);<br>                    &#125;<br>                    <span class=\"hljs-built_in\">this</span>.isloading=<span class=\"hljs-literal\">false</span>;<br>                &#125;)<br>            &#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"栏目文章详情组件\"><a href=\"#栏目文章详情组件\" class=\"headerlink\" title=\"栏目文章详情组件\"></a>栏目文章详情组件</h2><p>一开始只是把日报的组件拿来用，发现直接用v-html转换的页面太难看。<br><img src=\"https://img-blog.csdnimg.cn/20200327123440199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>正好栏目api提供了对应文章的知乎页面的url</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\">&#123;<br>    <span class=\"hljs-attr\">&quot;timestamp&quot;</span>: <span class=\"hljs-number\">1463148001</span>,<br>    <span class=\"hljs-attr\">&quot;stories&quot;</span>: [<br>        &#123;<br>            <span class=\"hljs-attr\">&quot;image_hue&quot;</span>: <span class=\"hljs-string\">&quot;0x3779b3&quot;</span>,<br>            <span class=\"hljs-attr\">&quot;title&quot;</span>: <span class=\"hljs-string\">&quot;深夜惊奇 · 要穿内衣&quot;</span>,<br>            <span class=\"hljs-attr\">&quot;url&quot;</span>: <span class=\"hljs-string\">&quot;https://daily.zhihu.com/story/8387524&quot;</span>,<br>            <span class=\"hljs-attr\">&quot;date&quot;</span>: <span class=\"hljs-string\">&quot;20160601&quot;</span>,<br>            <span class=\"hljs-attr\">&quot;display_date&quot;</span>: <span class=\"hljs-string\">&quot;6 月 1 日&quot;</span>,<br>            <span class=\"hljs-attr\">&quot;images&quot;</span>: [<br>                <span class=\"hljs-string\">&quot;http://pic3.zhimg.com/91125c9aebcab1c84f58ce4f8779551e.jpg&quot;</span><br>            ],<br>            <span class=\"hljs-attr\">&quot;id&quot;</span>: <span class=\"hljs-number\">8387524</span><br>        &#125;,<br></code></pre></td></tr></table></figure>\n<p>可以看到上面的stories中url就是文章对应知乎页面了，可以用一个<code>&lt;iframe&gt;</code>直接显示这个页面。但是为了尽量少动代码，还是将知乎的html源码保存下来，用v-html直接显示<br><strong>增加一个stories代理服务器</strong>，与之前类似</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//proxy.js</span><br><span class=\"hljs-keyword\">const</span> storiesServer = http.createServer(<span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> url = <span class=\"hljs-string\">&#x27;https://daily.zhihu.com/story&#x27;</span> + req.url;<br>    <span class=\"hljs-keyword\">const</span> options = &#123;<br>        <span class=\"hljs-attr\">url</span>: url<br>    &#125;;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">callback</span> (<span class=\"hljs-params\">error, response, body</span>) </span>&#123;<br>        <span class=\"hljs-comment\">//......</span><br>        &#125;<br>    &#125;<br>    request.get(options, callback);<br>&#125;);<br>storiesServer.listen(storiesPort, hostname, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`栏目故事代理运行在 http://<span class=\"hljs-subst\">$&#123;hostname&#125;</span>:<span class=\"hljs-subst\">$&#123;storiesPort&#125;</span>/`</span>)<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>相应的ajax模块</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//util.js</span><br><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;axios&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> Util = &#123;<br>   <span class=\"hljs-comment\">//...</span><br>    <span class=\"hljs-attr\">storiesPath</span>:<span class=\"hljs-string\">&#x27;http://127.0.0.1:8013/&#x27;</span><br>&#125;;<br>Util.ajaxStories = axios.create(&#123;<br>    <span class=\"hljs-attr\">baseURL</span>:Util.storiesPath<br>&#125;)<br>Util.ajaxStories.interceptors.response.use(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> res.data;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h5 id=\"daily-article组件\"><a href=\"#daily-article组件\" class=\"headerlink\" title=\"daily-article组件\"></a>daily-article组件</h5><p>props中增加一个参数type，接受父组件的信息，现在显示哪一部分，使用watch监控id与type，当他们发生改变时，调用相应方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//daily-article.vue</span><br>&lt;template&gt;<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;daily-article&quot;</span>&gt;</span></span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">&quot;this.type === &#x27;recommend&#x27;&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;daily-article-title&quot;</span>&gt;</span>&#123;&#123; data.title &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">&quot;this.type === &#x27;recommend&#x27;&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;daily-article-content&quot;</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">&quot;data.body&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">&quot;this.type === &#x27;section&#x27;&quot;</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">&quot;this.htmlData&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;daily-comments&quot;</span> <span class=\"hljs-attr\">v-show</span>=<span class=\"hljs-string\">&quot;comments.length&quot;</span>&gt;</span>         </span><br><span class=\"xml\">                <span class=\"hljs-comment\">&lt;!--...--&gt;</span></span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>&lt;/template&gt;<br>&lt;script&gt;<br>&#123;...&#125;<br><span class=\"hljs-attr\">props</span>:&#123;<br>\t <span class=\"hljs-attr\">type</span>:&#123;<br>\t                <span class=\"hljs-attr\">type</span>:<span class=\"hljs-built_in\">String</span>,<br>\t                <span class=\"hljs-attr\">default</span>:<span class=\"hljs-string\">&#x27;recommend&#x27;</span><br>\t            &#125;<br>\t        &#125;,<br>\t <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>            <span class=\"hljs-keyword\">return</span>&#123;<br>\t            <span class=\"hljs-attr\">htmlData</span>:<span class=\"hljs-string\">&#x27;&#x27;</span><br>\t            &#125;<br>        &#125;,<br>        <span class=\"hljs-attr\">watch</span>:&#123;<br>            <span class=\"hljs-function\"><span class=\"hljs-title\">type</span>(<span class=\"hljs-params\">val</span>)</span>&#123;<span class=\"hljs-comment\">//类型发生变化，清空数据</span><br>                <span class=\"hljs-built_in\">this</span>.data=&#123;&#125;,<br>                <span class=\"hljs-built_in\">this</span>.comments=[],<br>                <span class=\"hljs-built_in\">this</span>.htmlData=<span class=\"hljs-string\">&#x27;&#x27;</span><br>            &#125;,<br>            <span class=\"hljs-function\"><span class=\"hljs-title\">id</span>(<span class=\"hljs-params\">val</span>)</span>&#123;<span class=\"hljs-comment\">//文章id变化，更新文章数据</span><br>                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.type===<span class=\"hljs-string\">&#x27;recommend&#x27;</span>&amp;&amp;val) &#123;<br>                    <span class=\"hljs-built_in\">this</span>.getArticle();<br>                &#125;<span class=\"hljs-keyword\">else</span> &#123;<br>                    <span class=\"hljs-built_in\">this</span>.getStores()<br>                &#125;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-title\">getStores</span>(<span class=\"hljs-params\"></span>)</span>&#123;<span class=\"hljs-comment\">//获得html源码，将里面的图片换成代理地址</span><br>              $.ajaxStories.get(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">this</span>.id&#125;</span>`</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span>&#123;<br>                  res =res.replace(<span class=\"hljs-regexp\">/src=&quot;http/g</span>,<span class=\"hljs-string\">&#x27;src=&quot;&#x27;</span> + $.imgPath+<span class=\"hljs-string\">&#x27;http&#x27;</span>);<br>                  res =res.replace(<span class=\"hljs-regexp\">/src=&quot;https/g</span>,<span class=\"hljs-string\">&#x27;src=&quot;&#x27;</span> + $.imgPath + <span class=\"hljs-string\">&#x27;https&#x27;</span>);<br>                   <span class=\"hljs-built_in\">this</span>.htmlData = res;<br>                    <span class=\"hljs-built_in\">this</span>.getComments();<br>              &#125;)<br>            &#125;<br></code></pre></td></tr></table></figure>\n<p>本以为大功告成了，打开网页发现并没有显示文章，上来就是评论<br><img src=\"https://img-blog.csdnimg.cn/2020032712353950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>打开控制台看到<br><img src=\"https://img-blog.csdnimg.cn/20200327123608340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>看起来好像是css文件被跨域限制了，无法引用。那就用之前图片的代理服务器转发一下就好了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//daily-article.vue</span><br><span class=\"hljs-attr\">methods</span>:&#123;<br>            <span class=\"hljs-function\"><span class=\"hljs-title\">getStores</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>              $.ajaxStories.get(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">this</span>.id&#125;</span>`</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span>&#123;<br>              res =res.replace(<span class=\"hljs-regexp\">/href=&quot;http/g</span>,<span class=\"hljs-string\">&#x27;href=&quot;&#x27;</span> + $.imgPath+<span class=\"hljs-string\">&#x27;http&#x27;</span>);<br>              res =res.replace(<span class=\"hljs-regexp\">/href=&quot;https/g</span>,<span class=\"hljs-string\">&#x27;href=&quot;&#x27;</span> + $.imgPath + <span class=\"hljs-string\">&#x27;https&#x27;</span>);<br>&#125;)<br>            &#125;<br></code></pre></td></tr></table></figure>\n<p>再打开网页，确实没问题了，但是这个知乎app的提醒很烦，把它去掉。<br><img src=\"https://img-blog.csdnimg.cn/20200327124025380.png#pic_center\" alt=\"在这里插入图片描述\"><br>在html里找他的类名，在后面加上display：none</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//daily-article.vue</span><br><span class=\"hljs-attr\">methods</span>:&#123;<br>            <span class=\"hljs-function\"><span class=\"hljs-title\">getStores</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>              $.ajaxStories.get(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">this</span>.id&#125;</span>`</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span>&#123;<br>              res =res.replace(<span class=\"hljs-regexp\">/ZhihuDailyOIABanner&quot;/</span>,<span class=\"hljs-string\">&#x27;ZhihuDailyOIABanner&quot; style=&quot;display:none;&quot;&#x27;</span>)<br>              &#125;)<br>            &#125;<br></code></pre></td></tr></table></figure>\n<p>完工</p>\n","site":{"data":{}},"wordcount":8614,"excerpt":"","more":"<p>因为书中的代码比较久远，许多接口、webpack配置都已更新，但这个项目还是很好玩的，本文的代码都是相对于原书代码的补充。<br>完整代码:<a href=\"https://github.com/RichDavidMu/zhihuDaily\">https://github.com/RichDavidMu/zhihuDaily</a></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200326213059175.gif#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"webpack配置\"><a href=\"#webpack配置\" class=\"headerlink\" title=\"webpack配置\"></a>webpack配置</h2><p>虽然最新的webpack已经是4.0版本。但与书中的webpack2大多能兼容，只有几个地方稍有变化</p>\n<h6 id=\"vue-loader\"><a href=\"#vue-loader\" class=\"headerlink\" title=\"vue-loader\"></a>vue-loader</h6><p><a href=\"mailto:&#x76;&#x75;&#101;&#45;&#108;&#x6f;&#97;&#100;&#101;&#x72;&#x40;&#x31;&#53;&#x2e;&#120;\">&#x76;&#x75;&#101;&#45;&#108;&#x6f;&#97;&#100;&#101;&#x72;&#x40;&#x31;&#53;&#x2e;&#120;</a> 版本相较之前需要增加一些配置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//webpack.config.js</span><br><span class=\"hljs-keyword\">const</span> VueLoaderPlugin = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;vue-loader/lib/plugin&#x27;</span>);<br>&#123;...&#125;<br>\t<span class=\"hljs-attr\">plugins</span>:[<span class=\"hljs-keyword\">new</span> VueLoaderPlugin()]<br>&#123;...&#125;<br></code></pre></td></tr></table></figure>\n<h6 id=\"mini-css-extract-plugin\"><a href=\"#mini-css-extract-plugin\" class=\"headerlink\" title=\"mini-css-extract-plugin\"></a>mini-css-extract-plugin</h6><p>webpack4中建议使用mini-css-extract-plugin，而不是extract-text-webpack-plugin。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//webpack.config.js</span><br><span class=\"hljs-keyword\">const</span> MiniCssExtractPlugin = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;mini-css-extract-plugin&quot;</span>);<br>&#123;...&#125;<br>&#123;<br>   <span class=\"hljs-attr\">test</span>:<span class=\"hljs-regexp\">/\\.css$/</span>,<br>    use:[<br>        &#123;<br>            <span class=\"hljs-attr\">loader</span>: MiniCssExtractPlugin.loader<br>        &#125;,<br>        <span class=\"hljs-string\">&#x27;css-loader&#x27;</span><br>    ]<br>&#125;<br>&#123;...&#125;<br><span class=\"hljs-keyword\">new</span> MiniCssExtractPlugin(&#123;<br>            <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">&quot;[name].css&quot;</span>,<br>            <span class=\"hljs-attr\">chunkFilename</span>: <span class=\"hljs-string\">&quot;[id].css&quot;</span><br>        &#125;)<br></code></pre></td></tr></table></figure>\n<h6 id=\"遇到的一个坑\"><a href=\"#遇到的一个坑\" class=\"headerlink\" title=\"遇到的一个坑\"></a>遇到的一个坑</h6><p>因为这是一个单页应用，所以在写css的时候，我把他们全部写在app.vue文件中，这样在打包的时候，会自动的在打包后样式中加上属性选择器，就像这样</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.daily-item</span><span class=\"hljs-selector-attr\">[data-v-186c01a3]</span><span class=\"hljs-selector-pseudo\">:hover</span>&#123;<br>    <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-number\">#e3e8ee</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>然后坑来了，因为用的html-webpack-plugin自动生成html文件，而他的模板文件中的body、html元素不会自动生成相应的属性，打开控制台看一下Element<br><img src=\"https://img-blog.csdnimg.cn/20200326220121432.png\" alt=\"在这里插入图片描述\"><br>可以看到body，html元素均没有属性选择器，而写在vue文件的元素有，这样，我们在app.vue中的有关<code>&lt;html&gt;&lt;body&gt;</code>的样式均无法生效。<br>解决：新建一个style.css文件，在main.js中引用，将body、html的样式写在里面，这样打包后的样式不会被加上属性选择器。</p>\n<h2 id=\"热门栏目功能\"><a href=\"#热门栏目功能\" class=\"headerlink\" title=\"热门栏目功能\"></a>热门栏目功能</h2><p>因为书中的主题日报所用的api已经无效，看了一下这篇文章 <a href=\"https://blog.csdn.net/fanpeihua123/article/details/51210499\">日报 API 分析</a>，使用postman把里面的接口都试了一下，发现栏目的api可用，虽然是内容已经停止更新了，但作为练习的话，影响不大。<br><strong>首先建立一个section的代理服务器</strong>，用来转发数据，解决跨域限制</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//proxy.js</span><br><span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;http&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> request = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;request&#x27;</span>);<br><br><span class=\"hljs-keyword\">const</span> hostname = <span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>;<br><span class=\"hljs-keyword\">const</span> sectionPort= <span class=\"hljs-number\">8012</span>;<br><span class=\"hljs-keyword\">const</span> sectionServer = http.createServer(<span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> url = <span class=\"hljs-string\">&#x27;http://news-at.zhihu.com/api/3&#x27;</span> + req.url;<br>    <span class=\"hljs-keyword\">const</span> options = &#123;<br>        <span class=\"hljs-attr\">url</span>: url<br>    &#125;;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">callback</span> (<span class=\"hljs-params\">error, response, body</span>) </span>&#123;<br>        <span class=\"hljs-keyword\">if</span> (!error &amp;&amp; response.statusCode === <span class=\"hljs-number\">200</span>) &#123;<br>            <span class=\"hljs-comment\">// 设置编码类型，否则中文会显示为乱码</span><br>            res.setHeader(<span class=\"hljs-string\">&#x27;Content-Type&#x27;</span>, <span class=\"hljs-string\">&#x27;text/plain;charset=UTF-8&#x27;</span>);<br>            <span class=\"hljs-comment\">// 设置所有域允许跨域</span><br>            res.setHeader(<span class=\"hljs-string\">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class=\"hljs-string\">&#x27;*&#x27;</span>);<br>            <span class=\"hljs-comment\">// 返回代理后的内容</span><br>            res.end(body);<br>        &#125;<br>    &#125;<br>    request.get(options, callback);<br>&#125;);<br>sectionServer.listen(sectionPort, hostname, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`栏目代理运行在 http://<span class=\"hljs-subst\">$&#123;hostname&#125;</span>:<span class=\"hljs-subst\">$&#123;sectionPort&#125;</span>/`</span>)<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p><strong>增加相应的ajax模块</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//util.js</span><br><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;axios&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> Util = &#123;<br>    <span class=\"hljs-attr\">sectionPath</span>:<span class=\"hljs-string\">&#x27;http://127.0.0.1:8012/&#x27;</span><br>&#125;;<br><span class=\"hljs-comment\">// Ajax 通用配置</span><br>Util.ajaxSection = axios.create(&#123;<br>    <span class=\"hljs-attr\">baseURL</span>: Util.sectionPath<br>&#125;);<br><span class=\"hljs-comment\">// 添加响应拦截器</span><br>Util.ajaxStories.interceptors.response.use(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> res.data;<br>&#125;);<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> Util;<br></code></pre></td></tr></table></figure>\n<p>写上栏目的html结构，在data中加入我们需要维护的数据</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//app.vue</span><br>&lt;template&gt;<br><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;daily&quot;</span>&gt;</span></span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;daily-menu&quot;</span>&gt;</span></span><br><span class=\"xml\">        ...</span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;daily-menu-item&quot;</span></span></span><br><span class=\"hljs-tag\"><span class=\"xml\">            <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">&quot;&#123;on:type===&#x27;section&#x27;&#125;&quot;</span></span></span><br><span class=\"hljs-tag\"><span class=\"xml\">            @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">&quot;showSection = !showSection&quot;</span>&gt;</span>热门栏目<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">v-show</span>=<span class=\"hljs-string\">&quot;showSection&quot;</span>&gt;</span></span><br><span class=\"xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">&quot;item in sections&quot;</span>&gt;</span></span><br><span class=\"xml\">                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">&quot;&#123;on: item.id === sectionId &amp;&amp; type === &#x27;section&#x27;&#125;&quot;</span></span></span><br><span class=\"hljs-tag\"><span class=\"xml\">                    @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">&quot;handleToSection(item.id)&quot;</span>&gt;</span>&#123;&#123; item.name&#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></span><br><span class=\"xml\">                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></span><br><span class=\"xml\">            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;daily-list&quot;</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">&quot;list&quot;</span>&gt;</span></span><br><span class=\"xml\">     ...</span><br><span class=\"xml\">     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">&quot;type === &#x27;section&#x27;&quot;</span>&gt;</span></span><br><span class=\"xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">item</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">&quot;item in list&quot;</span></span></span><br><span class=\"hljs-tag\"><span class=\"xml\">                      <span class=\"hljs-attr\">:data</span>=<span class=\"hljs-string\">&quot;item&quot;</span></span></span><br><span class=\"hljs-tag\"><span class=\"xml\">                      <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">&quot;item.id&quot;</span></span></span><br><span class=\"hljs-tag\"><span class=\"xml\">                    @<span class=\"hljs-attr\">click.native</span>=<span class=\"hljs-string\">&quot;handleClick(item.id)&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">item</span>&gt;</span></span><br><span class=\"xml\">            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">         <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">daily-article</span> <span class=\"hljs-attr\">:id</span>=<span class=\"hljs-string\">&quot;articleId&quot;</span> <span class=\"hljs-attr\">:type</span>=<span class=\"hljs-string\">&quot;this.type&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">daily-article</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>&lt;/div&gt;<br>&lt;/template&gt;<br><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"javascript\"><span class=\"xml\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;</span></span><br><span class=\"javascript\"><span class=\"xml\"> <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span>&#123;</span></span><br><span class=\"javascript\"><span class=\"xml\">            <span class=\"hljs-keyword\">return</span> &#123;</span></span><br><span class=\"javascript\"><span class=\"xml\">                <span class=\"hljs-attr\">sections</span>:[],<span class=\"hljs-comment\">//保存栏目目录</span></span></span><br><span class=\"javascript\"><span class=\"xml\">                <span class=\"hljs-attr\">showSection</span>:<span class=\"hljs-literal\">false</span>,<span class=\"hljs-comment\">//是否显示所有栏目</span></span></span><br><span class=\"javascript\"><span class=\"xml\">                <span class=\"hljs-attr\">type</span>:<span class=\"hljs-string\">&#x27;recommend&#x27;</span>,</span></span><br><span class=\"javascript\"><span class=\"xml\">                <span class=\"hljs-attr\">sectionId</span>:<span class=\"hljs-number\">0</span>,<span class=\"hljs-comment\">//保存栏目id</span></span></span><br><span class=\"javascript\"><span class=\"xml\">                <span class=\"hljs-attr\">list</span>:[],<span class=\"hljs-comment\">//保存访问栏目的所有文章</span></span></span><br><span class=\"javascript\"><span class=\"xml\">                <span class=\"hljs-attr\">sectionTime</span>:<span class=\"hljs-number\">0</span>,<span class=\"hljs-comment\">//本次请求的时间戳</span></span></span><br><span class=\"javascript\"><span class=\"xml\">                           &#125;</span></span><br><span class=\"javascript\"><span class=\"xml\">        &#125;</span></span><br><span class=\"javascript\"><span class=\"xml\">    &#125;</span></span><br><span class=\"javascript\"><span class=\"xml\">        </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n<p>定义一个method，当点击栏目时，访问栏目api，获得栏目列表，并将数据写入data中</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">methods:&#123;<br>            <span class=\"hljs-function\"><span class=\"hljs-title\">getSections</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>                $.ajaxSection.get(<span class=\"hljs-string\">&#x27;sections&#x27;</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span>&#123;<br>                    <span class=\"hljs-built_in\">this</span>.sections = res.data;<br>                &#125;)<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure>\n<p>当点击具体某个栏目时，中间栏要显示该栏目的文章列表，定义一个method，当调用这哥method时，访问api，将数据写入data，DOM的改变让Vue去做</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-title\">handleToSection</span>(<span class=\"hljs-params\">id</span>)</span>&#123;<br>                <span class=\"hljs-built_in\">this</span>.type = <span class=\"hljs-string\">&#x27;section&#x27;</span>;<br>                <span class=\"hljs-built_in\">this</span>.sectionId = id;<br>                <span class=\"hljs-built_in\">this</span>.list = [];<br>                $.ajaxSection.get(<span class=\"hljs-string\">&#x27;section/&#x27;</span>+id).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span>&#123;<br>                    <span class=\"hljs-built_in\">this</span>.sectionTime = res.timestamp;<br>                    <span class=\"hljs-built_in\">this</span>.list = res.stories;<br>                &#125;)<br>            &#125;<br></code></pre></td></tr></table></figure>\n<p>为中间栏添加scroll事件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-title\">mounted</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>\t<span class=\"hljs-keyword\">const</span> $list = <span class=\"hljs-built_in\">this</span>.$refs.list;<br>\t$list.addEventListener(<span class=\"hljs-string\">&#x27;scroll&#x27;</span>,<span class=\"hljs-function\">()=&gt;</span>&#123;<br>                <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">this</span>.isloading) <span class=\"hljs-keyword\">return</span>;<br>                <span class=\"hljs-keyword\">if</span>($list.scrollTop + <span class=\"hljs-built_in\">document</span>.body.clientHeight &gt;= $list.scrollHeight-<span class=\"hljs-number\">100</span>)&#123;<br>                    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">this</span>.type === <span class=\"hljs-string\">&#x27;recommend&#x27;</span>) &#123;<br>                        <span class=\"hljs-built_in\">this</span>.dailyTime -=<span class=\"hljs-number\">86400000</span>;<br>                        <span class=\"hljs-built_in\">this</span>.getRecommendList();<br>                    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>                        <span class=\"hljs-built_in\">this</span>.getSectionList()<br>                    &#125;<br>                &#125;<br>            &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>下拉中间栏到底，自动加载更多数据</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-title\">getSectionList</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>                <span class=\"hljs-built_in\">this</span>.isloading = <span class=\"hljs-literal\">true</span>;<br>                $.ajaxSection.get(<span class=\"hljs-string\">&#x27;section/&#x27;</span> +<span class=\"hljs-built_in\">this</span>.sectionId+<span class=\"hljs-string\">`/before/<span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">this</span>.sectionTime&#125;</span>`</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span>&#123;<br>                    <span class=\"hljs-built_in\">this</span>.sectionTime= res.timestamp;<br>                    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> value <span class=\"hljs-keyword\">of</span> res.stories)&#123;<br>                        <span class=\"hljs-built_in\">this</span>.list.push(value);<br>                    &#125;<br>                    <span class=\"hljs-built_in\">this</span>.isloading=<span class=\"hljs-literal\">false</span>;<br>                &#125;)<br>            &#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"栏目文章详情组件\"><a href=\"#栏目文章详情组件\" class=\"headerlink\" title=\"栏目文章详情组件\"></a>栏目文章详情组件</h2><p>一开始只是把日报的组件拿来用，发现直接用v-html转换的页面太难看。<br><img src=\"https://img-blog.csdnimg.cn/20200327123440199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>正好栏目api提供了对应文章的知乎页面的url</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\">&#123;<br>    <span class=\"hljs-attr\">&quot;timestamp&quot;</span>: <span class=\"hljs-number\">1463148001</span>,<br>    <span class=\"hljs-attr\">&quot;stories&quot;</span>: [<br>        &#123;<br>            <span class=\"hljs-attr\">&quot;image_hue&quot;</span>: <span class=\"hljs-string\">&quot;0x3779b3&quot;</span>,<br>            <span class=\"hljs-attr\">&quot;title&quot;</span>: <span class=\"hljs-string\">&quot;深夜惊奇 · 要穿内衣&quot;</span>,<br>            <span class=\"hljs-attr\">&quot;url&quot;</span>: <span class=\"hljs-string\">&quot;https://daily.zhihu.com/story/8387524&quot;</span>,<br>            <span class=\"hljs-attr\">&quot;date&quot;</span>: <span class=\"hljs-string\">&quot;20160601&quot;</span>,<br>            <span class=\"hljs-attr\">&quot;display_date&quot;</span>: <span class=\"hljs-string\">&quot;6 月 1 日&quot;</span>,<br>            <span class=\"hljs-attr\">&quot;images&quot;</span>: [<br>                <span class=\"hljs-string\">&quot;http://pic3.zhimg.com/91125c9aebcab1c84f58ce4f8779551e.jpg&quot;</span><br>            ],<br>            <span class=\"hljs-attr\">&quot;id&quot;</span>: <span class=\"hljs-number\">8387524</span><br>        &#125;,<br></code></pre></td></tr></table></figure>\n<p>可以看到上面的stories中url就是文章对应知乎页面了，可以用一个<code>&lt;iframe&gt;</code>直接显示这个页面。但是为了尽量少动代码，还是将知乎的html源码保存下来，用v-html直接显示<br><strong>增加一个stories代理服务器</strong>，与之前类似</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//proxy.js</span><br><span class=\"hljs-keyword\">const</span> storiesServer = http.createServer(<span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> url = <span class=\"hljs-string\">&#x27;https://daily.zhihu.com/story&#x27;</span> + req.url;<br>    <span class=\"hljs-keyword\">const</span> options = &#123;<br>        <span class=\"hljs-attr\">url</span>: url<br>    &#125;;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">callback</span> (<span class=\"hljs-params\">error, response, body</span>) </span>&#123;<br>        <span class=\"hljs-comment\">//......</span><br>        &#125;<br>    &#125;<br>    request.get(options, callback);<br>&#125;);<br>storiesServer.listen(storiesPort, hostname, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`栏目故事代理运行在 http://<span class=\"hljs-subst\">$&#123;hostname&#125;</span>:<span class=\"hljs-subst\">$&#123;storiesPort&#125;</span>/`</span>)<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>相应的ajax模块</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//util.js</span><br><span class=\"hljs-keyword\">import</span> axios <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;axios&#x27;</span>;<br><br><span class=\"hljs-keyword\">const</span> Util = &#123;<br>   <span class=\"hljs-comment\">//...</span><br>    <span class=\"hljs-attr\">storiesPath</span>:<span class=\"hljs-string\">&#x27;http://127.0.0.1:8013/&#x27;</span><br>&#125;;<br>Util.ajaxStories = axios.create(&#123;<br>    <span class=\"hljs-attr\">baseURL</span>:Util.storiesPath<br>&#125;)<br>Util.ajaxStories.interceptors.response.use(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> res.data;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h5 id=\"daily-article组件\"><a href=\"#daily-article组件\" class=\"headerlink\" title=\"daily-article组件\"></a>daily-article组件</h5><p>props中增加一个参数type，接受父组件的信息，现在显示哪一部分，使用watch监控id与type，当他们发生改变时，调用相应方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//daily-article.vue</span><br>&lt;template&gt;<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;daily-article&quot;</span>&gt;</span></span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">&quot;this.type === &#x27;recommend&#x27;&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;daily-article-title&quot;</span>&gt;</span>&#123;&#123; data.title &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">&quot;this.type === &#x27;recommend&#x27;&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;daily-article-content&quot;</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">&quot;data.body&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">&quot;this.type === &#x27;section&#x27;&quot;</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">&quot;this.htmlData&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;daily-comments&quot;</span> <span class=\"hljs-attr\">v-show</span>=<span class=\"hljs-string\">&quot;comments.length&quot;</span>&gt;</span>         </span><br><span class=\"xml\">                <span class=\"hljs-comment\">&lt;!--...--&gt;</span></span><br><span class=\"xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>&lt;/template&gt;<br>&lt;script&gt;<br>&#123;...&#125;<br><span class=\"hljs-attr\">props</span>:&#123;<br>\t <span class=\"hljs-attr\">type</span>:&#123;<br>\t                <span class=\"hljs-attr\">type</span>:<span class=\"hljs-built_in\">String</span>,<br>\t                <span class=\"hljs-attr\">default</span>:<span class=\"hljs-string\">&#x27;recommend&#x27;</span><br>\t            &#125;<br>\t        &#125;,<br>\t <span class=\"hljs-function\"><span class=\"hljs-title\">data</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>            <span class=\"hljs-keyword\">return</span>&#123;<br>\t            <span class=\"hljs-attr\">htmlData</span>:<span class=\"hljs-string\">&#x27;&#x27;</span><br>\t            &#125;<br>        &#125;,<br>        <span class=\"hljs-attr\">watch</span>:&#123;<br>            <span class=\"hljs-function\"><span class=\"hljs-title\">type</span>(<span class=\"hljs-params\">val</span>)</span>&#123;<span class=\"hljs-comment\">//类型发生变化，清空数据</span><br>                <span class=\"hljs-built_in\">this</span>.data=&#123;&#125;,<br>                <span class=\"hljs-built_in\">this</span>.comments=[],<br>                <span class=\"hljs-built_in\">this</span>.htmlData=<span class=\"hljs-string\">&#x27;&#x27;</span><br>            &#125;,<br>            <span class=\"hljs-function\"><span class=\"hljs-title\">id</span>(<span class=\"hljs-params\">val</span>)</span>&#123;<span class=\"hljs-comment\">//文章id变化，更新文章数据</span><br>                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.type===<span class=\"hljs-string\">&#x27;recommend&#x27;</span>&amp;&amp;val) &#123;<br>                    <span class=\"hljs-built_in\">this</span>.getArticle();<br>                &#125;<span class=\"hljs-keyword\">else</span> &#123;<br>                    <span class=\"hljs-built_in\">this</span>.getStores()<br>                &#125;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-title\">getStores</span>(<span class=\"hljs-params\"></span>)</span>&#123;<span class=\"hljs-comment\">//获得html源码，将里面的图片换成代理地址</span><br>              $.ajaxStories.get(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">this</span>.id&#125;</span>`</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span>&#123;<br>                  res =res.replace(<span class=\"hljs-regexp\">/src=&quot;http/g</span>,<span class=\"hljs-string\">&#x27;src=&quot;&#x27;</span> + $.imgPath+<span class=\"hljs-string\">&#x27;http&#x27;</span>);<br>                  res =res.replace(<span class=\"hljs-regexp\">/src=&quot;https/g</span>,<span class=\"hljs-string\">&#x27;src=&quot;&#x27;</span> + $.imgPath + <span class=\"hljs-string\">&#x27;https&#x27;</span>);<br>                   <span class=\"hljs-built_in\">this</span>.htmlData = res;<br>                    <span class=\"hljs-built_in\">this</span>.getComments();<br>              &#125;)<br>            &#125;<br></code></pre></td></tr></table></figure>\n<p>本以为大功告成了，打开网页发现并没有显示文章，上来就是评论<br><img src=\"https://img-blog.csdnimg.cn/2020032712353950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>打开控制台看到<br><img src=\"https://img-blog.csdnimg.cn/20200327123608340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>看起来好像是css文件被跨域限制了，无法引用。那就用之前图片的代理服务器转发一下就好了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//daily-article.vue</span><br><span class=\"hljs-attr\">methods</span>:&#123;<br>            <span class=\"hljs-function\"><span class=\"hljs-title\">getStores</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>              $.ajaxStories.get(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">this</span>.id&#125;</span>`</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span>&#123;<br>              res =res.replace(<span class=\"hljs-regexp\">/href=&quot;http/g</span>,<span class=\"hljs-string\">&#x27;href=&quot;&#x27;</span> + $.imgPath+<span class=\"hljs-string\">&#x27;http&#x27;</span>);<br>              res =res.replace(<span class=\"hljs-regexp\">/href=&quot;https/g</span>,<span class=\"hljs-string\">&#x27;href=&quot;&#x27;</span> + $.imgPath + <span class=\"hljs-string\">&#x27;https&#x27;</span>);<br>&#125;)<br>            &#125;<br></code></pre></td></tr></table></figure>\n<p>再打开网页，确实没问题了，但是这个知乎app的提醒很烦，把它去掉。<br><img src=\"https://img-blog.csdnimg.cn/20200327124025380.png#pic_center\" alt=\"在这里插入图片描述\"><br>在html里找他的类名，在后面加上display：none</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">//daily-article.vue</span><br><span class=\"hljs-attr\">methods</span>:&#123;<br>            <span class=\"hljs-function\"><span class=\"hljs-title\">getStores</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>              $.ajaxStories.get(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">this</span>.id&#125;</span>`</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span>=&gt;</span>&#123;<br>              res =res.replace(<span class=\"hljs-regexp\">/ZhihuDailyOIABanner&quot;/</span>,<span class=\"hljs-string\">&#x27;ZhihuDailyOIABanner&quot; style=&quot;display:none;&quot;&#x27;</span>)<br>              &#125;)<br>            &#125;<br></code></pre></td></tr></table></figure>\n<p>完工</p>\n"},{"title":"踩坑日记：防盗链与x-tengine-error:denied by Referer ACL","date":"2020-03-28T15:14:16.000Z","index_img":"/img/blogCovers/blog-post5.jpg","_content":"## 踩坑\n之前的写的知乎日报项目[https://blog.csdn.net/johnny_mu/article/details/105128678](https://blog.csdn.net/johnny_mu/article/details/105128678)\n\n客户端曾爆出了这个403错误\n\n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200328193008768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70#pic_center)\n> 看起来好像是css文件被跨域限制了，无法引用。那就用之前图片的代理服务器转发一下就好了。\n\n我一开始以为是跨域限制导致的css文件无法加载，所以用代理服务器转发一下，设置上相应header字段就好，问题确实就解决了。\n但是昨晚睡前一想，不对啊，css，图片等静态资源是不会被跨域限制的。于是我试了一下真正跨域限制的报错。果然不一样。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200328193649824.png)\n再试一下，将图片代理服务器中的取消跨域限制的代码注释掉\n\n```javascript\n\t\t\tres.setHeader('Content-Type', contentType);\n            // res.setHeader('Access-Control-Allow-Origin', '*');\n            res.end(body);\n```\n重新打开网页，没有任何变化，完美运行。\n说明之前的bug不是因为跨域产生的，那是因为什么呢。\n打开控制台看一下请求这个css文件时的network，发现了问题\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200328194744609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n在回复头字段里多了一个`x-tengine-error`，这是什么鬼，百度了一下，明白了，这是因为防盗链检测所出现的`error`\n## 防盗链\n具体可以看这篇文章 [什么是防盗链](https://www.jianshu.com/p/0a1338db6cab)\n\n我简单说一下\n\n首先有一个问题，B站点作为一个商业网站，有很多自主版权的图片，自身展示用于商业目的。而A站点，希望在自己的网站上面也展示这些图片，直接使用：\n\n```javascript\n<img src=\"http://b.com/photo.jpg\"/>\n```\n\n这样，大量的客户端在访问A站点时，实际上消耗了B站点的流量，而A站点却从中达成商业目的。从而不劳而获。这样的A站点着实令B站点不快的。\n\n这种行为又叫做盗链（那我岂不也是盗链者了QAQ）\n\n如何解决这个问题呢？服务端利用了客户端的一个特性\n\n客户端在加载非本站的资源时，会在头字段加上`Referer:`字段，用来告诉服务端，这个请求是来自哪里。\n回头看一眼我们的network\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200328200214620.png)\n确实是这样。\n\n那我们可以推断，知乎服务器利用是否有referer字段来判断是否为盗链行为，如果是，那么返回403错误，与`x-tengine-error: denied by Referer ACL`字段。\n\n而我们用代理服务器转发静态资源请求，代理服务器不会无端加上referer字段，相当于变相绕过了知乎服务器的盗链限制。\n\n## 出坑\n\n验证一下，让代理服务器发送请求时带上`referer`字段，将request模块设置为调试模式\n\n\n\n```javascript\nconst imgServer = http.createServer((req, res) => {\n    const url = req.url.split('/img/')[1];\n    const options = {\n        url: url,\n        encoding: null,\n        headers: {\n            \"Referer\": \"http://localhost:8080/\",\n        }\n    };\n\n    function callback (error, response, body) {\n        if(error) console.log(error);\n        if (!error && response.statusCode === 200) {\n            const contentType = response.headers['content-type'];\n            res.setHeader('Content-Type', contentType);\n            // res.setHeader('Access-Control-Allow-Origin', '*');\n            res.end(body);\n        }\n    }\n    request.get(options, callback);\n});\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020032820280853.png)\n看到控制台输出\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200328202537488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n踩坑结束。","source":"_posts/vue实战踩坑-防盗链.md","raw":"---\ntitle: 踩坑日记：防盗链与x-tengine-error:denied by Referer ACL\ndate: 2020-03-28 23:14:16\nindex_img: /img/blogCovers/blog-post5.jpg\ntags: [JavaScript, http, NodeJs]\ncategories: [项目实战]\n---\n## 踩坑\n之前的写的知乎日报项目[https://blog.csdn.net/johnny_mu/article/details/105128678](https://blog.csdn.net/johnny_mu/article/details/105128678)\n\n客户端曾爆出了这个403错误\n\n> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200328193008768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70#pic_center)\n> 看起来好像是css文件被跨域限制了，无法引用。那就用之前图片的代理服务器转发一下就好了。\n\n我一开始以为是跨域限制导致的css文件无法加载，所以用代理服务器转发一下，设置上相应header字段就好，问题确实就解决了。\n但是昨晚睡前一想，不对啊，css，图片等静态资源是不会被跨域限制的。于是我试了一下真正跨域限制的报错。果然不一样。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200328193649824.png)\n再试一下，将图片代理服务器中的取消跨域限制的代码注释掉\n\n```javascript\n\t\t\tres.setHeader('Content-Type', contentType);\n            // res.setHeader('Access-Control-Allow-Origin', '*');\n            res.end(body);\n```\n重新打开网页，没有任何变化，完美运行。\n说明之前的bug不是因为跨域产生的，那是因为什么呢。\n打开控制台看一下请求这个css文件时的network，发现了问题\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200328194744609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n在回复头字段里多了一个`x-tengine-error`，这是什么鬼，百度了一下，明白了，这是因为防盗链检测所出现的`error`\n## 防盗链\n具体可以看这篇文章 [什么是防盗链](https://www.jianshu.com/p/0a1338db6cab)\n\n我简单说一下\n\n首先有一个问题，B站点作为一个商业网站，有很多自主版权的图片，自身展示用于商业目的。而A站点，希望在自己的网站上面也展示这些图片，直接使用：\n\n```javascript\n<img src=\"http://b.com/photo.jpg\"/>\n```\n\n这样，大量的客户端在访问A站点时，实际上消耗了B站点的流量，而A站点却从中达成商业目的。从而不劳而获。这样的A站点着实令B站点不快的。\n\n这种行为又叫做盗链（那我岂不也是盗链者了QAQ）\n\n如何解决这个问题呢？服务端利用了客户端的一个特性\n\n客户端在加载非本站的资源时，会在头字段加上`Referer:`字段，用来告诉服务端，这个请求是来自哪里。\n回头看一眼我们的network\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200328200214620.png)\n确实是这样。\n\n那我们可以推断，知乎服务器利用是否有referer字段来判断是否为盗链行为，如果是，那么返回403错误，与`x-tengine-error: denied by Referer ACL`字段。\n\n而我们用代理服务器转发静态资源请求，代理服务器不会无端加上referer字段，相当于变相绕过了知乎服务器的盗链限制。\n\n## 出坑\n\n验证一下，让代理服务器发送请求时带上`referer`字段，将request模块设置为调试模式\n\n\n\n```javascript\nconst imgServer = http.createServer((req, res) => {\n    const url = req.url.split('/img/')[1];\n    const options = {\n        url: url,\n        encoding: null,\n        headers: {\n            \"Referer\": \"http://localhost:8080/\",\n        }\n    };\n\n    function callback (error, response, body) {\n        if(error) console.log(error);\n        if (!error && response.statusCode === 200) {\n            const contentType = response.headers['content-type'];\n            res.setHeader('Content-Type', contentType);\n            // res.setHeader('Access-Control-Allow-Origin', '*');\n            res.end(body);\n        }\n    }\n    request.get(options, callback);\n});\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020032820280853.png)\n看到控制台输出\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200328202537488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n踩坑结束。","slug":"vue实战踩坑-防盗链","published":1,"updated":"2022-01-10T08:41:39.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckyo4lu6z0010nz6937uzel7u","content":"<h2 id=\"踩坑\"><a href=\"#踩坑\" class=\"headerlink\" title=\"踩坑\"></a>踩坑</h2><p>之前的写的知乎日报项目<a href=\"https://blog.csdn.net/johnny_mu/article/details/105128678\">https://blog.csdn.net/johnny_mu/article/details/105128678</a></p>\n<p>客户端曾爆出了这个403错误</p>\n<blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20200328193008768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>看起来好像是css文件被跨域限制了，无法引用。那就用之前图片的代理服务器转发一下就好了。</p>\n</blockquote>\n<p>我一开始以为是跨域限制导致的css文件无法加载，所以用代理服务器转发一下，设置上相应header字段就好，问题确实就解决了。<br>但是昨晚睡前一想，不对啊，css，图片等静态资源是不会被跨域限制的。于是我试了一下真正跨域限制的报错。果然不一样。<br><img src=\"https://img-blog.csdnimg.cn/20200328193649824.png\" alt=\"在这里插入图片描述\"><br>再试一下，将图片代理服务器中的取消跨域限制的代码注释掉</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">res.setHeader(<span class=\"hljs-string\">&#x27;Content-Type&#x27;</span>, contentType);<br>         <span class=\"hljs-comment\">// res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);</span><br>         res.end(body);<br></code></pre></td></tr></table></figure>\n<p>重新打开网页，没有任何变化，完美运行。<br>说明之前的bug不是因为跨域产生的，那是因为什么呢。<br>打开控制台看一下请求这个css文件时的network，发现了问题<br><img src=\"https://img-blog.csdnimg.cn/20200328194744609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>在回复头字段里多了一个<code>x-tengine-error</code>，这是什么鬼，百度了一下，明白了，这是因为防盗链检测所出现的<code>error</code></p>\n<h2 id=\"防盗链\"><a href=\"#防盗链\" class=\"headerlink\" title=\"防盗链\"></a>防盗链</h2><p>具体可以看这篇文章 <a href=\"https://www.jianshu.com/p/0a1338db6cab\">什么是防盗链</a></p>\n<p>我简单说一下</p>\n<p>首先有一个问题，B站点作为一个商业网站，有很多自主版权的图片，自身展示用于商业目的。而A站点，希望在自己的网站上面也展示这些图片，直接使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&lt;img src=<span class=\"hljs-string\">&quot;http://b.com/photo.jpg&quot;</span>/&gt;<br></code></pre></td></tr></table></figure>\n\n<p>这样，大量的客户端在访问A站点时，实际上消耗了B站点的流量，而A站点却从中达成商业目的。从而不劳而获。这样的A站点着实令B站点不快的。</p>\n<p>这种行为又叫做盗链（那我岂不也是盗链者了QAQ）</p>\n<p>如何解决这个问题呢？服务端利用了客户端的一个特性</p>\n<p>客户端在加载非本站的资源时，会在头字段加上<code>Referer:</code>字段，用来告诉服务端，这个请求是来自哪里。<br>回头看一眼我们的network<br><img src=\"https://img-blog.csdnimg.cn/20200328200214620.png\" alt=\"在这里插入图片描述\"><br>确实是这样。</p>\n<p>那我们可以推断，知乎服务器利用是否有referer字段来判断是否为盗链行为，如果是，那么返回403错误，与<code>x-tengine-error: denied by Referer ACL</code>字段。</p>\n<p>而我们用代理服务器转发静态资源请求，代理服务器不会无端加上referer字段，相当于变相绕过了知乎服务器的盗链限制。</p>\n<h2 id=\"出坑\"><a href=\"#出坑\" class=\"headerlink\" title=\"出坑\"></a>出坑</h2><p>验证一下，让代理服务器发送请求时带上<code>referer</code>字段，将request模块设置为调试模式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> imgServer = http.createServer(<span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> url = req.url.split(<span class=\"hljs-string\">&#x27;/img/&#x27;</span>)[<span class=\"hljs-number\">1</span>];<br>    <span class=\"hljs-keyword\">const</span> options = &#123;<br>        <span class=\"hljs-attr\">url</span>: url,<br>        <span class=\"hljs-attr\">encoding</span>: <span class=\"hljs-literal\">null</span>,<br>        <span class=\"hljs-attr\">headers</span>: &#123;<br>            <span class=\"hljs-string\">&quot;Referer&quot;</span>: <span class=\"hljs-string\">&quot;http://localhost:8080/&quot;</span>,<br>        &#125;<br>    &#125;;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">callback</span> (<span class=\"hljs-params\">error, response, body</span>) </span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(error) <span class=\"hljs-built_in\">console</span>.log(error);<br>        <span class=\"hljs-keyword\">if</span> (!error &amp;&amp; response.statusCode === <span class=\"hljs-number\">200</span>) &#123;<br>            <span class=\"hljs-keyword\">const</span> contentType = response.headers[<span class=\"hljs-string\">&#x27;content-type&#x27;</span>];<br>            res.setHeader(<span class=\"hljs-string\">&#x27;Content-Type&#x27;</span>, contentType);<br>            <span class=\"hljs-comment\">// res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);</span><br>            res.end(body);<br>        &#125;<br>    &#125;<br>    request.get(options, callback);<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/2020032820280853.png\" alt=\"在这里插入图片描述\"><br>看到控制台输出</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200328202537488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>踩坑结束。</p>\n","site":{"data":{}},"wordcount":1713,"excerpt":"","more":"<h2 id=\"踩坑\"><a href=\"#踩坑\" class=\"headerlink\" title=\"踩坑\"></a>踩坑</h2><p>之前的写的知乎日报项目<a href=\"https://blog.csdn.net/johnny_mu/article/details/105128678\">https://blog.csdn.net/johnny_mu/article/details/105128678</a></p>\n<p>客户端曾爆出了这个403错误</p>\n<blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20200328193008768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>看起来好像是css文件被跨域限制了，无法引用。那就用之前图片的代理服务器转发一下就好了。</p>\n</blockquote>\n<p>我一开始以为是跨域限制导致的css文件无法加载，所以用代理服务器转发一下，设置上相应header字段就好，问题确实就解决了。<br>但是昨晚睡前一想，不对啊，css，图片等静态资源是不会被跨域限制的。于是我试了一下真正跨域限制的报错。果然不一样。<br><img src=\"https://img-blog.csdnimg.cn/20200328193649824.png\" alt=\"在这里插入图片描述\"><br>再试一下，将图片代理服务器中的取消跨域限制的代码注释掉</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">res.setHeader(<span class=\"hljs-string\">&#x27;Content-Type&#x27;</span>, contentType);<br>         <span class=\"hljs-comment\">// res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);</span><br>         res.end(body);<br></code></pre></td></tr></table></figure>\n<p>重新打开网页，没有任何变化，完美运行。<br>说明之前的bug不是因为跨域产生的，那是因为什么呢。<br>打开控制台看一下请求这个css文件时的network，发现了问题<br><img src=\"https://img-blog.csdnimg.cn/20200328194744609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>在回复头字段里多了一个<code>x-tengine-error</code>，这是什么鬼，百度了一下，明白了，这是因为防盗链检测所出现的<code>error</code></p>\n<h2 id=\"防盗链\"><a href=\"#防盗链\" class=\"headerlink\" title=\"防盗链\"></a>防盗链</h2><p>具体可以看这篇文章 <a href=\"https://www.jianshu.com/p/0a1338db6cab\">什么是防盗链</a></p>\n<p>我简单说一下</p>\n<p>首先有一个问题，B站点作为一个商业网站，有很多自主版权的图片，自身展示用于商业目的。而A站点，希望在自己的网站上面也展示这些图片，直接使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&lt;img src=<span class=\"hljs-string\">&quot;http://b.com/photo.jpg&quot;</span>/&gt;<br></code></pre></td></tr></table></figure>\n\n<p>这样，大量的客户端在访问A站点时，实际上消耗了B站点的流量，而A站点却从中达成商业目的。从而不劳而获。这样的A站点着实令B站点不快的。</p>\n<p>这种行为又叫做盗链（那我岂不也是盗链者了QAQ）</p>\n<p>如何解决这个问题呢？服务端利用了客户端的一个特性</p>\n<p>客户端在加载非本站的资源时，会在头字段加上<code>Referer:</code>字段，用来告诉服务端，这个请求是来自哪里。<br>回头看一眼我们的network<br><img src=\"https://img-blog.csdnimg.cn/20200328200214620.png\" alt=\"在这里插入图片描述\"><br>确实是这样。</p>\n<p>那我们可以推断，知乎服务器利用是否有referer字段来判断是否为盗链行为，如果是，那么返回403错误，与<code>x-tengine-error: denied by Referer ACL</code>字段。</p>\n<p>而我们用代理服务器转发静态资源请求，代理服务器不会无端加上referer字段，相当于变相绕过了知乎服务器的盗链限制。</p>\n<h2 id=\"出坑\"><a href=\"#出坑\" class=\"headerlink\" title=\"出坑\"></a>出坑</h2><p>验证一下，让代理服务器发送请求时带上<code>referer</code>字段，将request模块设置为调试模式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> imgServer = http.createServer(<span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> url = req.url.split(<span class=\"hljs-string\">&#x27;/img/&#x27;</span>)[<span class=\"hljs-number\">1</span>];<br>    <span class=\"hljs-keyword\">const</span> options = &#123;<br>        <span class=\"hljs-attr\">url</span>: url,<br>        <span class=\"hljs-attr\">encoding</span>: <span class=\"hljs-literal\">null</span>,<br>        <span class=\"hljs-attr\">headers</span>: &#123;<br>            <span class=\"hljs-string\">&quot;Referer&quot;</span>: <span class=\"hljs-string\">&quot;http://localhost:8080/&quot;</span>,<br>        &#125;<br>    &#125;;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">callback</span> (<span class=\"hljs-params\">error, response, body</span>) </span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(error) <span class=\"hljs-built_in\">console</span>.log(error);<br>        <span class=\"hljs-keyword\">if</span> (!error &amp;&amp; response.statusCode === <span class=\"hljs-number\">200</span>) &#123;<br>            <span class=\"hljs-keyword\">const</span> contentType = response.headers[<span class=\"hljs-string\">&#x27;content-type&#x27;</span>];<br>            res.setHeader(<span class=\"hljs-string\">&#x27;Content-Type&#x27;</span>, contentType);<br>            <span class=\"hljs-comment\">// res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);</span><br>            res.end(body);<br>        &#125;<br>    &#125;<br>    request.get(options, callback);<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/2020032820280853.png\" alt=\"在这里插入图片描述\"><br>看到控制台输出</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200328202537488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>踩坑结束。</p>\n"},{"title":"同源限制理解与解决","date":"2020-03-02T15:05:42.000Z","index_img":"/img/blogCovers/blog-post3.jpg","_content":"\n同源策略是对JavaScript代码能够操作哪些web内容的一条完整的安全限制。\n### 什么是同源\nURL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。\n下表给出了相对`http://store.company.com/dir/page.html`同源检测的示例:\n\nURL\t|结果\t|原因\n---|---|---\nhttp://store.company.com/dir2/other.html\t|成功\t| 只有路径不同\nhttp://store.company.com/dir/inner/another.html|\t成功\t| 只有路径不同\nhttps://store.company.com/secure.html\t|失败|\t不同协议 ( https和http )\nhttp://store.company.com:81/dir/etc.html\t|失败\t|不同端口 ( http:// 80是默认的)\nhttp://news.company.com/dir/other.html|\t失败|\t不同域名 ( news和store )\n### 同源策略阻止什么\n\n同源策略最初由网景公司添加到浏览器，当前所有的浏览器都支持此功能。\n\n初始的功能是为了限制非同域网页之间cookie的访问，例如a.html页面无法访问非同域的b.html页面的cookie。\n\n 功能是为了保护网站信息安全，比如，一个电脑可以访问很多网站，总不能此网站可以读取另一个网站的信息，尤其是涉及到重要信息，比如用户名和密码。\n\n随着浏览器功能的增强，同源策略由最初限制cookie的访问，发展到限制多种本地信息:\n-  Cookie、LocalStorage 和 IndexedDB访问限制。\na.html的脚本无法访问b.html页面下的上述种类浏览器缓存，为了防止恶意网站通过js获取用户其他网站的cookie。\n- DOM获取限制。\n在浏览器中，`<script>`、`<img>`、`<iframe>`、`<link>`等含有`src`属性的标签都可以加载跨域资源，而不受同源限制，但浏览器限制了JavaScript的权限使其不能读、写加载的内容。\n如果没有这一条，恶意网站可以通过iframe打开银行页面，可以获取dom就相当于可以获取整个银行页面的信息。\n- 限制 ajax 请求，准确来说是限制操作 ajax 响应结果，本质上跟上一条是一样的\n\n\t> 假设有一个黑客叫做小黑，他从网上抓取了一堆美女图做了一个网站，每日访问量爆表。\n\t> 为了维护网站运行，小黑挂了一张收款码，觉得网站不错的可以适当资助一点，可是无奈伸手党太多，小黑的网站入不敷出。\n\t> 于是他非常生气的在网页中写了一段js代码，使用ajax向淘宝发起登陆请求，因为很多数人都访问过淘宝，所以电脑中存有淘宝的cookie，不需要输入账号密码直接就自动登录了，然后小黑在ajax回调函数中解析了淘宝返回的数据，得到了很多人的隐私信息，转手一卖，小黑的网站终于盈利了。\n\t> 如果跨域也可以发送AJAX请求的话，小黑就真的获取到了用户的隐私并成功获利了！！！\n\n### 同源策略允许什么\n- 同源策略只对网页的HTML文档做了限制，对加载的其他静态资源如javascript、css、图片等仍然认为属于同源。\n- 页面中的`<script>`、`<img>`、`<ifram>`、`<link>`等标签、重定向以及表单提交是不会受到同源策略限制的，比如在网站`www.foo.com`下提交一个表单到`www.bar.com`是完全可以的。\n- 跨域资源嵌入是允许的。\n脚本本身的来源和同源策略并不相关，相关的是脚本所嵌入的文档的来源，理解这一点很重要。例如、假设一个来自主机A的脚本被包含到（使用`<script>`标记的src属性）宿主B的一个web页面中。这个脚本的来源就是主机B而不是A，并且可以完整的访问包含它的文档内容。如果脚本打开一个新的窗口载入来自主机B的另一个文档，脚本对这个文档的内容也完全具有访问权限。但是，如果脚本打开第三个窗口并载入一个来自主机C吃文档（或者是主机A），同源策略会发挥作用，阻止脚本访问这个文档。\n### 如何跨域\n1.iframe跨域 [参考happy哥](https://www.cnblogs.com/happy-8090/p/11570998.html)\n- `document.domain`跨域\n\n\t**此方案仅限主域相同，子域不同的跨域应用场景。**\n\n\t同源策略会给那些使用多个子域的大站点带来一些问题。如，来自`home.example.com`的文档里脚本想要合法的读取从`developer.example.com`上的文档的属性。为了支持这种类型的多域名站点，可以使用Document对象的`domain`属性。在默认情况下，属性`domain`存放的是载入文档的服务器的主机名。可以设置这一个属性，不过字符串必须具有有效的域前缀或他本身。因此，如果一个`domain`属性的初始值是字符串`home.example.com`，就可以把它设置为`example.com`。但是不能设置为`home.example`或者`ample.com`。另外`domain`值中必须有一个.，不能把它设置为`com`或其他顶级域名。如果两个窗口（或窗体）包含的脚本把domain设置成了相同的值，那么这两个窗口就不会再受同源策略的约束。\n\t在`home.example.com`和`developer.example.com`的文档同时使用脚本设置\n\t\n\n\t```javascript\n\tdocument.domain = 'example.com'\n\t```\n\t实现跨域，**cookie**也可以用这种方法实现跨域\n\n\n- `location.hash` 跨域\n当主域不同时，可以使用此方法\n在url中，`http://www.baidu.com#helloword`的`#helloworad`就是`location.hash`，改变hash值不会导致页面刷新，所以可以利用hash值来进行数据的传递，当然数据量是有限的。\n父窗口可以把信息，写入子窗口的`location.hash`。\n\n\t```javascript\n\tvar src = originURL + '#' + data;\n\tdocument.getElementById('myIFrame').src = src;\n\t```\n\t子窗口通过监听`hashchange`事件得到通知。\n\n\n\t```javascript\n\twindow.onhashchange = checkMessage;\n\tfunction checkMessage() {\n\t  var message = window.location.hash;\n\t  // ...\n\t}\n\t```\n\t同样的，子窗口也可以改变父窗口的片段标识符。\n\n\n\t```javascript\n\tparent.location.href= target + \"#\" + hash;\n\t```\n\n- `window.name`跨域\n`window.name`（一般在js代码里出现）的值不是一个普通的全局变量，而是当前窗口的名字，要注意的是每个iframe都有包裹它的window，而这个window是top window的子窗口，而它自然也有window.name的属性，window.name属性的神奇之处在于name值在不同的页面（甚至不同域名）加载后依旧存在（如果没有修改则值不会变化），并且可以支持非常长的name值（2MB）\n举个简单的例子：你在某个页面的控制台输入：\n\n\t```javascript\n\twindow.name = \"hello world\"\n\twindow.location = \"http://www.baidu.com\"\n\t```\n\n\t页面跳转到了百度首页\n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216152224507.png)\n\t但是`window.name`却被保存下来了，还是`hello world`。\n\n\t> 这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。\n\n- 跨文本消息 `postMessage`\n`postMessage` 是 HTML5 新增加的一项功能，跨文档消息传输(Cross Document Messaging)，目前：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 都支持这项功能。\n举例来说，父窗口`http://aaa.com`向子窗口`http://bbb.com`发消息，调用`postMessage`方法就可以了。\n\n\t```javascript\n\tvar popup = window.open('http://bbb.com', 'title');\n\tpopup.postMessage('Hello World!', 'http://bbb.com');\n\t```\n\t子窗口向父窗口发送消息的写法类似。\n\n\n\t```javascript\n\twindow.opener.postMessage('Nice to see you', 'http://aaa.com');\n\t```\n\t父窗口和子窗口都可以通过message事件，监听对方的消息。\n\t```javascript\n\twindow.addEventListener('message', function(e) {\n\tconsole.log(e.data);\n\t},false);\n\t```\n\tmessage事件的事件对象event，提供以下三个属性。\n\n\t```\n\tevent.source：发送消息的窗口\n\tevent.origin: 消息发向的网址\n\tevent.data: 消息内容\n\t```\n2. Ajax跨域\n- Jsonp\nJSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。\n\n\t它的基本思想是，网页通过添加一个`<script>`元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。\n\n\t首先，网页动态插入`<script>`元素，由它向跨源网址发出请求。\n\t```javascript\n\tfunction addScriptTag(src) {//定义添加script标签函数\n\tvar script = document.createElement('script');\n\tscript.setAttribute(\"type\",\"text/javascript\");\n\tscript.src = src;\n\tdocument.body.appendChild(script);\n\t}\n\twindow.onload = function () {//当文档加载完成时，发送Jsonp请求\n\t  addScriptTag('http://example.com/ip?code=123&callback=foo');\n\t  //url中包含code需要的数据，与需要的回调函数callback\n\t}\n\tfunction foo(data) {//回调函数，当数据返回时，调用\n\t  console.log('Your public IP address is: ' + data.ip);\n\t};\n\t```\n\t上面代码通过动态添加`<script>`元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。\n\t服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。\n\t```javascript\n\tfoo({\n\t    \"ip\": \"8.8.8.8\"\n\t});\n\t```\n\t由于`<script>`元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。\n- CORS跨域资源共享\nCORS的主要工作在后端，是HTML5规范定义的如何跨域访问资源。\nOrigin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。\n用一个图来表示就是：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216161317768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n假设本域是`my.com`，外域是`sina.com`，只要响应头`Access-Control-Allow-Origin`为`http://my.com`，或者是`*`，本次请求就可以成功。\n\n\t可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的`Access-Control-Allow-Origin`，决定权始终在对方手中。\n\n\t上面这种跨域请求，称之为“简单请求”。简单请求包括GET、HEAD和POST（POST的Content-Type类型 仅限`application/x-www-form-urlencoded`、`multipart/form-data`和`text/plain`），并且不能出现任何自定义头（例如，X-Custom: 12345），通常能满足90%的需求。\n\n\t无论你是否需要用JavaScript通过CORS跨域请求资源，你都要了解CORS的原理。最新的浏览器全面支持HTML5。在引用外域资源时，除了JavaScript和CSS外，都要验证CORS。例如，当你引用了某个第三方CDN上的字体文件时：\n\n\t```javascript\n\t/* CSS */\n\t@font-face {\n\t  font-family: 'FontAwesome';\n\t  src: url('http://cdn.com/fonts/fontawesome.ttf') format('truetype');\n\t}\n\t```\n\n\t如果该CDN服务商未正确设置`Access-Control-Allow-Origin`，那么浏览器无法加载字体资源。\n\n\t对于`PUT`、`DELETE`以及其他类型如`application/json`的POST请求，在发送AJAX请求之前，浏览器会先发送一个OPTIONS请求（称为preflighted请求）到这个URL上，询问目标服务器是否接受：\n\n\t```\n\tOPTIONS /path/to/resource HTTP/1.1\n\tHost: bar.com\n\tOrigin: http://my.com\n\tAccess-Control-Request-Method: POST\n\t```\n\n\t服务器必须响应并明确指出允许的Method：\n\n\t```\n\tHTTP/1.1 200 OK\n\tAccess-Control-Allow-Origin: http://my.com\n\tAccess-Control-Allow-Methods: POST, GET, PUT, OPTIONS\n\tAccess-Control-Max-Age: 86400\n\t```\n\n\t浏览器确认服务器响应的`Access-Control-Allow-Methods`头确实包含将要发送的AJAX请求的Method，才会继续发送AJAX，否则，抛出一个错误。\n\n\t由于以POST、PUT方式传送JSON格式的数据在REST中很常见，所以要跨域正确处理POST和PUT请求，服务器端必须正确响应OPTIONS请求。\n4. cookie跨域 \n- document.domain跨域，与iframe类似\n- Jsonp跨域\n- Ajax+cors跨域\n默认情况下，标准的跨域请求是不会发送不同源的cookie的\n\n\t```javascript\n\tvar xhr = new XMLHttpRequest();\n\txhr.withCredentials = true;\n\t```\n\t为了安全，标准里不允许 `Access-Control-Allow-Origin: *`，`*`必须指定明确的、与请求网页一致的域名。\n5. LocalStorage跨域\n- postMessage\n\n参考：\nhttps://blog.csdn.net/hansexploration/article/details/80314948\nhttp://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html\nhttps://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400\nhttps://blog.csdn.net/shuidinaozhongyan/article/details/78155310\nhttps://blog.csdn.net/chou_out_man/article/details/80664413\nhttps://blog.csdn.net/itcats_cn/article/details/82318092\nhttps://www.cnblogs.com/happy-8090/p/11570998.html\n","source":"_posts/同源限制理解与解决.md","raw":"---\ntitle: 同源限制理解与解决\ndate: 2020-03-02 23:05:42\nindex_img: /img/blogCovers/blog-post3.jpg\ntags: [JavaScript, http, 浏览器]\ncategories: [学习笔记]\n---\n\n同源策略是对JavaScript代码能够操作哪些web内容的一条完整的安全限制。\n### 什么是同源\nURL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。\n下表给出了相对`http://store.company.com/dir/page.html`同源检测的示例:\n\nURL\t|结果\t|原因\n---|---|---\nhttp://store.company.com/dir2/other.html\t|成功\t| 只有路径不同\nhttp://store.company.com/dir/inner/another.html|\t成功\t| 只有路径不同\nhttps://store.company.com/secure.html\t|失败|\t不同协议 ( https和http )\nhttp://store.company.com:81/dir/etc.html\t|失败\t|不同端口 ( http:// 80是默认的)\nhttp://news.company.com/dir/other.html|\t失败|\t不同域名 ( news和store )\n### 同源策略阻止什么\n\n同源策略最初由网景公司添加到浏览器，当前所有的浏览器都支持此功能。\n\n初始的功能是为了限制非同域网页之间cookie的访问，例如a.html页面无法访问非同域的b.html页面的cookie。\n\n 功能是为了保护网站信息安全，比如，一个电脑可以访问很多网站，总不能此网站可以读取另一个网站的信息，尤其是涉及到重要信息，比如用户名和密码。\n\n随着浏览器功能的增强，同源策略由最初限制cookie的访问，发展到限制多种本地信息:\n-  Cookie、LocalStorage 和 IndexedDB访问限制。\na.html的脚本无法访问b.html页面下的上述种类浏览器缓存，为了防止恶意网站通过js获取用户其他网站的cookie。\n- DOM获取限制。\n在浏览器中，`<script>`、`<img>`、`<iframe>`、`<link>`等含有`src`属性的标签都可以加载跨域资源，而不受同源限制，但浏览器限制了JavaScript的权限使其不能读、写加载的内容。\n如果没有这一条，恶意网站可以通过iframe打开银行页面，可以获取dom就相当于可以获取整个银行页面的信息。\n- 限制 ajax 请求，准确来说是限制操作 ajax 响应结果，本质上跟上一条是一样的\n\n\t> 假设有一个黑客叫做小黑，他从网上抓取了一堆美女图做了一个网站，每日访问量爆表。\n\t> 为了维护网站运行，小黑挂了一张收款码，觉得网站不错的可以适当资助一点，可是无奈伸手党太多，小黑的网站入不敷出。\n\t> 于是他非常生气的在网页中写了一段js代码，使用ajax向淘宝发起登陆请求，因为很多数人都访问过淘宝，所以电脑中存有淘宝的cookie，不需要输入账号密码直接就自动登录了，然后小黑在ajax回调函数中解析了淘宝返回的数据，得到了很多人的隐私信息，转手一卖，小黑的网站终于盈利了。\n\t> 如果跨域也可以发送AJAX请求的话，小黑就真的获取到了用户的隐私并成功获利了！！！\n\n### 同源策略允许什么\n- 同源策略只对网页的HTML文档做了限制，对加载的其他静态资源如javascript、css、图片等仍然认为属于同源。\n- 页面中的`<script>`、`<img>`、`<ifram>`、`<link>`等标签、重定向以及表单提交是不会受到同源策略限制的，比如在网站`www.foo.com`下提交一个表单到`www.bar.com`是完全可以的。\n- 跨域资源嵌入是允许的。\n脚本本身的来源和同源策略并不相关，相关的是脚本所嵌入的文档的来源，理解这一点很重要。例如、假设一个来自主机A的脚本被包含到（使用`<script>`标记的src属性）宿主B的一个web页面中。这个脚本的来源就是主机B而不是A，并且可以完整的访问包含它的文档内容。如果脚本打开一个新的窗口载入来自主机B的另一个文档，脚本对这个文档的内容也完全具有访问权限。但是，如果脚本打开第三个窗口并载入一个来自主机C吃文档（或者是主机A），同源策略会发挥作用，阻止脚本访问这个文档。\n### 如何跨域\n1.iframe跨域 [参考happy哥](https://www.cnblogs.com/happy-8090/p/11570998.html)\n- `document.domain`跨域\n\n\t**此方案仅限主域相同，子域不同的跨域应用场景。**\n\n\t同源策略会给那些使用多个子域的大站点带来一些问题。如，来自`home.example.com`的文档里脚本想要合法的读取从`developer.example.com`上的文档的属性。为了支持这种类型的多域名站点，可以使用Document对象的`domain`属性。在默认情况下，属性`domain`存放的是载入文档的服务器的主机名。可以设置这一个属性，不过字符串必须具有有效的域前缀或他本身。因此，如果一个`domain`属性的初始值是字符串`home.example.com`，就可以把它设置为`example.com`。但是不能设置为`home.example`或者`ample.com`。另外`domain`值中必须有一个.，不能把它设置为`com`或其他顶级域名。如果两个窗口（或窗体）包含的脚本把domain设置成了相同的值，那么这两个窗口就不会再受同源策略的约束。\n\t在`home.example.com`和`developer.example.com`的文档同时使用脚本设置\n\t\n\n\t```javascript\n\tdocument.domain = 'example.com'\n\t```\n\t实现跨域，**cookie**也可以用这种方法实现跨域\n\n\n- `location.hash` 跨域\n当主域不同时，可以使用此方法\n在url中，`http://www.baidu.com#helloword`的`#helloworad`就是`location.hash`，改变hash值不会导致页面刷新，所以可以利用hash值来进行数据的传递，当然数据量是有限的。\n父窗口可以把信息，写入子窗口的`location.hash`。\n\n\t```javascript\n\tvar src = originURL + '#' + data;\n\tdocument.getElementById('myIFrame').src = src;\n\t```\n\t子窗口通过监听`hashchange`事件得到通知。\n\n\n\t```javascript\n\twindow.onhashchange = checkMessage;\n\tfunction checkMessage() {\n\t  var message = window.location.hash;\n\t  // ...\n\t}\n\t```\n\t同样的，子窗口也可以改变父窗口的片段标识符。\n\n\n\t```javascript\n\tparent.location.href= target + \"#\" + hash;\n\t```\n\n- `window.name`跨域\n`window.name`（一般在js代码里出现）的值不是一个普通的全局变量，而是当前窗口的名字，要注意的是每个iframe都有包裹它的window，而这个window是top window的子窗口，而它自然也有window.name的属性，window.name属性的神奇之处在于name值在不同的页面（甚至不同域名）加载后依旧存在（如果没有修改则值不会变化），并且可以支持非常长的name值（2MB）\n举个简单的例子：你在某个页面的控制台输入：\n\n\t```javascript\n\twindow.name = \"hello world\"\n\twindow.location = \"http://www.baidu.com\"\n\t```\n\n\t页面跳转到了百度首页\n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216152224507.png)\n\t但是`window.name`却被保存下来了，还是`hello world`。\n\n\t> 这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。\n\n- 跨文本消息 `postMessage`\n`postMessage` 是 HTML5 新增加的一项功能，跨文档消息传输(Cross Document Messaging)，目前：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 都支持这项功能。\n举例来说，父窗口`http://aaa.com`向子窗口`http://bbb.com`发消息，调用`postMessage`方法就可以了。\n\n\t```javascript\n\tvar popup = window.open('http://bbb.com', 'title');\n\tpopup.postMessage('Hello World!', 'http://bbb.com');\n\t```\n\t子窗口向父窗口发送消息的写法类似。\n\n\n\t```javascript\n\twindow.opener.postMessage('Nice to see you', 'http://aaa.com');\n\t```\n\t父窗口和子窗口都可以通过message事件，监听对方的消息。\n\t```javascript\n\twindow.addEventListener('message', function(e) {\n\tconsole.log(e.data);\n\t},false);\n\t```\n\tmessage事件的事件对象event，提供以下三个属性。\n\n\t```\n\tevent.source：发送消息的窗口\n\tevent.origin: 消息发向的网址\n\tevent.data: 消息内容\n\t```\n2. Ajax跨域\n- Jsonp\nJSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。\n\n\t它的基本思想是，网页通过添加一个`<script>`元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。\n\n\t首先，网页动态插入`<script>`元素，由它向跨源网址发出请求。\n\t```javascript\n\tfunction addScriptTag(src) {//定义添加script标签函数\n\tvar script = document.createElement('script');\n\tscript.setAttribute(\"type\",\"text/javascript\");\n\tscript.src = src;\n\tdocument.body.appendChild(script);\n\t}\n\twindow.onload = function () {//当文档加载完成时，发送Jsonp请求\n\t  addScriptTag('http://example.com/ip?code=123&callback=foo');\n\t  //url中包含code需要的数据，与需要的回调函数callback\n\t}\n\tfunction foo(data) {//回调函数，当数据返回时，调用\n\t  console.log('Your public IP address is: ' + data.ip);\n\t};\n\t```\n\t上面代码通过动态添加`<script>`元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。\n\t服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。\n\t```javascript\n\tfoo({\n\t    \"ip\": \"8.8.8.8\"\n\t});\n\t```\n\t由于`<script>`元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。\n- CORS跨域资源共享\nCORS的主要工作在后端，是HTML5规范定义的如何跨域访问资源。\nOrigin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。\n用一个图来表示就是：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216161317768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70)\n假设本域是`my.com`，外域是`sina.com`，只要响应头`Access-Control-Allow-Origin`为`http://my.com`，或者是`*`，本次请求就可以成功。\n\n\t可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的`Access-Control-Allow-Origin`，决定权始终在对方手中。\n\n\t上面这种跨域请求，称之为“简单请求”。简单请求包括GET、HEAD和POST（POST的Content-Type类型 仅限`application/x-www-form-urlencoded`、`multipart/form-data`和`text/plain`），并且不能出现任何自定义头（例如，X-Custom: 12345），通常能满足90%的需求。\n\n\t无论你是否需要用JavaScript通过CORS跨域请求资源，你都要了解CORS的原理。最新的浏览器全面支持HTML5。在引用外域资源时，除了JavaScript和CSS外，都要验证CORS。例如，当你引用了某个第三方CDN上的字体文件时：\n\n\t```javascript\n\t/* CSS */\n\t@font-face {\n\t  font-family: 'FontAwesome';\n\t  src: url('http://cdn.com/fonts/fontawesome.ttf') format('truetype');\n\t}\n\t```\n\n\t如果该CDN服务商未正确设置`Access-Control-Allow-Origin`，那么浏览器无法加载字体资源。\n\n\t对于`PUT`、`DELETE`以及其他类型如`application/json`的POST请求，在发送AJAX请求之前，浏览器会先发送一个OPTIONS请求（称为preflighted请求）到这个URL上，询问目标服务器是否接受：\n\n\t```\n\tOPTIONS /path/to/resource HTTP/1.1\n\tHost: bar.com\n\tOrigin: http://my.com\n\tAccess-Control-Request-Method: POST\n\t```\n\n\t服务器必须响应并明确指出允许的Method：\n\n\t```\n\tHTTP/1.1 200 OK\n\tAccess-Control-Allow-Origin: http://my.com\n\tAccess-Control-Allow-Methods: POST, GET, PUT, OPTIONS\n\tAccess-Control-Max-Age: 86400\n\t```\n\n\t浏览器确认服务器响应的`Access-Control-Allow-Methods`头确实包含将要发送的AJAX请求的Method，才会继续发送AJAX，否则，抛出一个错误。\n\n\t由于以POST、PUT方式传送JSON格式的数据在REST中很常见，所以要跨域正确处理POST和PUT请求，服务器端必须正确响应OPTIONS请求。\n4. cookie跨域 \n- document.domain跨域，与iframe类似\n- Jsonp跨域\n- Ajax+cors跨域\n默认情况下，标准的跨域请求是不会发送不同源的cookie的\n\n\t```javascript\n\tvar xhr = new XMLHttpRequest();\n\txhr.withCredentials = true;\n\t```\n\t为了安全，标准里不允许 `Access-Control-Allow-Origin: *`，`*`必须指定明确的、与请求网页一致的域名。\n5. LocalStorage跨域\n- postMessage\n\n参考：\nhttps://blog.csdn.net/hansexploration/article/details/80314948\nhttp://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html\nhttps://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400\nhttps://blog.csdn.net/shuidinaozhongyan/article/details/78155310\nhttps://blog.csdn.net/chou_out_man/article/details/80664413\nhttps://blog.csdn.net/itcats_cn/article/details/82318092\nhttps://www.cnblogs.com/happy-8090/p/11570998.html\n","slug":"同源限制理解与解决","published":1,"updated":"2022-01-10T08:41:39.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckyo4lu700012nz69b6lmhc2h","content":"<p>同源策略是对JavaScript代码能够操作哪些web内容的一条完整的安全限制。</p>\n<h3 id=\"什么是同源\"><a href=\"#什么是同源\" class=\"headerlink\" title=\"什么是同源\"></a>什么是同源</h3><p>URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。<br>下表给出了相对<code>http://store.company.com/dir/page.html</code>同源检测的示例:</p>\n<table>\n<thead>\n<tr>\n<th>URL</th>\n<th>结果</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"http://store.company.com/dir2/other.html\">http://store.company.com/dir2/other.html</a></td>\n<td>成功</td>\n<td>只有路径不同</td>\n</tr>\n<tr>\n<td><a href=\"http://store.company.com/dir/inner/another.html\">http://store.company.com/dir/inner/another.html</a></td>\n<td>成功</td>\n<td>只有路径不同</td>\n</tr>\n<tr>\n<td><a href=\"https://store.company.com/secure.html\">https://store.company.com/secure.html</a></td>\n<td>失败</td>\n<td>不同协议 ( https和http )</td>\n</tr>\n<tr>\n<td><a href=\"http://store.company.com:81/dir/etc.html\">http://store.company.com:81/dir/etc.html</a></td>\n<td>失败</td>\n<td>不同端口 ( http:// 80是默认的)</td>\n</tr>\n<tr>\n<td><a href=\"http://news.company.com/dir/other.html\">http://news.company.com/dir/other.html</a></td>\n<td>失败</td>\n<td>不同域名 ( news和store )</td>\n</tr>\n</tbody></table>\n<h3 id=\"同源策略阻止什么\"><a href=\"#同源策略阻止什么\" class=\"headerlink\" title=\"同源策略阻止什么\"></a>同源策略阻止什么</h3><p>同源策略最初由网景公司添加到浏览器，当前所有的浏览器都支持此功能。</p>\n<p>初始的功能是为了限制非同域网页之间cookie的访问，例如a.html页面无法访问非同域的b.html页面的cookie。</p>\n<p> 功能是为了保护网站信息安全，比如，一个电脑可以访问很多网站，总不能此网站可以读取另一个网站的信息，尤其是涉及到重要信息，比如用户名和密码。</p>\n<p>随着浏览器功能的增强，同源策略由最初限制cookie的访问，发展到限制多种本地信息:</p>\n<ul>\n<li><p> Cookie、LocalStorage 和 IndexedDB访问限制。<br>a.html的脚本无法访问b.html页面下的上述种类浏览器缓存，为了防止恶意网站通过js获取用户其他网站的cookie。</p>\n</li>\n<li><p>DOM获取限制。<br>在浏览器中，<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;link&gt;</code>等含有<code>src</code>属性的标签都可以加载跨域资源，而不受同源限制，但浏览器限制了JavaScript的权限使其不能读、写加载的内容。<br>如果没有这一条，恶意网站可以通过iframe打开银行页面，可以获取dom就相当于可以获取整个银行页面的信息。</p>\n</li>\n<li><p>限制 ajax 请求，准确来说是限制操作 ajax 响应结果，本质上跟上一条是一样的</p>\n<blockquote>\n<p>假设有一个黑客叫做小黑，他从网上抓取了一堆美女图做了一个网站，每日访问量爆表。<br>为了维护网站运行，小黑挂了一张收款码，觉得网站不错的可以适当资助一点，可是无奈伸手党太多，小黑的网站入不敷出。<br>于是他非常生气的在网页中写了一段js代码，使用ajax向淘宝发起登陆请求，因为很多数人都访问过淘宝，所以电脑中存有淘宝的cookie，不需要输入账号密码直接就自动登录了，然后小黑在ajax回调函数中解析了淘宝返回的数据，得到了很多人的隐私信息，转手一卖，小黑的网站终于盈利了。<br>如果跨域也可以发送AJAX请求的话，小黑就真的获取到了用户的隐私并成功获利了！！！</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"同源策略允许什么\"><a href=\"#同源策略允许什么\" class=\"headerlink\" title=\"同源策略允许什么\"></a>同源策略允许什么</h3><ul>\n<li>同源策略只对网页的HTML文档做了限制，对加载的其他静态资源如javascript、css、图片等仍然认为属于同源。</li>\n<li>页面中的<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;ifram&gt;</code>、<code>&lt;link&gt;</code>等标签、重定向以及表单提交是不会受到同源策略限制的，比如在网站<code>www.foo.com</code>下提交一个表单到<code>www.bar.com</code>是完全可以的。</li>\n<li>跨域资源嵌入是允许的。<br>脚本本身的来源和同源策略并不相关，相关的是脚本所嵌入的文档的来源，理解这一点很重要。例如、假设一个来自主机A的脚本被包含到（使用<code>&lt;script&gt;</code>标记的src属性）宿主B的一个web页面中。这个脚本的来源就是主机B而不是A，并且可以完整的访问包含它的文档内容。如果脚本打开一个新的窗口载入来自主机B的另一个文档，脚本对这个文档的内容也完全具有访问权限。但是，如果脚本打开第三个窗口并载入一个来自主机C吃文档（或者是主机A），同源策略会发挥作用，阻止脚本访问这个文档。<h3 id=\"如何跨域\"><a href=\"#如何跨域\" class=\"headerlink\" title=\"如何跨域\"></a>如何跨域</h3></li>\n</ul>\n<p>1.iframe跨域 <a href=\"https://www.cnblogs.com/happy-8090/p/11570998.html\">参考happy哥</a></p>\n<ul>\n<li><p><code>document.domain</code>跨域</p>\n<p>  <strong>此方案仅限主域相同，子域不同的跨域应用场景。</strong></p>\n<p>  同源策略会给那些使用多个子域的大站点带来一些问题。如，来自<code>home.example.com</code>的文档里脚本想要合法的读取从<code>developer.example.com</code>上的文档的属性。为了支持这种类型的多域名站点，可以使用Document对象的<code>domain</code>属性。在默认情况下，属性<code>domain</code>存放的是载入文档的服务器的主机名。可以设置这一个属性，不过字符串必须具有有效的域前缀或他本身。因此，如果一个<code>domain</code>属性的初始值是字符串<code>home.example.com</code>，就可以把它设置为<code>example.com</code>。但是不能设置为<code>home.example</code>或者<code>ample.com</code>。另外<code>domain</code>值中必须有一个.，不能把它设置为<code>com</code>或其他顶级域名。如果两个窗口（或窗体）包含的脚本把domain设置成了相同的值，那么这两个窗口就不会再受同源策略的约束。<br>  在<code>home.example.com</code>和<code>developer.example.com</code>的文档同时使用脚本设置</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">document</span>.domain = <span class=\"hljs-string\">&#x27;example.com&#x27;</span><br></code></pre></td></tr></table></figure>\n<p>  实现跨域，<strong>cookie</strong>也可以用这种方法实现跨域</p>\n</li>\n</ul>\n<ul>\n<li><p><code>location.hash</code> 跨域<br>当主域不同时，可以使用此方法<br>在url中，<code>http://www.baidu.com#helloword</code>的<code>#helloworad</code>就是<code>location.hash</code>，改变hash值不会导致页面刷新，所以可以利用hash值来进行数据的传递，当然数据量是有限的。<br>父窗口可以把信息，写入子窗口的<code>location.hash</code>。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> src = originURL + <span class=\"hljs-string\">&#x27;#&#x27;</span> + data;<br><span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;myIFrame&#x27;</span>).src = src;<br></code></pre></td></tr></table></figure>\n<p>  子窗口通过监听<code>hashchange</code>事件得到通知。</p>\n</li>\n</ul>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">window</span>.onhashchange = checkMessage;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">checkMessage</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">var</span> message = <span class=\"hljs-built_in\">window</span>.location.hash;<br>  <span class=\"hljs-comment\">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n同样的，子窗口也可以改变父窗口的片段标识符。\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">parent.location.href= target + <span class=\"hljs-string\">&quot;#&quot;</span> + hash;<br></code></pre></td></tr></table></figure>\n</code></pre>\n<ul>\n<li><p><code>window.name</code>跨域<br><code>window.name</code>（一般在js代码里出现）的值不是一个普通的全局变量，而是当前窗口的名字，要注意的是每个iframe都有包裹它的window，而这个window是top window的子窗口，而它自然也有window.name的属性，window.name属性的神奇之处在于name值在不同的页面（甚至不同域名）加载后依旧存在（如果没有修改则值不会变化），并且可以支持非常长的name值（2MB）<br>举个简单的例子：你在某个页面的控制台输入：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">window</span>.name = <span class=\"hljs-string\">&quot;hello world&quot;</span><br><span class=\"hljs-built_in\">window</span>.location = <span class=\"hljs-string\">&quot;http://www.baidu.com&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>  页面跳转到了百度首页<br>  <img src=\"https://img-blog.csdnimg.cn/20200216152224507.png\" alt=\"在这里插入图片描述\"><br>  但是<code>window.name</code>却被保存下来了，还是<code>hello world</code>。</p>\n<blockquote>\n<p>这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。</p>\n</blockquote>\n</li>\n<li><p>跨文本消息 <code>postMessage</code><br><code>postMessage</code> 是 HTML5 新增加的一项功能，跨文档消息传输(Cross Document Messaging)，目前：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 都支持这项功能。<br>举例来说，父窗口<code>http://aaa.com</code>向子窗口<code>http://bbb.com</code>发消息，调用<code>postMessage</code>方法就可以了。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> popup = <span class=\"hljs-built_in\">window</span>.open(<span class=\"hljs-string\">&#x27;http://bbb.com&#x27;</span>, <span class=\"hljs-string\">&#x27;title&#x27;</span>);<br>popup.postMessage(<span class=\"hljs-string\">&#x27;Hello World!&#x27;</span>, <span class=\"hljs-string\">&#x27;http://bbb.com&#x27;</span>);<br></code></pre></td></tr></table></figure>\n<p>  子窗口向父窗口发送消息的写法类似。</p>\n</li>\n</ul>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">window</span>.opener.postMessage(<span class=\"hljs-string\">&#x27;Nice to see you&#x27;</span>, <span class=\"hljs-string\">&#x27;http://aaa.com&#x27;</span>);<br></code></pre></td></tr></table></figure>\n父窗口和子窗口都可以通过message事件，监听对方的消息。\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">&#x27;message&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>) </span>&#123;<br><span class=\"hljs-built_in\">console</span>.log(e.data);<br>&#125;,<span class=\"hljs-literal\">false</span>);<br></code></pre></td></tr></table></figure>\nmessage事件的事件对象event，提供以下三个属性。\n\n<figure class=\"highlight mel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mel\"><span class=\"hljs-keyword\">event</span>.<span class=\"hljs-keyword\">source</span>：发送消息的窗口<br><span class=\"hljs-keyword\">event</span>.origin: 消息发向的网址<br><span class=\"hljs-keyword\">event</span>.data: 消息内容<br></code></pre></td></tr></table></figure>\n</code></pre>\n<ol start=\"2\">\n<li>Ajax跨域</li>\n</ol>\n<ul>\n<li><p>Jsonp<br>JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。</p>\n<p>  它的基本思想是，网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</p>\n<p>  首先，网页动态插入<code>&lt;script&gt;</code>元素，由它向跨源网址发出请求。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addScriptTag</span>(<span class=\"hljs-params\">src</span>) </span>&#123;<span class=\"hljs-comment\">//定义添加script标签函数</span><br><span class=\"hljs-keyword\">var</span> script = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">&#x27;script&#x27;</span>);<br>script.setAttribute(<span class=\"hljs-string\">&quot;type&quot;</span>,<span class=\"hljs-string\">&quot;text/javascript&quot;</span>);<br>script.src = src;<br><span class=\"hljs-built_in\">document</span>.body.appendChild(script);<br>&#125;<br><span class=\"hljs-built_in\">window</span>.onload = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<span class=\"hljs-comment\">//当文档加载完成时，发送Jsonp请求</span><br>  addScriptTag(<span class=\"hljs-string\">&#x27;http://example.com/ip?code=123&amp;callback=foo&#x27;</span>);<br>  <span class=\"hljs-comment\">//url中包含code需要的数据，与需要的回调函数callback</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">data</span>) </span>&#123;<span class=\"hljs-comment\">//回调函数，当数据返回时，调用</span><br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;Your public IP address is: &#x27;</span> + data.ip);<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>  上面代码通过动态添加<code>&lt;script&gt;</code>元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。<br>  服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">foo(&#123;<br>    <span class=\"hljs-string\">&quot;ip&quot;</span>: <span class=\"hljs-string\">&quot;8.8.8.8&quot;</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>  由于<code>&lt;script&gt;</code>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。</p>\n</li>\n<li><p>CORS跨域资源共享<br>CORS的主要工作在后端，是HTML5规范定义的如何跨域访问资源。<br>Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。<br>用一个图来表示就是：<br><img src=\"https://img-blog.csdnimg.cn/20200216161317768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>假设本域是<code>my.com</code>，外域是<code>sina.com</code>，只要响应头<code>Access-Control-Allow-Origin</code>为<code>http://my.com</code>，或者是<code>*</code>，本次请求就可以成功。</p>\n<p>  可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的<code>Access-Control-Allow-Origin</code>，决定权始终在对方手中。</p>\n<p>  上面这种跨域请求，称之为“简单请求”。简单请求包括GET、HEAD和POST（POST的Content-Type类型 仅限<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>和<code>text/plain</code>），并且不能出现任何自定义头（例如，X-Custom: 12345），通常能满足90%的需求。</p>\n<p>  无论你是否需要用JavaScript通过CORS跨域请求资源，你都要了解CORS的原理。最新的浏览器全面支持HTML5。在引用外域资源时，除了JavaScript和CSS外，都要验证CORS。例如，当你引用了某个第三方CDN上的字体文件时：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/* CSS */</span><br>@font-face &#123;<br>  font-family: <span class=\"hljs-string\">&#x27;FontAwesome&#x27;</span>;<br>  src: url(<span class=\"hljs-string\">&#x27;http://cdn.com/fonts/fontawesome.ttf&#x27;</span>) format(<span class=\"hljs-string\">&#x27;truetype&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>  如果该CDN服务商未正确设置<code>Access-Control-Allow-Origin</code>，那么浏览器无法加载字体资源。</p>\n<p>  对于<code>PUT</code>、<code>DELETE</code>以及其他类型如<code>application/json</code>的POST请求，在发送AJAX请求之前，浏览器会先发送一个OPTIONS请求（称为preflighted请求）到这个URL上，询问目标服务器是否接受：</p>\n  <figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs oxygene\">OPTIONS /path/<span class=\"hljs-keyword\">to</span>/resource HTTP/<span class=\"hljs-number\">1.1</span><br>Host: bar.com<br>Origin: http:<span class=\"hljs-comment\">//my.com</span><br>Access-Control-Request-<span class=\"hljs-function\"><span class=\"hljs-keyword\">Method</span>:</span> POST<br></code></pre></td></tr></table></figure>\n\n<p>  服务器必须响应并明确指出允许的Method：</p>\n  <figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs http\"><span class=\"hljs-meta\">HTTP/1.1</span> <span class=\"hljs-number\">200</span> OK<br><span class=\"hljs-attribute\">Access-Control-Allow-Origin</span><span class=\"hljs-punctuation\">: </span>http://my.com<br><span class=\"hljs-attribute\">Access-Control-Allow-Methods</span><span class=\"hljs-punctuation\">: </span>POST, GET, PUT, OPTIONS<br><span class=\"hljs-attribute\">Access-Control-Max-Age</span><span class=\"hljs-punctuation\">: </span>86400<br></code></pre></td></tr></table></figure>\n\n<p>  浏览器确认服务器响应的<code>Access-Control-Allow-Methods</code>头确实包含将要发送的AJAX请求的Method，才会继续发送AJAX，否则，抛出一个错误。</p>\n<p>  由于以POST、PUT方式传送JSON格式的数据在REST中很常见，所以要跨域正确处理POST和PUT请求，服务器端必须正确响应OPTIONS请求。</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li>cookie跨域 </li>\n</ol>\n<ul>\n<li><p>document.domain跨域，与iframe类似</p>\n</li>\n<li><p>Jsonp跨域</p>\n</li>\n<li><p>Ajax+cors跨域<br>默认情况下，标准的跨域请求是不会发送不同源的cookie的</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> xhr = <span class=\"hljs-keyword\">new</span> XMLHttpRequest();<br>xhr.withCredentials = <span class=\"hljs-literal\">true</span>;<br></code></pre></td></tr></table></figure>\n<p>  为了安全，标准里不允许 <code>Access-Control-Allow-Origin: *</code>，<code>*</code>必须指定明确的、与请求网页一致的域名。</p>\n</li>\n</ul>\n<ol start=\"5\">\n<li>LocalStorage跨域</li>\n</ol>\n<ul>\n<li>postMessage</li>\n</ul>\n<p>参考：<br><a href=\"https://blog.csdn.net/hansexploration/article/details/80314948\">https://blog.csdn.net/hansexploration/article/details/80314948</a><br><a href=\"http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html\">http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</a><br><a href=\"https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400\">https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400</a><br><a href=\"https://blog.csdn.net/shuidinaozhongyan/article/details/78155310\">https://blog.csdn.net/shuidinaozhongyan/article/details/78155310</a><br><a href=\"https://blog.csdn.net/chou_out_man/article/details/80664413\">https://blog.csdn.net/chou_out_man/article/details/80664413</a><br><a href=\"https://blog.csdn.net/itcats_cn/article/details/82318092\">https://blog.csdn.net/itcats_cn/article/details/82318092</a><br><a href=\"https://www.cnblogs.com/happy-8090/p/11570998.html\">https://www.cnblogs.com/happy-8090/p/11570998.html</a></p>\n","site":{"data":{}},"wordcount":6740,"excerpt":"","more":"<p>同源策略是对JavaScript代码能够操作哪些web内容的一条完整的安全限制。</p>\n<h3 id=\"什么是同源\"><a href=\"#什么是同源\" class=\"headerlink\" title=\"什么是同源\"></a>什么是同源</h3><p>URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。<br>下表给出了相对<code>http://store.company.com/dir/page.html</code>同源检测的示例:</p>\n<table>\n<thead>\n<tr>\n<th>URL</th>\n<th>结果</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"http://store.company.com/dir2/other.html\">http://store.company.com/dir2/other.html</a></td>\n<td>成功</td>\n<td>只有路径不同</td>\n</tr>\n<tr>\n<td><a href=\"http://store.company.com/dir/inner/another.html\">http://store.company.com/dir/inner/another.html</a></td>\n<td>成功</td>\n<td>只有路径不同</td>\n</tr>\n<tr>\n<td><a href=\"https://store.company.com/secure.html\">https://store.company.com/secure.html</a></td>\n<td>失败</td>\n<td>不同协议 ( https和http )</td>\n</tr>\n<tr>\n<td><a href=\"http://store.company.com:81/dir/etc.html\">http://store.company.com:81/dir/etc.html</a></td>\n<td>失败</td>\n<td>不同端口 ( http:// 80是默认的)</td>\n</tr>\n<tr>\n<td><a href=\"http://news.company.com/dir/other.html\">http://news.company.com/dir/other.html</a></td>\n<td>失败</td>\n<td>不同域名 ( news和store )</td>\n</tr>\n</tbody></table>\n<h3 id=\"同源策略阻止什么\"><a href=\"#同源策略阻止什么\" class=\"headerlink\" title=\"同源策略阻止什么\"></a>同源策略阻止什么</h3><p>同源策略最初由网景公司添加到浏览器，当前所有的浏览器都支持此功能。</p>\n<p>初始的功能是为了限制非同域网页之间cookie的访问，例如a.html页面无法访问非同域的b.html页面的cookie。</p>\n<p> 功能是为了保护网站信息安全，比如，一个电脑可以访问很多网站，总不能此网站可以读取另一个网站的信息，尤其是涉及到重要信息，比如用户名和密码。</p>\n<p>随着浏览器功能的增强，同源策略由最初限制cookie的访问，发展到限制多种本地信息:</p>\n<ul>\n<li><p> Cookie、LocalStorage 和 IndexedDB访问限制。<br>a.html的脚本无法访问b.html页面下的上述种类浏览器缓存，为了防止恶意网站通过js获取用户其他网站的cookie。</p>\n</li>\n<li><p>DOM获取限制。<br>在浏览器中，<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;link&gt;</code>等含有<code>src</code>属性的标签都可以加载跨域资源，而不受同源限制，但浏览器限制了JavaScript的权限使其不能读、写加载的内容。<br>如果没有这一条，恶意网站可以通过iframe打开银行页面，可以获取dom就相当于可以获取整个银行页面的信息。</p>\n</li>\n<li><p>限制 ajax 请求，准确来说是限制操作 ajax 响应结果，本质上跟上一条是一样的</p>\n<blockquote>\n<p>假设有一个黑客叫做小黑，他从网上抓取了一堆美女图做了一个网站，每日访问量爆表。<br>为了维护网站运行，小黑挂了一张收款码，觉得网站不错的可以适当资助一点，可是无奈伸手党太多，小黑的网站入不敷出。<br>于是他非常生气的在网页中写了一段js代码，使用ajax向淘宝发起登陆请求，因为很多数人都访问过淘宝，所以电脑中存有淘宝的cookie，不需要输入账号密码直接就自动登录了，然后小黑在ajax回调函数中解析了淘宝返回的数据，得到了很多人的隐私信息，转手一卖，小黑的网站终于盈利了。<br>如果跨域也可以发送AJAX请求的话，小黑就真的获取到了用户的隐私并成功获利了！！！</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"同源策略允许什么\"><a href=\"#同源策略允许什么\" class=\"headerlink\" title=\"同源策略允许什么\"></a>同源策略允许什么</h3><ul>\n<li>同源策略只对网页的HTML文档做了限制，对加载的其他静态资源如javascript、css、图片等仍然认为属于同源。</li>\n<li>页面中的<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;ifram&gt;</code>、<code>&lt;link&gt;</code>等标签、重定向以及表单提交是不会受到同源策略限制的，比如在网站<code>www.foo.com</code>下提交一个表单到<code>www.bar.com</code>是完全可以的。</li>\n<li>跨域资源嵌入是允许的。<br>脚本本身的来源和同源策略并不相关，相关的是脚本所嵌入的文档的来源，理解这一点很重要。例如、假设一个来自主机A的脚本被包含到（使用<code>&lt;script&gt;</code>标记的src属性）宿主B的一个web页面中。这个脚本的来源就是主机B而不是A，并且可以完整的访问包含它的文档内容。如果脚本打开一个新的窗口载入来自主机B的另一个文档，脚本对这个文档的内容也完全具有访问权限。但是，如果脚本打开第三个窗口并载入一个来自主机C吃文档（或者是主机A），同源策略会发挥作用，阻止脚本访问这个文档。<h3 id=\"如何跨域\"><a href=\"#如何跨域\" class=\"headerlink\" title=\"如何跨域\"></a>如何跨域</h3></li>\n</ul>\n<p>1.iframe跨域 <a href=\"https://www.cnblogs.com/happy-8090/p/11570998.html\">参考happy哥</a></p>\n<ul>\n<li><p><code>document.domain</code>跨域</p>\n<p>  <strong>此方案仅限主域相同，子域不同的跨域应用场景。</strong></p>\n<p>  同源策略会给那些使用多个子域的大站点带来一些问题。如，来自<code>home.example.com</code>的文档里脚本想要合法的读取从<code>developer.example.com</code>上的文档的属性。为了支持这种类型的多域名站点，可以使用Document对象的<code>domain</code>属性。在默认情况下，属性<code>domain</code>存放的是载入文档的服务器的主机名。可以设置这一个属性，不过字符串必须具有有效的域前缀或他本身。因此，如果一个<code>domain</code>属性的初始值是字符串<code>home.example.com</code>，就可以把它设置为<code>example.com</code>。但是不能设置为<code>home.example</code>或者<code>ample.com</code>。另外<code>domain</code>值中必须有一个.，不能把它设置为<code>com</code>或其他顶级域名。如果两个窗口（或窗体）包含的脚本把domain设置成了相同的值，那么这两个窗口就不会再受同源策略的约束。<br>  在<code>home.example.com</code>和<code>developer.example.com</code>的文档同时使用脚本设置</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">document</span>.domain = <span class=\"hljs-string\">&#x27;example.com&#x27;</span><br></code></pre></td></tr></table></figure>\n<p>  实现跨域，<strong>cookie</strong>也可以用这种方法实现跨域</p>\n</li>\n</ul>\n<ul>\n<li><p><code>location.hash</code> 跨域<br>当主域不同时，可以使用此方法<br>在url中，<code>http://www.baidu.com#helloword</code>的<code>#helloworad</code>就是<code>location.hash</code>，改变hash值不会导致页面刷新，所以可以利用hash值来进行数据的传递，当然数据量是有限的。<br>父窗口可以把信息，写入子窗口的<code>location.hash</code>。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> src = originURL + <span class=\"hljs-string\">&#x27;#&#x27;</span> + data;<br><span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;myIFrame&#x27;</span>).src = src;<br></code></pre></td></tr></table></figure>\n<p>  子窗口通过监听<code>hashchange</code>事件得到通知。</p>\n</li>\n</ul>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">window</span>.onhashchange = checkMessage;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">checkMessage</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">var</span> message = <span class=\"hljs-built_in\">window</span>.location.hash;<br>  <span class=\"hljs-comment\">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n同样的，子窗口也可以改变父窗口的片段标识符。\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">parent.location.href= target + <span class=\"hljs-string\">&quot;#&quot;</span> + hash;<br></code></pre></td></tr></table></figure>\n</code></pre>\n<ul>\n<li><p><code>window.name</code>跨域<br><code>window.name</code>（一般在js代码里出现）的值不是一个普通的全局变量，而是当前窗口的名字，要注意的是每个iframe都有包裹它的window，而这个window是top window的子窗口，而它自然也有window.name的属性，window.name属性的神奇之处在于name值在不同的页面（甚至不同域名）加载后依旧存在（如果没有修改则值不会变化），并且可以支持非常长的name值（2MB）<br>举个简单的例子：你在某个页面的控制台输入：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">window</span>.name = <span class=\"hljs-string\">&quot;hello world&quot;</span><br><span class=\"hljs-built_in\">window</span>.location = <span class=\"hljs-string\">&quot;http://www.baidu.com&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>  页面跳转到了百度首页<br>  <img src=\"https://img-blog.csdnimg.cn/20200216152224507.png\" alt=\"在这里插入图片描述\"><br>  但是<code>window.name</code>却被保存下来了，还是<code>hello world</code>。</p>\n<blockquote>\n<p>这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。</p>\n</blockquote>\n</li>\n<li><p>跨文本消息 <code>postMessage</code><br><code>postMessage</code> 是 HTML5 新增加的一项功能，跨文档消息传输(Cross Document Messaging)，目前：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 都支持这项功能。<br>举例来说，父窗口<code>http://aaa.com</code>向子窗口<code>http://bbb.com</code>发消息，调用<code>postMessage</code>方法就可以了。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> popup = <span class=\"hljs-built_in\">window</span>.open(<span class=\"hljs-string\">&#x27;http://bbb.com&#x27;</span>, <span class=\"hljs-string\">&#x27;title&#x27;</span>);<br>popup.postMessage(<span class=\"hljs-string\">&#x27;Hello World!&#x27;</span>, <span class=\"hljs-string\">&#x27;http://bbb.com&#x27;</span>);<br></code></pre></td></tr></table></figure>\n<p>  子窗口向父窗口发送消息的写法类似。</p>\n</li>\n</ul>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">window</span>.opener.postMessage(<span class=\"hljs-string\">&#x27;Nice to see you&#x27;</span>, <span class=\"hljs-string\">&#x27;http://aaa.com&#x27;</span>);<br></code></pre></td></tr></table></figure>\n父窗口和子窗口都可以通过message事件，监听对方的消息。\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">&#x27;message&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>) </span>&#123;<br><span class=\"hljs-built_in\">console</span>.log(e.data);<br>&#125;,<span class=\"hljs-literal\">false</span>);<br></code></pre></td></tr></table></figure>\nmessage事件的事件对象event，提供以下三个属性。\n\n<figure class=\"highlight mel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mel\"><span class=\"hljs-keyword\">event</span>.<span class=\"hljs-keyword\">source</span>：发送消息的窗口<br><span class=\"hljs-keyword\">event</span>.origin: 消息发向的网址<br><span class=\"hljs-keyword\">event</span>.data: 消息内容<br></code></pre></td></tr></table></figure>\n</code></pre>\n<ol start=\"2\">\n<li>Ajax跨域</li>\n</ol>\n<ul>\n<li><p>Jsonp<br>JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。</p>\n<p>  它的基本思想是，网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</p>\n<p>  首先，网页动态插入<code>&lt;script&gt;</code>元素，由它向跨源网址发出请求。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addScriptTag</span>(<span class=\"hljs-params\">src</span>) </span>&#123;<span class=\"hljs-comment\">//定义添加script标签函数</span><br><span class=\"hljs-keyword\">var</span> script = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">&#x27;script&#x27;</span>);<br>script.setAttribute(<span class=\"hljs-string\">&quot;type&quot;</span>,<span class=\"hljs-string\">&quot;text/javascript&quot;</span>);<br>script.src = src;<br><span class=\"hljs-built_in\">document</span>.body.appendChild(script);<br>&#125;<br><span class=\"hljs-built_in\">window</span>.onload = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<span class=\"hljs-comment\">//当文档加载完成时，发送Jsonp请求</span><br>  addScriptTag(<span class=\"hljs-string\">&#x27;http://example.com/ip?code=123&amp;callback=foo&#x27;</span>);<br>  <span class=\"hljs-comment\">//url中包含code需要的数据，与需要的回调函数callback</span><br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">data</span>) </span>&#123;<span class=\"hljs-comment\">//回调函数，当数据返回时，调用</span><br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;Your public IP address is: &#x27;</span> + data.ip);<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>  上面代码通过动态添加<code>&lt;script&gt;</code>元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。<br>  服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">foo(&#123;<br>    <span class=\"hljs-string\">&quot;ip&quot;</span>: <span class=\"hljs-string\">&quot;8.8.8.8&quot;</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>  由于<code>&lt;script&gt;</code>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。</p>\n</li>\n<li><p>CORS跨域资源共享<br>CORS的主要工作在后端，是HTML5规范定义的如何跨域访问资源。<br>Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。<br>用一个图来表示就是：<br><img src=\"https://img-blog.csdnimg.cn/20200216161317768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>假设本域是<code>my.com</code>，外域是<code>sina.com</code>，只要响应头<code>Access-Control-Allow-Origin</code>为<code>http://my.com</code>，或者是<code>*</code>，本次请求就可以成功。</p>\n<p>  可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的<code>Access-Control-Allow-Origin</code>，决定权始终在对方手中。</p>\n<p>  上面这种跨域请求，称之为“简单请求”。简单请求包括GET、HEAD和POST（POST的Content-Type类型 仅限<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>和<code>text/plain</code>），并且不能出现任何自定义头（例如，X-Custom: 12345），通常能满足90%的需求。</p>\n<p>  无论你是否需要用JavaScript通过CORS跨域请求资源，你都要了解CORS的原理。最新的浏览器全面支持HTML5。在引用外域资源时，除了JavaScript和CSS外，都要验证CORS。例如，当你引用了某个第三方CDN上的字体文件时：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/* CSS */</span><br>@font-face &#123;<br>  font-family: <span class=\"hljs-string\">&#x27;FontAwesome&#x27;</span>;<br>  src: url(<span class=\"hljs-string\">&#x27;http://cdn.com/fonts/fontawesome.ttf&#x27;</span>) format(<span class=\"hljs-string\">&#x27;truetype&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>  如果该CDN服务商未正确设置<code>Access-Control-Allow-Origin</code>，那么浏览器无法加载字体资源。</p>\n<p>  对于<code>PUT</code>、<code>DELETE</code>以及其他类型如<code>application/json</code>的POST请求，在发送AJAX请求之前，浏览器会先发送一个OPTIONS请求（称为preflighted请求）到这个URL上，询问目标服务器是否接受：</p>\n  <figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs oxygene\">OPTIONS /path/<span class=\"hljs-keyword\">to</span>/resource HTTP/<span class=\"hljs-number\">1.1</span><br>Host: bar.com<br>Origin: http:<span class=\"hljs-comment\">//my.com</span><br>Access-Control-Request-<span class=\"hljs-function\"><span class=\"hljs-keyword\">Method</span>:</span> POST<br></code></pre></td></tr></table></figure>\n\n<p>  服务器必须响应并明确指出允许的Method：</p>\n  <figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs http\"><span class=\"hljs-meta\">HTTP/1.1</span> <span class=\"hljs-number\">200</span> OK<br><span class=\"hljs-attribute\">Access-Control-Allow-Origin</span><span class=\"hljs-punctuation\">: </span>http://my.com<br><span class=\"hljs-attribute\">Access-Control-Allow-Methods</span><span class=\"hljs-punctuation\">: </span>POST, GET, PUT, OPTIONS<br><span class=\"hljs-attribute\">Access-Control-Max-Age</span><span class=\"hljs-punctuation\">: </span>86400<br></code></pre></td></tr></table></figure>\n\n<p>  浏览器确认服务器响应的<code>Access-Control-Allow-Methods</code>头确实包含将要发送的AJAX请求的Method，才会继续发送AJAX，否则，抛出一个错误。</p>\n<p>  由于以POST、PUT方式传送JSON格式的数据在REST中很常见，所以要跨域正确处理POST和PUT请求，服务器端必须正确响应OPTIONS请求。</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li>cookie跨域 </li>\n</ol>\n<ul>\n<li><p>document.domain跨域，与iframe类似</p>\n</li>\n<li><p>Jsonp跨域</p>\n</li>\n<li><p>Ajax+cors跨域<br>默认情况下，标准的跨域请求是不会发送不同源的cookie的</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> xhr = <span class=\"hljs-keyword\">new</span> XMLHttpRequest();<br>xhr.withCredentials = <span class=\"hljs-literal\">true</span>;<br></code></pre></td></tr></table></figure>\n<p>  为了安全，标准里不允许 <code>Access-Control-Allow-Origin: *</code>，<code>*</code>必须指定明确的、与请求网页一致的域名。</p>\n</li>\n</ul>\n<ol start=\"5\">\n<li>LocalStorage跨域</li>\n</ol>\n<ul>\n<li>postMessage</li>\n</ul>\n<p>参考：<br><a href=\"https://blog.csdn.net/hansexploration/article/details/80314948\">https://blog.csdn.net/hansexploration/article/details/80314948</a><br><a href=\"http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html\">http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</a><br><a href=\"https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400\">https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400</a><br><a href=\"https://blog.csdn.net/shuidinaozhongyan/article/details/78155310\">https://blog.csdn.net/shuidinaozhongyan/article/details/78155310</a><br><a href=\"https://blog.csdn.net/chou_out_man/article/details/80664413\">https://blog.csdn.net/chou_out_man/article/details/80664413</a><br><a href=\"https://blog.csdn.net/itcats_cn/article/details/82318092\">https://blog.csdn.net/itcats_cn/article/details/82318092</a><br><a href=\"https://www.cnblogs.com/happy-8090/p/11570998.html\">https://www.cnblogs.com/happy-8090/p/11570998.html</a></p>\n"},{"title":"Hexo博客使用Github_Webhook自动部署到个人服务器","date":"2022-02-10T03:16:21.000Z","index_img":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","_content":"\n最近想把之前写的博客重新注册一个域名放到网上，地址：[https://luoluoqinghuan.cn/](https://luoluoqinghuan.cn/)\n。博客框架使用的是hexo，部署到服务器上也很简单，把hexo生成的网站文件放在服务器上，用koa-static起一个服务就行了。\n\n但这是一种非常麻烦的部署方式，每次更新博客都要登陆服务器手动上传，如果想要自动更新网站就要解决两个问题：\n+ 从哪里拿到最新的代码（github）\n+ 如何知道代码已经更新（github-webhook）\n## What Is Webhook\n\nwebhook是github提供的一个钩子，这个钩子在触发github一些事件后，会向配置好的地址发一个http请求。在`任何一个仓库 -> Setting -> Webhooks` 可以进行配置。我们可以在服务器上监听这个请求，就可以知道更新网站的时机了。\n\ngithub提供的事件非常丰富，有20多种，几乎覆盖了所有git相关的操作，比如打了个tag、新建了branch、有新的commit等。\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/882c8bc589534941bd19cc2ffc53053a~tplv-k3u1fbpfcp-watermark.image?)\n\n了解到这里，我们就知道如何去自动部署我们的博客网站了，首先将博客源码推到github上，并配置webhook，针对push事件进行监听，在个人服务器上另起一个服务，接收webhook的请求，收到请求后拉取最新代码并重新构建，done！\n\n## 实现-web服务\n我们有两个服务，一个是网站服务，一个是webhook监听服务。咱们一个一个来\n```javascript\n// 网站服务 hexo_server.js\nconst serve = require('koa-static');\nconst Koa = require('koa');\nconst app = new Koa();\n \nconst fs = require('fs')\nconst http = require('http')\nconst https = require('https')\nconst enforceHttps = require('koa-sslify').default\n\napp.use(enforceHttps())\napp.use(serve('public'));\n \nconst options = {\n\tkey: fs.readFileSync('./ssl/luoluoqinghuan.cn.key'),\n\tcert: fs.readFileSync('./ssl/luoluoqinghuan.cn.pem')\n}\n\nhttp.createServer(app.callback()).listen(80);\nhttps.createServer(options, app.callback()).listen(443)\nconsole.log('listening on port 80 443');\n\n```\n直接使用koa-static这个中间件，很容易就可以将网站跑起来，我还在腾讯云申请了免费的证书，这样网站就可以支持https了，虽然一个简单的静态网站好像不需要https，但使用https可以帮助博客在搜索引擎中的排名更高一些。\n\n## 实现-webhook服务\n首先要在博客仓库里配置webhook\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51073488f70a43998748ab2094c5ec0c~tplv-k3u1fbpfcp-watermark.image?)\n\n在payloadUrl中填入你服务器的地址，webhook的http请求会发向该地址，secret是密码，webhook会在请求头中使用此密码生成哈希值，供我们鉴权使用，events我们选第一个就可以了，我们在本地写完文章，push上去，触发webhook回调，点击add就添加成功了\n\n接下来就可以写一下服务了。\n```javascript\n// webhook服务 webhook_server.js\nconst Koa = require('koa');\nconst app = new Koa();\nconst child_process = require('child_process')\nconst crypto = require('crypto')\nconst bodyParser = require('koa-bodyparser')\n\nconst sigHeaderName = 'x-hub-signature-256'\nconst sigHashAlg = 'sha256'\n\napp.use(bodyParser())\n\nconst secret = '123456'\n\nconst main = ctx => {\n  // 鉴权\n  const sig = Buffer.from(ctx.request.headers[`${sigHeaderName}`] || '', 'utf8')\n  const hmac = crypto.createHmac(sigHashAlg, secret)\n  const digest = Buffer.from(sigHashAlg + '=' + hmac.update(ctx.request.rawBody).digest('hex'), 'utf8')\n  if (sig.length !== digest.length || !crypto.timingSafeEqual(digest, sig)) {\n    console.log(`Request body digest (${digest}) did not match ${sigHeaderName} (${sig})`)\n    ctx.status = 403\n    return\n  }\n\n  console.log('start cmd')\n  // 拉取最新代码\n  const cmd = 'git checkout . && git pull'\n\n  try{\n    const log = child_process.spawnSync(cmd, {shell: true})\n    console.log(log.stdout.toString())\n  }catch(e){\n    console.error(e.toString())\n    const response = {code: 500, message: 'update failed'}\n    ctx.response.body = response\n    ctx.status = 500\n    return;\n  }\n\n  // build网站\n  const cmd1 = 'hexo clean && hexo generate'\n  try{\n    const log1 = child_process.spawnSync(cmd1, {shell: true})\n    console.log(log1.stdout.toString())\n    console.log('hexo blog update successed !!!!')\n    const response = {code: 200, message: 'update successfully'}\n    ctx.response.body = response\n    ctx.status = 200\n    return;\n  }catch(e){\n    console.log(e.toString())\n    console.log('hexo blog update failed !!!!')\n    const response = {code: 500, message: 'failed'}\n    ctx.response.body = response\n    ctx.status = 500\n    return;\n  }\n}\napp.use(main);\napp.listen(3000);\nconsole.log('github hook server listen at port 3000')\n```\n这样，我们的监听服务就搞定了，跑起来（推荐使用pm2），写一下文章，然后push一下，可以看到我们自动部署服务成功了。最新的文章也出现在了网站上。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9aacf4c41b6c42458e25936ee383797a~tplv-k3u1fbpfcp-watermark.image?)\n\n","source":"_posts/Hexo博客使用Github自动部署到个人服务器.md","raw":"---\ntitle: Hexo博客使用Github_Webhook自动部署到个人服务器\ndate: 2022-02-10 11:16:21\nindex_img: https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg\ntags: [hexo, 前端工程化]\ncategories: [CI/CD]\n---\n\n最近想把之前写的博客重新注册一个域名放到网上，地址：[https://luoluoqinghuan.cn/](https://luoluoqinghuan.cn/)\n。博客框架使用的是hexo，部署到服务器上也很简单，把hexo生成的网站文件放在服务器上，用koa-static起一个服务就行了。\n\n但这是一种非常麻烦的部署方式，每次更新博客都要登陆服务器手动上传，如果想要自动更新网站就要解决两个问题：\n+ 从哪里拿到最新的代码（github）\n+ 如何知道代码已经更新（github-webhook）\n## What Is Webhook\n\nwebhook是github提供的一个钩子，这个钩子在触发github一些事件后，会向配置好的地址发一个http请求。在`任何一个仓库 -> Setting -> Webhooks` 可以进行配置。我们可以在服务器上监听这个请求，就可以知道更新网站的时机了。\n\ngithub提供的事件非常丰富，有20多种，几乎覆盖了所有git相关的操作，比如打了个tag、新建了branch、有新的commit等。\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/882c8bc589534941bd19cc2ffc53053a~tplv-k3u1fbpfcp-watermark.image?)\n\n了解到这里，我们就知道如何去自动部署我们的博客网站了，首先将博客源码推到github上，并配置webhook，针对push事件进行监听，在个人服务器上另起一个服务，接收webhook的请求，收到请求后拉取最新代码并重新构建，done！\n\n## 实现-web服务\n我们有两个服务，一个是网站服务，一个是webhook监听服务。咱们一个一个来\n```javascript\n// 网站服务 hexo_server.js\nconst serve = require('koa-static');\nconst Koa = require('koa');\nconst app = new Koa();\n \nconst fs = require('fs')\nconst http = require('http')\nconst https = require('https')\nconst enforceHttps = require('koa-sslify').default\n\napp.use(enforceHttps())\napp.use(serve('public'));\n \nconst options = {\n\tkey: fs.readFileSync('./ssl/luoluoqinghuan.cn.key'),\n\tcert: fs.readFileSync('./ssl/luoluoqinghuan.cn.pem')\n}\n\nhttp.createServer(app.callback()).listen(80);\nhttps.createServer(options, app.callback()).listen(443)\nconsole.log('listening on port 80 443');\n\n```\n直接使用koa-static这个中间件，很容易就可以将网站跑起来，我还在腾讯云申请了免费的证书，这样网站就可以支持https了，虽然一个简单的静态网站好像不需要https，但使用https可以帮助博客在搜索引擎中的排名更高一些。\n\n## 实现-webhook服务\n首先要在博客仓库里配置webhook\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51073488f70a43998748ab2094c5ec0c~tplv-k3u1fbpfcp-watermark.image?)\n\n在payloadUrl中填入你服务器的地址，webhook的http请求会发向该地址，secret是密码，webhook会在请求头中使用此密码生成哈希值，供我们鉴权使用，events我们选第一个就可以了，我们在本地写完文章，push上去，触发webhook回调，点击add就添加成功了\n\n接下来就可以写一下服务了。\n```javascript\n// webhook服务 webhook_server.js\nconst Koa = require('koa');\nconst app = new Koa();\nconst child_process = require('child_process')\nconst crypto = require('crypto')\nconst bodyParser = require('koa-bodyparser')\n\nconst sigHeaderName = 'x-hub-signature-256'\nconst sigHashAlg = 'sha256'\n\napp.use(bodyParser())\n\nconst secret = '123456'\n\nconst main = ctx => {\n  // 鉴权\n  const sig = Buffer.from(ctx.request.headers[`${sigHeaderName}`] || '', 'utf8')\n  const hmac = crypto.createHmac(sigHashAlg, secret)\n  const digest = Buffer.from(sigHashAlg + '=' + hmac.update(ctx.request.rawBody).digest('hex'), 'utf8')\n  if (sig.length !== digest.length || !crypto.timingSafeEqual(digest, sig)) {\n    console.log(`Request body digest (${digest}) did not match ${sigHeaderName} (${sig})`)\n    ctx.status = 403\n    return\n  }\n\n  console.log('start cmd')\n  // 拉取最新代码\n  const cmd = 'git checkout . && git pull'\n\n  try{\n    const log = child_process.spawnSync(cmd, {shell: true})\n    console.log(log.stdout.toString())\n  }catch(e){\n    console.error(e.toString())\n    const response = {code: 500, message: 'update failed'}\n    ctx.response.body = response\n    ctx.status = 500\n    return;\n  }\n\n  // build网站\n  const cmd1 = 'hexo clean && hexo generate'\n  try{\n    const log1 = child_process.spawnSync(cmd1, {shell: true})\n    console.log(log1.stdout.toString())\n    console.log('hexo blog update successed !!!!')\n    const response = {code: 200, message: 'update successfully'}\n    ctx.response.body = response\n    ctx.status = 200\n    return;\n  }catch(e){\n    console.log(e.toString())\n    console.log('hexo blog update failed !!!!')\n    const response = {code: 500, message: 'failed'}\n    ctx.response.body = response\n    ctx.status = 500\n    return;\n  }\n}\napp.use(main);\napp.listen(3000);\nconsole.log('github hook server listen at port 3000')\n```\n这样，我们的监听服务就搞定了，跑起来（推荐使用pm2），写一下文章，然后push一下，可以看到我们自动部署服务成功了。最新的文章也出现在了网站上。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9aacf4c41b6c42458e25936ee383797a~tplv-k3u1fbpfcp-watermark.image?)\n\n","slug":"Hexo博客使用Github自动部署到个人服务器","published":1,"updated":"2025-06-10T04:39:28.844Z","_id":"ckzgq58r80000o969hgrbefc5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近想把之前写的博客重新注册一个域名放到网上，地址：<a href=\"https://luoluoqinghuan.cn/\">https://luoluoqinghuan.cn/</a><br>。博客框架使用的是hexo，部署到服务器上也很简单，把hexo生成的网站文件放在服务器上，用koa-static起一个服务就行了。</p>\n<p>但这是一种非常麻烦的部署方式，每次更新博客都要登陆服务器手动上传，如果想要自动更新网站就要解决两个问题：</p>\n<ul>\n<li>从哪里拿到最新的代码（github）</li>\n<li>如何知道代码已经更新（github-webhook）<h2 id=\"What-Is-Webhook\"><a href=\"#What-Is-Webhook\" class=\"headerlink\" title=\"What Is Webhook\"></a>What Is Webhook</h2></li>\n</ul>\n<p>webhook是github提供的一个钩子，这个钩子在触发github一些事件后，会向配置好的地址发一个http请求。在<code>任何一个仓库 -&gt; Setting -&gt; Webhooks</code> 可以进行配置。我们可以在服务器上监听这个请求，就可以知道更新网站的时机了。</p>\n<p>github提供的事件非常丰富，有20多种，几乎覆盖了所有git相关的操作，比如打了个tag、新建了branch、有新的commit等。<br><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/882c8bc589534941bd19cc2ffc53053a~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>了解到这里，我们就知道如何去自动部署我们的博客网站了，首先将博客源码推到github上，并配置webhook，针对push事件进行监听，在个人服务器上另起一个服务，接收webhook的请求，收到请求后拉取最新代码并重新构建，done！</p>\n<h2 id=\"实现-web服务\"><a href=\"#实现-web服务\" class=\"headerlink\" title=\"实现-web服务\"></a>实现-web服务</h2><p>我们有两个服务，一个是网站服务，一个是webhook监听服务。咱们一个一个来</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 网站服务 hexo_server.js</span><br><span class=\"hljs-keyword\">const</span> serve = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;koa-static&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> Koa = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;koa&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> Koa();<br> <br><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;fs&#x27;</span>)<br><span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;http&#x27;</span>)<br><span class=\"hljs-keyword\">const</span> https = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;https&#x27;</span>)<br><span class=\"hljs-keyword\">const</span> enforceHttps = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;koa-sslify&#x27;</span>).default<br><br>app.use(enforceHttps())<br>app.use(serve(<span class=\"hljs-string\">&#x27;public&#x27;</span>));<br> <br><span class=\"hljs-keyword\">const</span> options = &#123;<br>\t<span class=\"hljs-attr\">key</span>: fs.readFileSync(<span class=\"hljs-string\">&#x27;./ssl/luoluoqinghuan.cn.key&#x27;</span>),<br>\t<span class=\"hljs-attr\">cert</span>: fs.readFileSync(<span class=\"hljs-string\">&#x27;./ssl/luoluoqinghuan.cn.pem&#x27;</span>)<br>&#125;<br><br>http.createServer(app.callback()).listen(<span class=\"hljs-number\">80</span>);<br>https.createServer(options, app.callback()).listen(<span class=\"hljs-number\">443</span>)<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;listening on port 80 443&#x27;</span>);<br><br></code></pre></td></tr></table></figure>\n<p>直接使用koa-static这个中间件，很容易就可以将网站跑起来，我还在腾讯云申请了免费的证书，这样网站就可以支持https了，虽然一个简单的静态网站好像不需要https，但使用https可以帮助博客在搜索引擎中的排名更高一些。</p>\n<h2 id=\"实现-webhook服务\"><a href=\"#实现-webhook服务\" class=\"headerlink\" title=\"实现-webhook服务\"></a>实现-webhook服务</h2><p>首先要在博客仓库里配置webhook</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51073488f70a43998748ab2094c5ec0c~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>在payloadUrl中填入你服务器的地址，webhook的http请求会发向该地址，secret是密码，webhook会在请求头中使用此密码生成哈希值，供我们鉴权使用，events我们选第一个就可以了，我们在本地写完文章，push上去，触发webhook回调，点击add就添加成功了</p>\n<p>接下来就可以写一下服务了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// webhook服务 webhook_server.js</span><br><span class=\"hljs-keyword\">const</span> Koa = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;koa&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> Koa();<br><span class=\"hljs-keyword\">const</span> child_process = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;child_process&#x27;</span>)<br><span class=\"hljs-keyword\">const</span> crypto = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;crypto&#x27;</span>)<br><span class=\"hljs-keyword\">const</span> bodyParser = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;koa-bodyparser&#x27;</span>)<br><br><span class=\"hljs-keyword\">const</span> sigHeaderName = <span class=\"hljs-string\">&#x27;x-hub-signature-256&#x27;</span><br><span class=\"hljs-keyword\">const</span> sigHashAlg = <span class=\"hljs-string\">&#x27;sha256&#x27;</span><br><br>app.use(bodyParser())<br><br><span class=\"hljs-keyword\">const</span> secret = <span class=\"hljs-string\">&#x27;123456&#x27;</span><br><br><span class=\"hljs-keyword\">const</span> main = <span class=\"hljs-function\"><span class=\"hljs-params\">ctx</span> =&gt;</span> &#123;<br>  <span class=\"hljs-comment\">// 鉴权</span><br>  <span class=\"hljs-keyword\">const</span> sig = Buffer.from(ctx.request.headers[<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;sigHeaderName&#125;</span>`</span>] || <span class=\"hljs-string\">&#x27;&#x27;</span>, <span class=\"hljs-string\">&#x27;utf8&#x27;</span>)<br>  <span class=\"hljs-keyword\">const</span> hmac = crypto.createHmac(sigHashAlg, secret)<br>  <span class=\"hljs-keyword\">const</span> digest = Buffer.from(sigHashAlg + <span class=\"hljs-string\">&#x27;=&#x27;</span> + hmac.update(ctx.request.rawBody).digest(<span class=\"hljs-string\">&#x27;hex&#x27;</span>), <span class=\"hljs-string\">&#x27;utf8&#x27;</span>)<br>  <span class=\"hljs-keyword\">if</span> (sig.length !== digest.length || !crypto.timingSafeEqual(digest, sig)) &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Request body digest (<span class=\"hljs-subst\">$&#123;digest&#125;</span>) did not match <span class=\"hljs-subst\">$&#123;sigHeaderName&#125;</span> (<span class=\"hljs-subst\">$&#123;sig&#125;</span>)`</span>)<br>    ctx.status = <span class=\"hljs-number\">403</span><br>    <span class=\"hljs-keyword\">return</span><br>  &#125;<br><br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;start cmd&#x27;</span>)<br>  <span class=\"hljs-comment\">// 拉取最新代码</span><br>  <span class=\"hljs-keyword\">const</span> cmd = <span class=\"hljs-string\">&#x27;git checkout . &amp;&amp; git pull&#x27;</span><br><br>  <span class=\"hljs-keyword\">try</span>&#123;<br>    <span class=\"hljs-keyword\">const</span> log = child_process.spawnSync(cmd, &#123;<span class=\"hljs-attr\">shell</span>: <span class=\"hljs-literal\">true</span>&#125;)<br>    <span class=\"hljs-built_in\">console</span>.log(log.stdout.toString())<br>  &#125;<span class=\"hljs-keyword\">catch</span>(e)&#123;<br>    <span class=\"hljs-built_in\">console</span>.error(e.toString())<br>    <span class=\"hljs-keyword\">const</span> response = &#123;<span class=\"hljs-attr\">code</span>: <span class=\"hljs-number\">500</span>, <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;update failed&#x27;</span>&#125;<br>    ctx.response.body = response<br>    ctx.status = <span class=\"hljs-number\">500</span><br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// build网站</span><br>  <span class=\"hljs-keyword\">const</span> cmd1 = <span class=\"hljs-string\">&#x27;hexo clean &amp;&amp; hexo generate&#x27;</span><br>  <span class=\"hljs-keyword\">try</span>&#123;<br>    <span class=\"hljs-keyword\">const</span> log1 = child_process.spawnSync(cmd1, &#123;<span class=\"hljs-attr\">shell</span>: <span class=\"hljs-literal\">true</span>&#125;)<br>    <span class=\"hljs-built_in\">console</span>.log(log1.stdout.toString())<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;hexo blog update successed !!!!&#x27;</span>)<br>    <span class=\"hljs-keyword\">const</span> response = &#123;<span class=\"hljs-attr\">code</span>: <span class=\"hljs-number\">200</span>, <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;update successfully&#x27;</span>&#125;<br>    ctx.response.body = response<br>    ctx.status = <span class=\"hljs-number\">200</span><br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<span class=\"hljs-keyword\">catch</span>(e)&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(e.toString())<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;hexo blog update failed !!!!&#x27;</span>)<br>    <span class=\"hljs-keyword\">const</span> response = &#123;<span class=\"hljs-attr\">code</span>: <span class=\"hljs-number\">500</span>, <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;failed&#x27;</span>&#125;<br>    ctx.response.body = response<br>    ctx.status = <span class=\"hljs-number\">500</span><br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>&#125;<br>app.use(main);<br>app.listen(<span class=\"hljs-number\">3000</span>);<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;github hook server listen at port 3000&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>这样，我们的监听服务就搞定了，跑起来（推荐使用pm2），写一下文章，然后push一下，可以看到我们自动部署服务成功了。最新的文章也出现在了网站上。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9aacf4c41b6c42458e25936ee383797a~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n","site":{"data":{}},"wordcount":3599,"excerpt":"","more":"<p>最近想把之前写的博客重新注册一个域名放到网上，地址：<a href=\"https://luoluoqinghuan.cn/\">https://luoluoqinghuan.cn/</a><br>。博客框架使用的是hexo，部署到服务器上也很简单，把hexo生成的网站文件放在服务器上，用koa-static起一个服务就行了。</p>\n<p>但这是一种非常麻烦的部署方式，每次更新博客都要登陆服务器手动上传，如果想要自动更新网站就要解决两个问题：</p>\n<ul>\n<li>从哪里拿到最新的代码（github）</li>\n<li>如何知道代码已经更新（github-webhook）<h2 id=\"What-Is-Webhook\"><a href=\"#What-Is-Webhook\" class=\"headerlink\" title=\"What Is Webhook\"></a>What Is Webhook</h2></li>\n</ul>\n<p>webhook是github提供的一个钩子，这个钩子在触发github一些事件后，会向配置好的地址发一个http请求。在<code>任何一个仓库 -&gt; Setting -&gt; Webhooks</code> 可以进行配置。我们可以在服务器上监听这个请求，就可以知道更新网站的时机了。</p>\n<p>github提供的事件非常丰富，有20多种，几乎覆盖了所有git相关的操作，比如打了个tag、新建了branch、有新的commit等。<br><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/882c8bc589534941bd19cc2ffc53053a~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>了解到这里，我们就知道如何去自动部署我们的博客网站了，首先将博客源码推到github上，并配置webhook，针对push事件进行监听，在个人服务器上另起一个服务，接收webhook的请求，收到请求后拉取最新代码并重新构建，done！</p>\n<h2 id=\"实现-web服务\"><a href=\"#实现-web服务\" class=\"headerlink\" title=\"实现-web服务\"></a>实现-web服务</h2><p>我们有两个服务，一个是网站服务，一个是webhook监听服务。咱们一个一个来</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 网站服务 hexo_server.js</span><br><span class=\"hljs-keyword\">const</span> serve = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;koa-static&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> Koa = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;koa&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> Koa();<br> <br><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;fs&#x27;</span>)<br><span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;http&#x27;</span>)<br><span class=\"hljs-keyword\">const</span> https = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;https&#x27;</span>)<br><span class=\"hljs-keyword\">const</span> enforceHttps = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;koa-sslify&#x27;</span>).default<br><br>app.use(enforceHttps())<br>app.use(serve(<span class=\"hljs-string\">&#x27;public&#x27;</span>));<br> <br><span class=\"hljs-keyword\">const</span> options = &#123;<br>\t<span class=\"hljs-attr\">key</span>: fs.readFileSync(<span class=\"hljs-string\">&#x27;./ssl/luoluoqinghuan.cn.key&#x27;</span>),<br>\t<span class=\"hljs-attr\">cert</span>: fs.readFileSync(<span class=\"hljs-string\">&#x27;./ssl/luoluoqinghuan.cn.pem&#x27;</span>)<br>&#125;<br><br>http.createServer(app.callback()).listen(<span class=\"hljs-number\">80</span>);<br>https.createServer(options, app.callback()).listen(<span class=\"hljs-number\">443</span>)<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;listening on port 80 443&#x27;</span>);<br><br></code></pre></td></tr></table></figure>\n<p>直接使用koa-static这个中间件，很容易就可以将网站跑起来，我还在腾讯云申请了免费的证书，这样网站就可以支持https了，虽然一个简单的静态网站好像不需要https，但使用https可以帮助博客在搜索引擎中的排名更高一些。</p>\n<h2 id=\"实现-webhook服务\"><a href=\"#实现-webhook服务\" class=\"headerlink\" title=\"实现-webhook服务\"></a>实现-webhook服务</h2><p>首先要在博客仓库里配置webhook</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51073488f70a43998748ab2094c5ec0c~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>在payloadUrl中填入你服务器的地址，webhook的http请求会发向该地址，secret是密码，webhook会在请求头中使用此密码生成哈希值，供我们鉴权使用，events我们选第一个就可以了，我们在本地写完文章，push上去，触发webhook回调，点击add就添加成功了</p>\n<p>接下来就可以写一下服务了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// webhook服务 webhook_server.js</span><br><span class=\"hljs-keyword\">const</span> Koa = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;koa&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> Koa();<br><span class=\"hljs-keyword\">const</span> child_process = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;child_process&#x27;</span>)<br><span class=\"hljs-keyword\">const</span> crypto = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;crypto&#x27;</span>)<br><span class=\"hljs-keyword\">const</span> bodyParser = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;koa-bodyparser&#x27;</span>)<br><br><span class=\"hljs-keyword\">const</span> sigHeaderName = <span class=\"hljs-string\">&#x27;x-hub-signature-256&#x27;</span><br><span class=\"hljs-keyword\">const</span> sigHashAlg = <span class=\"hljs-string\">&#x27;sha256&#x27;</span><br><br>app.use(bodyParser())<br><br><span class=\"hljs-keyword\">const</span> secret = <span class=\"hljs-string\">&#x27;123456&#x27;</span><br><br><span class=\"hljs-keyword\">const</span> main = <span class=\"hljs-function\"><span class=\"hljs-params\">ctx</span> =&gt;</span> &#123;<br>  <span class=\"hljs-comment\">// 鉴权</span><br>  <span class=\"hljs-keyword\">const</span> sig = Buffer.from(ctx.request.headers[<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;sigHeaderName&#125;</span>`</span>] || <span class=\"hljs-string\">&#x27;&#x27;</span>, <span class=\"hljs-string\">&#x27;utf8&#x27;</span>)<br>  <span class=\"hljs-keyword\">const</span> hmac = crypto.createHmac(sigHashAlg, secret)<br>  <span class=\"hljs-keyword\">const</span> digest = Buffer.from(sigHashAlg + <span class=\"hljs-string\">&#x27;=&#x27;</span> + hmac.update(ctx.request.rawBody).digest(<span class=\"hljs-string\">&#x27;hex&#x27;</span>), <span class=\"hljs-string\">&#x27;utf8&#x27;</span>)<br>  <span class=\"hljs-keyword\">if</span> (sig.length !== digest.length || !crypto.timingSafeEqual(digest, sig)) &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Request body digest (<span class=\"hljs-subst\">$&#123;digest&#125;</span>) did not match <span class=\"hljs-subst\">$&#123;sigHeaderName&#125;</span> (<span class=\"hljs-subst\">$&#123;sig&#125;</span>)`</span>)<br>    ctx.status = <span class=\"hljs-number\">403</span><br>    <span class=\"hljs-keyword\">return</span><br>  &#125;<br><br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;start cmd&#x27;</span>)<br>  <span class=\"hljs-comment\">// 拉取最新代码</span><br>  <span class=\"hljs-keyword\">const</span> cmd = <span class=\"hljs-string\">&#x27;git checkout . &amp;&amp; git pull&#x27;</span><br><br>  <span class=\"hljs-keyword\">try</span>&#123;<br>    <span class=\"hljs-keyword\">const</span> log = child_process.spawnSync(cmd, &#123;<span class=\"hljs-attr\">shell</span>: <span class=\"hljs-literal\">true</span>&#125;)<br>    <span class=\"hljs-built_in\">console</span>.log(log.stdout.toString())<br>  &#125;<span class=\"hljs-keyword\">catch</span>(e)&#123;<br>    <span class=\"hljs-built_in\">console</span>.error(e.toString())<br>    <span class=\"hljs-keyword\">const</span> response = &#123;<span class=\"hljs-attr\">code</span>: <span class=\"hljs-number\">500</span>, <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;update failed&#x27;</span>&#125;<br>    ctx.response.body = response<br>    ctx.status = <span class=\"hljs-number\">500</span><br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br><br>  <span class=\"hljs-comment\">// build网站</span><br>  <span class=\"hljs-keyword\">const</span> cmd1 = <span class=\"hljs-string\">&#x27;hexo clean &amp;&amp; hexo generate&#x27;</span><br>  <span class=\"hljs-keyword\">try</span>&#123;<br>    <span class=\"hljs-keyword\">const</span> log1 = child_process.spawnSync(cmd1, &#123;<span class=\"hljs-attr\">shell</span>: <span class=\"hljs-literal\">true</span>&#125;)<br>    <span class=\"hljs-built_in\">console</span>.log(log1.stdout.toString())<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;hexo blog update successed !!!!&#x27;</span>)<br>    <span class=\"hljs-keyword\">const</span> response = &#123;<span class=\"hljs-attr\">code</span>: <span class=\"hljs-number\">200</span>, <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;update successfully&#x27;</span>&#125;<br>    ctx.response.body = response<br>    ctx.status = <span class=\"hljs-number\">200</span><br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<span class=\"hljs-keyword\">catch</span>(e)&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(e.toString())<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;hexo blog update failed !!!!&#x27;</span>)<br>    <span class=\"hljs-keyword\">const</span> response = &#123;<span class=\"hljs-attr\">code</span>: <span class=\"hljs-number\">500</span>, <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;failed&#x27;</span>&#125;<br>    ctx.response.body = response<br>    ctx.status = <span class=\"hljs-number\">500</span><br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>&#125;<br>app.use(main);<br>app.listen(<span class=\"hljs-number\">3000</span>);<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;github hook server listen at port 3000&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>这样，我们的监听服务就搞定了，跑起来（推荐使用pm2），写一下文章，然后push一下，可以看到我们自动部署服务成功了。最新的文章也出现在了网站上。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9aacf4c41b6c42458e25936ee383797a~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n"},{"title":"useSelector是如何触发更新的以及手写一个简单的useSelector","date":"2022-02-15T10:04:00.000Z","index_img":"https://d33wubrfki0l68.cloudfront.net/0834d0215db51e91525a25acf97433051f280f2f/c30f5/img/redux.svg","_content":"## 概述\n`useSelector`是`react-redux@7`中加入的hook，可以在不使用`connect()`的情况下将函数组件连接到redux，这样代码写起来会更加清晰，更加方便。\n\n使用起来也很简单，我们写一个简单的加减数组件来看一下\n```typescript\n// index.tsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { createStore, Reducer } from 'redux';\nimport { Provider } from 'react-redux';\nimport Sub from './sub';\n\nexport interface StoreState {\n  count: number\n}\nexport interface StoreAction {\n  type: 'change'\n  payload: StoreState\n}\n\nconst reducer: Reducer<StoreState, StoreAction> = (state, action) => ({ ...state, ...action.payload });\nconst store = createStore(reducer, { count: 0 });\n\nfunction App() {\n  return (\n    <Provider store={store}>\n      <Sub />\n    </Provider>\n  );\n}\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n```\n``` typescript\n// Sub.tsx\nimport React from 'react';\nimport { StoreState, StoreAction } from './index';\nimport { useDispatch, useSelector } from 'react-redux';\n\nexport default function Sub() {\n  const count = useSelector<StoreState, number>((state) => state.count);\n  const dispatch = useDispatch<StoreAction>();\n  const customEqalityCount = useSelector<StoreState, number>((state) => state.count, (a, b) => a > b);\n  \n  return (\n    <div>\n      <div>{count}</div>\n      <div onClick={() => dispatch(\n        {\n          type: 'change',\n          payload: { count: count + 1 },\n        },\n      )}>\n        点击增加\n      </div>\n      <div onClick={() => dispatch(\n        {\n          type: 'change',\n          payload: { count: count - 1 },\n        },\n      )}>\n        点击减少\n      </div>\n      <div>{customEqalityCount}</div>\n    </div>\n  );\n}\n```\n在`index.tsx`中创建了一个`store`，丢到`Provider`中，在子组件中使用`useSelector`获取`store`中最新的state, `useDispatch`更新`store`中的state，这样一个简单的加减数功能就完成了，注意在`Sub`中第二个`useSelector`使用了两个参数，向它传递了一个新旧`count`比较函数，只有该函数返回`false`的时候才会触发更新。在这里我传了一个`(a, b) => a > b`，意味着该值只能减少不能增加。\n\n可以在[sandbox](https://codesandbox.io/s/sad-violet-65vrz?file=/src/App.tsx)里玩下试试\n\n## 原理浅析\n其实原理也不复杂，使用了`useContext`的特性，但看过源码后，发现直接想的一些细节很妙。\n我们可以先想一下，实现一个`useSelector`有哪些问题需要解决：\n+ `useSelector`如何获取`store`\n+ 如何知道`store`中的`state`已经变了\n+ 如何触发组件re-render\n+ 如何记录变化前的`state`\n+ 如何返回用户希望拿到的`state`\n\n第一个问题最简单，直接使用`useContext`就可以拿到。怎么知道`state`已经变了呢，这里我一开始有个误区，以为直接把`store`或者把`store.getState()`获取的`state`放到`useEffect`的依赖里就可以知道了。可问题是`store`会变吗，答案是不会，`store`是一个对象，只要`store`通过`createStore()`创建，这个对象的引用就不会变。`state`确实会变，但这个变化react可以知道吗，`state`只是一个值，是一个闭包，而不是react通过`useState`创建的，react是不知道他是否变化的，换句话说`state`改变时不会通知react。\n\n那么如何解决呢，答案就在谜面上，在`store.subscribe()`里订阅就可以了，我们可以在回调函数中比较变化前后的`state`，去触发更新。\n\nOK，如何触发组件re-render呢，这个也比较简单，用 `useState` 或 `useReducer` 记录一个无意义的状态，在需要重新渲染的时候，改变它就可以了。\n\n如何记录变化前后的`state`呢，可以用`useState` `useReducer`吗，当然不可以，我们记录之前的`state`是为了与现在的`state`进行比较，从而决定是否触发组件更新，使用这两个api可能引起额外的非必要更新，那能记录状态且不会触发re-render的api只有`useRef`了。\n\n如何返回用户想要的state呢，哈哈哈，自定义hook是个函数呀，直接返回就完事了。\n\n## 手写一个简单的useSelector\n原理差不多搞清楚了之后，我们就可以来试着模拟一个useSelector，实践一下。*注：以下实现简化了源码中的很多细节*\n\n首先，我们需要有一个context\n```typescript\n// context.ts\nimport { createContext } from \"react\";\nimport { AnyAction, Store } from \"redux\";\n\nconst StoreContext = createContext<Store<any, AnyAction>>(null as any);\nexport default StoreContext;\n```\n\n有了context就可以写provider跟useDispatch了\n```typescript\n// Provider.tsx\nimport React from 'react';\nimport { AnyAction, Store, Action } from 'redux';\nimport StoreContext from './context';\n\ninterface ProviderParams<T extends Action = AnyAction, S = any> {\n  store: Store<S, T>,\n  children: JSX.Element\n}\n\nexport default function Provider\n<T extends Action = AnyAction>({ store, children }: ProviderParams<T>) {\n  // @ts-ignore\n  return <StoreContext.Provider value={store}>{children}</StoreContext.Provider>;\n}\n\n// useDispatch.ts\nimport { useContext } from 'react';\nimport { Action, Dispatch } from 'redux';\nimport StoreContext from './context';\n\nexport default function useDispatch<T extends Action>(): Dispatch<T> {\n  const store = useContext(StoreContext);\n  return store.dispatch;\n}\n```\n\n然后就可以将最开始index.tsx的代码改一下，引用我们自己文件。\n```typescript\n// index.tsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { createStore, Reducer } from 'redux';\nimport Provider from './Provider';\nimport Sub from './sub';\n// ...\n```\n我们在这里创建store，通过context传下去。\n接下来就可写useSelector了\n```typescript\nimport {\n  useContext, useEffect, useReducer, useRef,\n} from 'react';\nimport StoreContext from './context';\n\ntype EqualityFn<T> = (a: T, b: T) => boolean;\n\nexport default function useSelector<T, Selected extends unknown>(\n  selector: (state: T) => Selected,\n  equalityFn?: EqualityFn<Selected>,\n): Selected {\n  const store = useContext(StoreContext);\n  const [, forceRender] = useReducer((s) => s + 1, 0);\n\n  const latestStoreState = useRef<T>(store.getState());\n  const latestSelectedState = useRef<Selected>(selector(latestStoreState.current));\n\n  useEffect(() => {\n    function checkUpdate() {\n      const newState = store.getState();\n      if (newState === latestStoreState) return;\n\n      const newSelectedState = selector(newState);\n      if (!equalityFn) equalityFn = (a, b) => a === b;\n\n      if (!equalityFn(newSelectedState, latestSelectedState.current)) {\n        latestSelectedState.current = newSelectedState;\n        latestStoreState.current = newState;\n        forceRender();\n      }\n    }\n    const unsubscribe = store.subscribe(checkUpdate);\n    return () => unsubscribe();\n  }, [store]);\n\n  return latestSelectedState.current;\n}\n```\n最后改下sub.tsx中的代码，引用我们自己的文件\n```typescript\nimport React from 'react';\nimport { StoreState, StoreAction } from './index';\nimport useDispatch from './useDispatch';\nimport useSelector from './useSelector';\n//...\n```\n可以在[sandbox](https://codesandbox.io/s/blissful-fire-g00xj?file=/src/index.tsx:0-606)中试一下，效果跟之前是一样的\n\n## 尾巴\n上面的原理是借鉴了`react-redux@7`中的实现，使用一个forceUpdate去触发re-render，但在`@8-beta`中，useSelector直接使用了React18提供的`useSyncExternalStore`api去做这件事，关于这个api可以在[这里](https://www.zhihu.com/question/502917860)了解一下。\n\n## 参考\n[How useSelector can trigger an update only when we want it to](https://medium.com/async/how-useselector-can-trigger-an-update-only-when-we-want-it-to-a8d92306f559)\n\n[React Redux Doc: Hooks](https://react-redux.js.org/api/hooks)\n\n[react-redux](https://github.com/reduxjs/react-redux)\n\n[redux](https://github.com/reduxjs/redux)","source":"_posts/useSelector是如何触发更新的以及手写一个简单的useSelector.md","raw":"---\ntitle: useSelector是如何触发更新的以及手写一个简单的useSelector\ndate: 2022-02-15 18:04:00\nindex_img: https://d33wubrfki0l68.cloudfront.net/0834d0215db51e91525a25acf97433051f280f2f/c30f5/img/redux.svg\ntags: [redux]\ncategories: [源码解读]\n---\n## 概述\n`useSelector`是`react-redux@7`中加入的hook，可以在不使用`connect()`的情况下将函数组件连接到redux，这样代码写起来会更加清晰，更加方便。\n\n使用起来也很简单，我们写一个简单的加减数组件来看一下\n```typescript\n// index.tsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { createStore, Reducer } from 'redux';\nimport { Provider } from 'react-redux';\nimport Sub from './sub';\n\nexport interface StoreState {\n  count: number\n}\nexport interface StoreAction {\n  type: 'change'\n  payload: StoreState\n}\n\nconst reducer: Reducer<StoreState, StoreAction> = (state, action) => ({ ...state, ...action.payload });\nconst store = createStore(reducer, { count: 0 });\n\nfunction App() {\n  return (\n    <Provider store={store}>\n      <Sub />\n    </Provider>\n  );\n}\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n```\n``` typescript\n// Sub.tsx\nimport React from 'react';\nimport { StoreState, StoreAction } from './index';\nimport { useDispatch, useSelector } from 'react-redux';\n\nexport default function Sub() {\n  const count = useSelector<StoreState, number>((state) => state.count);\n  const dispatch = useDispatch<StoreAction>();\n  const customEqalityCount = useSelector<StoreState, number>((state) => state.count, (a, b) => a > b);\n  \n  return (\n    <div>\n      <div>{count}</div>\n      <div onClick={() => dispatch(\n        {\n          type: 'change',\n          payload: { count: count + 1 },\n        },\n      )}>\n        点击增加\n      </div>\n      <div onClick={() => dispatch(\n        {\n          type: 'change',\n          payload: { count: count - 1 },\n        },\n      )}>\n        点击减少\n      </div>\n      <div>{customEqalityCount}</div>\n    </div>\n  );\n}\n```\n在`index.tsx`中创建了一个`store`，丢到`Provider`中，在子组件中使用`useSelector`获取`store`中最新的state, `useDispatch`更新`store`中的state，这样一个简单的加减数功能就完成了，注意在`Sub`中第二个`useSelector`使用了两个参数，向它传递了一个新旧`count`比较函数，只有该函数返回`false`的时候才会触发更新。在这里我传了一个`(a, b) => a > b`，意味着该值只能减少不能增加。\n\n可以在[sandbox](https://codesandbox.io/s/sad-violet-65vrz?file=/src/App.tsx)里玩下试试\n\n## 原理浅析\n其实原理也不复杂，使用了`useContext`的特性，但看过源码后，发现直接想的一些细节很妙。\n我们可以先想一下，实现一个`useSelector`有哪些问题需要解决：\n+ `useSelector`如何获取`store`\n+ 如何知道`store`中的`state`已经变了\n+ 如何触发组件re-render\n+ 如何记录变化前的`state`\n+ 如何返回用户希望拿到的`state`\n\n第一个问题最简单，直接使用`useContext`就可以拿到。怎么知道`state`已经变了呢，这里我一开始有个误区，以为直接把`store`或者把`store.getState()`获取的`state`放到`useEffect`的依赖里就可以知道了。可问题是`store`会变吗，答案是不会，`store`是一个对象，只要`store`通过`createStore()`创建，这个对象的引用就不会变。`state`确实会变，但这个变化react可以知道吗，`state`只是一个值，是一个闭包，而不是react通过`useState`创建的，react是不知道他是否变化的，换句话说`state`改变时不会通知react。\n\n那么如何解决呢，答案就在谜面上，在`store.subscribe()`里订阅就可以了，我们可以在回调函数中比较变化前后的`state`，去触发更新。\n\nOK，如何触发组件re-render呢，这个也比较简单，用 `useState` 或 `useReducer` 记录一个无意义的状态，在需要重新渲染的时候，改变它就可以了。\n\n如何记录变化前后的`state`呢，可以用`useState` `useReducer`吗，当然不可以，我们记录之前的`state`是为了与现在的`state`进行比较，从而决定是否触发组件更新，使用这两个api可能引起额外的非必要更新，那能记录状态且不会触发re-render的api只有`useRef`了。\n\n如何返回用户想要的state呢，哈哈哈，自定义hook是个函数呀，直接返回就完事了。\n\n## 手写一个简单的useSelector\n原理差不多搞清楚了之后，我们就可以来试着模拟一个useSelector，实践一下。*注：以下实现简化了源码中的很多细节*\n\n首先，我们需要有一个context\n```typescript\n// context.ts\nimport { createContext } from \"react\";\nimport { AnyAction, Store } from \"redux\";\n\nconst StoreContext = createContext<Store<any, AnyAction>>(null as any);\nexport default StoreContext;\n```\n\n有了context就可以写provider跟useDispatch了\n```typescript\n// Provider.tsx\nimport React from 'react';\nimport { AnyAction, Store, Action } from 'redux';\nimport StoreContext from './context';\n\ninterface ProviderParams<T extends Action = AnyAction, S = any> {\n  store: Store<S, T>,\n  children: JSX.Element\n}\n\nexport default function Provider\n<T extends Action = AnyAction>({ store, children }: ProviderParams<T>) {\n  // @ts-ignore\n  return <StoreContext.Provider value={store}>{children}</StoreContext.Provider>;\n}\n\n// useDispatch.ts\nimport { useContext } from 'react';\nimport { Action, Dispatch } from 'redux';\nimport StoreContext from './context';\n\nexport default function useDispatch<T extends Action>(): Dispatch<T> {\n  const store = useContext(StoreContext);\n  return store.dispatch;\n}\n```\n\n然后就可以将最开始index.tsx的代码改一下，引用我们自己文件。\n```typescript\n// index.tsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { createStore, Reducer } from 'redux';\nimport Provider from './Provider';\nimport Sub from './sub';\n// ...\n```\n我们在这里创建store，通过context传下去。\n接下来就可写useSelector了\n```typescript\nimport {\n  useContext, useEffect, useReducer, useRef,\n} from 'react';\nimport StoreContext from './context';\n\ntype EqualityFn<T> = (a: T, b: T) => boolean;\n\nexport default function useSelector<T, Selected extends unknown>(\n  selector: (state: T) => Selected,\n  equalityFn?: EqualityFn<Selected>,\n): Selected {\n  const store = useContext(StoreContext);\n  const [, forceRender] = useReducer((s) => s + 1, 0);\n\n  const latestStoreState = useRef<T>(store.getState());\n  const latestSelectedState = useRef<Selected>(selector(latestStoreState.current));\n\n  useEffect(() => {\n    function checkUpdate() {\n      const newState = store.getState();\n      if (newState === latestStoreState) return;\n\n      const newSelectedState = selector(newState);\n      if (!equalityFn) equalityFn = (a, b) => a === b;\n\n      if (!equalityFn(newSelectedState, latestSelectedState.current)) {\n        latestSelectedState.current = newSelectedState;\n        latestStoreState.current = newState;\n        forceRender();\n      }\n    }\n    const unsubscribe = store.subscribe(checkUpdate);\n    return () => unsubscribe();\n  }, [store]);\n\n  return latestSelectedState.current;\n}\n```\n最后改下sub.tsx中的代码，引用我们自己的文件\n```typescript\nimport React from 'react';\nimport { StoreState, StoreAction } from './index';\nimport useDispatch from './useDispatch';\nimport useSelector from './useSelector';\n//...\n```\n可以在[sandbox](https://codesandbox.io/s/blissful-fire-g00xj?file=/src/index.tsx:0-606)中试一下，效果跟之前是一样的\n\n## 尾巴\n上面的原理是借鉴了`react-redux@7`中的实现，使用一个forceUpdate去触发re-render，但在`@8-beta`中，useSelector直接使用了React18提供的`useSyncExternalStore`api去做这件事，关于这个api可以在[这里](https://www.zhihu.com/question/502917860)了解一下。\n\n## 参考\n[How useSelector can trigger an update only when we want it to](https://medium.com/async/how-useselector-can-trigger-an-update-only-when-we-want-it-to-a8d92306f559)\n\n[React Redux Doc: Hooks](https://react-redux.js.org/api/hooks)\n\n[react-redux](https://github.com/reduxjs/react-redux)\n\n[redux](https://github.com/reduxjs/redux)","slug":"useSelector是如何触发更新的以及手写一个简单的useSelector","published":1,"updated":"2025-06-10T04:39:28.845Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmbq19nxn0000rq9k3q10f8v5","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><code>useSelector</code>是<code>react-redux@7</code>中加入的hook，可以在不使用<code>connect()</code>的情况下将函数组件连接到redux，这样代码写起来会更加清晰，更加方便。</p>\n<p>使用起来也很简单，我们写一个简单的加减数组件来看一下</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// index.tsx</span><br><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> ReactDOM <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-dom&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; createStore, Reducer &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;redux&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; Provider &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-redux&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> Sub <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./sub&#x27;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> StoreState &#123;<br>  <span class=\"hljs-attr\">count</span>: <span class=\"hljs-built_in\">number</span><br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> StoreAction &#123;<br>  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;change&#x27;</span><br>  <span class=\"hljs-attr\">payload</span>: StoreState<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> reducer: Reducer&lt;StoreState, StoreAction&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">state, action</span>) =&gt;</span> (&#123; ...state, ...action.payload &#125;);<br><span class=\"hljs-keyword\">const</span> store = createStore(reducer, &#123; <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span> &#125;);<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Provider</span> <span class=\"hljs-attr\">store</span>=<span class=\"hljs-string\">&#123;store&#125;</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Sub</span> /&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br>ReactDOM.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span> /&gt;</span></span>, <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;root&#x27;</span>));<br><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// Sub.tsx</span><br><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; StoreState, StoreAction &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./index&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; useDispatch, useSelector &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-redux&#x27;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Sub</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> count = useSelector&lt;StoreState, <span class=\"hljs-built_in\">number</span>&gt;(<span class=\"hljs-function\">(<span class=\"hljs-params\">state</span>) =&gt;</span> state.count);<br>  <span class=\"hljs-keyword\">const</span> dispatch = useDispatch&lt;StoreAction&gt;();<br>  <span class=\"hljs-keyword\">const</span> customEqalityCount = useSelector&lt;StoreState, <span class=\"hljs-built_in\">number</span>&gt;(<span class=\"hljs-function\">(<span class=\"hljs-params\">state</span>) =&gt;</span> state.count, <span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> a &gt; b);<br>  <br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> dispatch(</span><br><span class=\"xml\">        &#123;</span><br><span class=\"xml\">          type: &#x27;change&#x27;,</span><br><span class=\"xml\">          payload: &#123; count: count + 1 &#125;,</span><br><span class=\"xml\">        &#125;,</span><br><span class=\"xml\">      )&#125;&gt;</span><br><span class=\"xml\">        点击增加</span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> dispatch(</span><br><span class=\"xml\">        &#123;</span><br><span class=\"xml\">          type: &#x27;change&#x27;,</span><br><span class=\"xml\">          payload: &#123; count: count - 1 &#125;,</span><br><span class=\"xml\">        &#125;,</span><br><span class=\"xml\">      )&#125;&gt;</span><br><span class=\"xml\">        点击减少</span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;customEqalityCount&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>在<code>index.tsx</code>中创建了一个<code>store</code>，丢到<code>Provider</code>中，在子组件中使用<code>useSelector</code>获取<code>store</code>中最新的state, <code>useDispatch</code>更新<code>store</code>中的state，这样一个简单的加减数功能就完成了，注意在<code>Sub</code>中第二个<code>useSelector</code>使用了两个参数，向它传递了一个新旧<code>count</code>比较函数，只有该函数返回<code>false</code>的时候才会触发更新。在这里我传了一个<code>(a, b) =&gt; a &gt; b</code>，意味着该值只能减少不能增加。</p>\n<p>可以在<a href=\"https://codesandbox.io/s/sad-violet-65vrz?file=/src/App.tsx\">sandbox</a>里玩下试试</p>\n<h2 id=\"原理浅析\"><a href=\"#原理浅析\" class=\"headerlink\" title=\"原理浅析\"></a>原理浅析</h2><p>其实原理也不复杂，使用了<code>useContext</code>的特性，但看过源码后，发现直接想的一些细节很妙。<br>我们可以先想一下，实现一个<code>useSelector</code>有哪些问题需要解决：</p>\n<ul>\n<li><code>useSelector</code>如何获取<code>store</code></li>\n<li>如何知道<code>store</code>中的<code>state</code>已经变了</li>\n<li>如何触发组件re-render</li>\n<li>如何记录变化前的<code>state</code></li>\n<li>如何返回用户希望拿到的<code>state</code></li>\n</ul>\n<p>第一个问题最简单，直接使用<code>useContext</code>就可以拿到。怎么知道<code>state</code>已经变了呢，这里我一开始有个误区，以为直接把<code>store</code>或者把<code>store.getState()</code>获取的<code>state</code>放到<code>useEffect</code>的依赖里就可以知道了。可问题是<code>store</code>会变吗，答案是不会，<code>store</code>是一个对象，只要<code>store</code>通过<code>createStore()</code>创建，这个对象的引用就不会变。<code>state</code>确实会变，但这个变化react可以知道吗，<code>state</code>只是一个值，是一个闭包，而不是react通过<code>useState</code>创建的，react是不知道他是否变化的，换句话说<code>state</code>改变时不会通知react。</p>\n<p>那么如何解决呢，答案就在谜面上，在<code>store.subscribe()</code>里订阅就可以了，我们可以在回调函数中比较变化前后的<code>state</code>，去触发更新。</p>\n<p>OK，如何触发组件re-render呢，这个也比较简单，用 <code>useState</code> 或 <code>useReducer</code> 记录一个无意义的状态，在需要重新渲染的时候，改变它就可以了。</p>\n<p>如何记录变化前后的<code>state</code>呢，可以用<code>useState</code> <code>useReducer</code>吗，当然不可以，我们记录之前的<code>state</code>是为了与现在的<code>state</code>进行比较，从而决定是否触发组件更新，使用这两个api可能引起额外的非必要更新，那能记录状态且不会触发re-render的api只有<code>useRef</code>了。</p>\n<p>如何返回用户想要的state呢，哈哈哈，自定义hook是个函数呀，直接返回就完事了。</p>\n<h2 id=\"手写一个简单的useSelector\"><a href=\"#手写一个简单的useSelector\" class=\"headerlink\" title=\"手写一个简单的useSelector\"></a>手写一个简单的useSelector</h2><p>原理差不多搞清楚了之后，我们就可以来试着模拟一个useSelector，实践一下。<em>注：以下实现简化了源码中的很多细节</em></p>\n<p>首先，我们需要有一个context</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// context.ts</span><br><span class=\"hljs-keyword\">import</span> &#123; createContext &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; AnyAction, Store &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;redux&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> StoreContext = createContext&lt;Store&lt;<span class=\"hljs-built_in\">any</span>, AnyAction&gt;&gt;(<span class=\"hljs-literal\">null</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>);<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> StoreContext;<br></code></pre></td></tr></table></figure>\n\n<p>有了context就可以写provider跟useDispatch了</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// Provider.tsx</span><br><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; AnyAction, Store, Action &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;redux&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> StoreContext <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./context&#x27;</span>;<br><br><span class=\"hljs-keyword\">interface</span> ProviderParams&lt;T <span class=\"hljs-keyword\">extends</span> Action = AnyAction, S = any&gt; &#123;<br>  <span class=\"hljs-attr\">store</span>: Store&lt;S, T&gt;,<br>  children: JSX.Element<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Provider</span></span><br><span class=\"hljs-function\">&lt;<span class=\"hljs-title\">T</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">Action</span> = <span class=\"hljs-title\">AnyAction</span>&gt;(<span class=\"hljs-params\">&#123; store, children &#125;: ProviderParams&lt;T&gt;</span>) </span>&#123;<br>  <span class=\"hljs-comment\">// @ts-ignore</span><br>  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">StoreContext.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;store&#125;</span>&gt;</span>&#123;children&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">StoreContext.Provider</span>&gt;</span></span>;<br>&#125;<br><br><span class=\"hljs-comment\">// useDispatch.ts</span><br><span class=\"hljs-keyword\">import</span> &#123; useContext &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; Action, Dispatch &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;redux&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> StoreContext <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./context&#x27;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useDispatch</span>&lt;<span class=\"hljs-title\">T</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">Action</span>&gt;(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">Dispatch</span>&lt;<span class=\"hljs-title\">T</span>&gt; </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> store = useContext(StoreContext);<br>  <span class=\"hljs-keyword\">return</span> store.dispatch;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后就可以将最开始index.tsx的代码改一下，引用我们自己文件。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// index.tsx</span><br><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> ReactDOM <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-dom&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; createStore, Reducer &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;redux&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> Provider <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./Provider&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> Sub <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./sub&#x27;</span>;<br><span class=\"hljs-comment\">// ...</span><br></code></pre></td></tr></table></figure>\n<p>我们在这里创建store，通过context传下去。<br>接下来就可写useSelector了</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">import</span> &#123;<br>  useContext, useEffect, useReducer, useRef,<br>&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> StoreContext <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./context&#x27;</span>;<br><br><span class=\"hljs-keyword\">type</span> EqualityFn&lt;T&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: T, b: T</span>) =&gt;</span> <span class=\"hljs-built_in\">boolean</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useSelector</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">Selected</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">unknown</span>&gt;(<span class=\"hljs-params\"></span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">  selector: (state: T) =&gt; Selected,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">  equalityFn?: EqualityFn&lt;Selected&gt;,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\"></span>): <span class=\"hljs-title\">Selected</span> </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> store = useContext(StoreContext);<br>  <span class=\"hljs-keyword\">const</span> [, forceRender] = useReducer(<span class=\"hljs-function\">(<span class=\"hljs-params\">s</span>) =&gt;</span> s + <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>);<br><br>  <span class=\"hljs-keyword\">const</span> latestStoreState = useRef&lt;T&gt;(store.getState());<br>  <span class=\"hljs-keyword\">const</span> latestSelectedState = useRef&lt;Selected&gt;(selector(latestStoreState.current));<br><br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">checkUpdate</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>      <span class=\"hljs-keyword\">const</span> newState = store.getState();<br>      <span class=\"hljs-keyword\">if</span> (newState === latestStoreState) <span class=\"hljs-keyword\">return</span>;<br><br>      <span class=\"hljs-keyword\">const</span> newSelectedState = selector(newState);<br>      <span class=\"hljs-keyword\">if</span> (!equalityFn) equalityFn = <span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> a === b;<br><br>      <span class=\"hljs-keyword\">if</span> (!equalityFn(newSelectedState, latestSelectedState.current)) &#123;<br>        latestSelectedState.current = newSelectedState;<br>        latestStoreState.current = newState;<br>        forceRender();<br>      &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">const</span> unsubscribe = store.subscribe(checkUpdate);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> unsubscribe();<br>  &#125;, [store]);<br><br>  <span class=\"hljs-keyword\">return</span> latestSelectedState.current;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>最后改下sub.tsx中的代码，引用我们自己的文件</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; StoreState, StoreAction &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./index&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> useDispatch <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./useDispatch&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> useSelector <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./useSelector&#x27;</span>;<br><span class=\"hljs-comment\">//...</span><br></code></pre></td></tr></table></figure>\n<p>可以在<a href=\"https://codesandbox.io/s/blissful-fire-g00xj?file=/src/index.tsx:0-606\">sandbox</a>中试一下，效果跟之前是一样的</p>\n<h2 id=\"尾巴\"><a href=\"#尾巴\" class=\"headerlink\" title=\"尾巴\"></a>尾巴</h2><p>上面的原理是借鉴了<code>react-redux@7</code>中的实现，使用一个forceUpdate去触发re-render，但在<code>@8-beta</code>中，useSelector直接使用了React18提供的<code>useSyncExternalStore</code>api去做这件事，关于这个api可以在<a href=\"https://www.zhihu.com/question/502917860\">这里</a>了解一下。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://medium.com/async/how-useselector-can-trigger-an-update-only-when-we-want-it-to-a8d92306f559\">How useSelector can trigger an update only when we want it to</a></p>\n<p><a href=\"https://react-redux.js.org/api/hooks\">React Redux Doc: Hooks</a></p>\n<p><a href=\"https://github.com/reduxjs/react-redux\">react-redux</a></p>\n<p><a href=\"https://github.com/reduxjs/redux\">redux</a></p>\n","site":{"data":{}},"wordcount":5875,"excerpt":"","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><code>useSelector</code>是<code>react-redux@7</code>中加入的hook，可以在不使用<code>connect()</code>的情况下将函数组件连接到redux，这样代码写起来会更加清晰，更加方便。</p>\n<p>使用起来也很简单，我们写一个简单的加减数组件来看一下</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// index.tsx</span><br><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> ReactDOM <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-dom&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; createStore, Reducer &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;redux&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; Provider &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-redux&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> Sub <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./sub&#x27;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> StoreState &#123;<br>  <span class=\"hljs-attr\">count</span>: <span class=\"hljs-built_in\">number</span><br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> StoreAction &#123;<br>  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;change&#x27;</span><br>  <span class=\"hljs-attr\">payload</span>: StoreState<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> reducer: Reducer&lt;StoreState, StoreAction&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">state, action</span>) =&gt;</span> (&#123; ...state, ...action.payload &#125;);<br><span class=\"hljs-keyword\">const</span> store = createStore(reducer, &#123; <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span> &#125;);<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">App</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Provider</span> <span class=\"hljs-attr\">store</span>=<span class=\"hljs-string\">&#123;store&#125;</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Sub</span> /&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Provider</span>&gt;</span></span><br>  );<br>&#125;<br><br>ReactDOM.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">App</span> /&gt;</span></span>, <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;root&#x27;</span>));<br><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// Sub.tsx</span><br><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; StoreState, StoreAction &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./index&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; useDispatch, useSelector &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-redux&#x27;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Sub</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> count = useSelector&lt;StoreState, <span class=\"hljs-built_in\">number</span>&gt;(<span class=\"hljs-function\">(<span class=\"hljs-params\">state</span>) =&gt;</span> state.count);<br>  <span class=\"hljs-keyword\">const</span> dispatch = useDispatch&lt;StoreAction&gt;();<br>  <span class=\"hljs-keyword\">const</span> customEqalityCount = useSelector&lt;StoreState, <span class=\"hljs-built_in\">number</span>&gt;(<span class=\"hljs-function\">(<span class=\"hljs-params\">state</span>) =&gt;</span> state.count, <span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> a &gt; b);<br>  <br>  <span class=\"hljs-keyword\">return</span> (<br>    <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> dispatch(</span><br><span class=\"xml\">        &#123;</span><br><span class=\"xml\">          type: &#x27;change&#x27;,</span><br><span class=\"xml\">          payload: &#123; count: count + 1 &#125;,</span><br><span class=\"xml\">        &#125;,</span><br><span class=\"xml\">      )&#125;&gt;</span><br><span class=\"xml\">        点击增加</span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> dispatch(</span><br><span class=\"xml\">        &#123;</span><br><span class=\"xml\">          type: &#x27;change&#x27;,</span><br><span class=\"xml\">          payload: &#123; count: count - 1 &#125;,</span><br><span class=\"xml\">        &#125;,</span><br><span class=\"xml\">      )&#125;&gt;</span><br><span class=\"xml\">        点击减少</span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;customEqalityCount&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>在<code>index.tsx</code>中创建了一个<code>store</code>，丢到<code>Provider</code>中，在子组件中使用<code>useSelector</code>获取<code>store</code>中最新的state, <code>useDispatch</code>更新<code>store</code>中的state，这样一个简单的加减数功能就完成了，注意在<code>Sub</code>中第二个<code>useSelector</code>使用了两个参数，向它传递了一个新旧<code>count</code>比较函数，只有该函数返回<code>false</code>的时候才会触发更新。在这里我传了一个<code>(a, b) =&gt; a &gt; b</code>，意味着该值只能减少不能增加。</p>\n<p>可以在<a href=\"https://codesandbox.io/s/sad-violet-65vrz?file=/src/App.tsx\">sandbox</a>里玩下试试</p>\n<h2 id=\"原理浅析\"><a href=\"#原理浅析\" class=\"headerlink\" title=\"原理浅析\"></a>原理浅析</h2><p>其实原理也不复杂，使用了<code>useContext</code>的特性，但看过源码后，发现直接想的一些细节很妙。<br>我们可以先想一下，实现一个<code>useSelector</code>有哪些问题需要解决：</p>\n<ul>\n<li><code>useSelector</code>如何获取<code>store</code></li>\n<li>如何知道<code>store</code>中的<code>state</code>已经变了</li>\n<li>如何触发组件re-render</li>\n<li>如何记录变化前的<code>state</code></li>\n<li>如何返回用户希望拿到的<code>state</code></li>\n</ul>\n<p>第一个问题最简单，直接使用<code>useContext</code>就可以拿到。怎么知道<code>state</code>已经变了呢，这里我一开始有个误区，以为直接把<code>store</code>或者把<code>store.getState()</code>获取的<code>state</code>放到<code>useEffect</code>的依赖里就可以知道了。可问题是<code>store</code>会变吗，答案是不会，<code>store</code>是一个对象，只要<code>store</code>通过<code>createStore()</code>创建，这个对象的引用就不会变。<code>state</code>确实会变，但这个变化react可以知道吗，<code>state</code>只是一个值，是一个闭包，而不是react通过<code>useState</code>创建的，react是不知道他是否变化的，换句话说<code>state</code>改变时不会通知react。</p>\n<p>那么如何解决呢，答案就在谜面上，在<code>store.subscribe()</code>里订阅就可以了，我们可以在回调函数中比较变化前后的<code>state</code>，去触发更新。</p>\n<p>OK，如何触发组件re-render呢，这个也比较简单，用 <code>useState</code> 或 <code>useReducer</code> 记录一个无意义的状态，在需要重新渲染的时候，改变它就可以了。</p>\n<p>如何记录变化前后的<code>state</code>呢，可以用<code>useState</code> <code>useReducer</code>吗，当然不可以，我们记录之前的<code>state</code>是为了与现在的<code>state</code>进行比较，从而决定是否触发组件更新，使用这两个api可能引起额外的非必要更新，那能记录状态且不会触发re-render的api只有<code>useRef</code>了。</p>\n<p>如何返回用户想要的state呢，哈哈哈，自定义hook是个函数呀，直接返回就完事了。</p>\n<h2 id=\"手写一个简单的useSelector\"><a href=\"#手写一个简单的useSelector\" class=\"headerlink\" title=\"手写一个简单的useSelector\"></a>手写一个简单的useSelector</h2><p>原理差不多搞清楚了之后，我们就可以来试着模拟一个useSelector，实践一下。<em>注：以下实现简化了源码中的很多细节</em></p>\n<p>首先，我们需要有一个context</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// context.ts</span><br><span class=\"hljs-keyword\">import</span> &#123; createContext &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; AnyAction, Store &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;redux&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> StoreContext = createContext&lt;Store&lt;<span class=\"hljs-built_in\">any</span>, AnyAction&gt;&gt;(<span class=\"hljs-literal\">null</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>);<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> StoreContext;<br></code></pre></td></tr></table></figure>\n\n<p>有了context就可以写provider跟useDispatch了</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// Provider.tsx</span><br><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; AnyAction, Store, Action &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;redux&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> StoreContext <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./context&#x27;</span>;<br><br><span class=\"hljs-keyword\">interface</span> ProviderParams&lt;T <span class=\"hljs-keyword\">extends</span> Action = AnyAction, S = any&gt; &#123;<br>  <span class=\"hljs-attr\">store</span>: Store&lt;S, T&gt;,<br>  children: JSX.Element<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Provider</span></span><br><span class=\"hljs-function\">&lt;<span class=\"hljs-title\">T</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">Action</span> = <span class=\"hljs-title\">AnyAction</span>&gt;(<span class=\"hljs-params\">&#123; store, children &#125;: ProviderParams&lt;T&gt;</span>) </span>&#123;<br>  <span class=\"hljs-comment\">// @ts-ignore</span><br>  <span class=\"hljs-keyword\">return</span> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">StoreContext.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;store&#125;</span>&gt;</span>&#123;children&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">StoreContext.Provider</span>&gt;</span></span>;<br>&#125;<br><br><span class=\"hljs-comment\">// useDispatch.ts</span><br><span class=\"hljs-keyword\">import</span> &#123; useContext &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; Action, Dispatch &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;redux&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> StoreContext <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./context&#x27;</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useDispatch</span>&lt;<span class=\"hljs-title\">T</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">Action</span>&gt;(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">Dispatch</span>&lt;<span class=\"hljs-title\">T</span>&gt; </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> store = useContext(StoreContext);<br>  <span class=\"hljs-keyword\">return</span> store.dispatch;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后就可以将最开始index.tsx的代码改一下，引用我们自己文件。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-comment\">// index.tsx</span><br><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> ReactDOM <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-dom&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; createStore, Reducer &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;redux&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> Provider <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./Provider&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> Sub <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./sub&#x27;</span>;<br><span class=\"hljs-comment\">// ...</span><br></code></pre></td></tr></table></figure>\n<p>我们在这里创建store，通过context传下去。<br>接下来就可写useSelector了</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">import</span> &#123;<br>  useContext, useEffect, useReducer, useRef,<br>&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> StoreContext <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./context&#x27;</span>;<br><br><span class=\"hljs-keyword\">type</span> EqualityFn&lt;T&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">a: T, b: T</span>) =&gt;</span> <span class=\"hljs-built_in\">boolean</span>;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">useSelector</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">Selected</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">unknown</span>&gt;(<span class=\"hljs-params\"></span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">  selector: (state: T) =&gt; Selected,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">  equalityFn?: EqualityFn&lt;Selected&gt;,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\"></span>): <span class=\"hljs-title\">Selected</span> </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> store = useContext(StoreContext);<br>  <span class=\"hljs-keyword\">const</span> [, forceRender] = useReducer(<span class=\"hljs-function\">(<span class=\"hljs-params\">s</span>) =&gt;</span> s + <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>);<br><br>  <span class=\"hljs-keyword\">const</span> latestStoreState = useRef&lt;T&gt;(store.getState());<br>  <span class=\"hljs-keyword\">const</span> latestSelectedState = useRef&lt;Selected&gt;(selector(latestStoreState.current));<br><br>  useEffect(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">checkUpdate</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>      <span class=\"hljs-keyword\">const</span> newState = store.getState();<br>      <span class=\"hljs-keyword\">if</span> (newState === latestStoreState) <span class=\"hljs-keyword\">return</span>;<br><br>      <span class=\"hljs-keyword\">const</span> newSelectedState = selector(newState);<br>      <span class=\"hljs-keyword\">if</span> (!equalityFn) equalityFn = <span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> a === b;<br><br>      <span class=\"hljs-keyword\">if</span> (!equalityFn(newSelectedState, latestSelectedState.current)) &#123;<br>        latestSelectedState.current = newSelectedState;<br>        latestStoreState.current = newState;<br>        forceRender();<br>      &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">const</span> unsubscribe = store.subscribe(checkUpdate);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> unsubscribe();<br>  &#125;, [store]);<br><br>  <span class=\"hljs-keyword\">return</span> latestSelectedState.current;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>最后改下sub.tsx中的代码，引用我们自己的文件</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; StoreState, StoreAction &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./index&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> useDispatch <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./useDispatch&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> useSelector <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./useSelector&#x27;</span>;<br><span class=\"hljs-comment\">//...</span><br></code></pre></td></tr></table></figure>\n<p>可以在<a href=\"https://codesandbox.io/s/blissful-fire-g00xj?file=/src/index.tsx:0-606\">sandbox</a>中试一下，效果跟之前是一样的</p>\n<h2 id=\"尾巴\"><a href=\"#尾巴\" class=\"headerlink\" title=\"尾巴\"></a>尾巴</h2><p>上面的原理是借鉴了<code>react-redux@7</code>中的实现，使用一个forceUpdate去触发re-render，但在<code>@8-beta</code>中，useSelector直接使用了React18提供的<code>useSyncExternalStore</code>api去做这件事，关于这个api可以在<a href=\"https://www.zhihu.com/question/502917860\">这里</a>了解一下。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://medium.com/async/how-useselector-can-trigger-an-update-only-when-we-want-it-to-a8d92306f559\">How useSelector can trigger an update only when we want it to</a></p>\n<p><a href=\"https://react-redux.js.org/api/hooks\">React Redux Doc: Hooks</a></p>\n<p><a href=\"https://github.com/reduxjs/react-redux\">react-redux</a></p>\n<p><a href=\"https://github.com/reduxjs/redux\">redux</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckv5ff35t0001xgepaegu0pvk","category_id":"ckv5ff35w0002xgep6dqgdmdf","_id":"ckv5ff35y0005xgep88939b19"},{"post_id":"ckyo4lu6i0000nz6973jf9sth","category_id":"ckv5ff35w0002xgep6dqgdmdf","_id":"ckyo4lu6o0006nz695zbm6glk"},{"post_id":"ckyo4lu6k0001nz692p6jg09c","category_id":"ckv5ff35w0002xgep6dqgdmdf","_id":"ckyo4lu6p0009nz69bq0xbl0j"},{"post_id":"ckyo4lu6o0008nz696ewge9pz","category_id":"ckv5ff35w0002xgep6dqgdmdf","_id":"ckyo4lu6s000fnz69534o0dod"},{"post_id":"ckyo4lu6l0003nz69fspg7s6k","category_id":"ckyo4lu6o0007nz69hfpn4go2","_id":"ckyo4lu6s000jnz69cdxy7mkb"},{"post_id":"ckyo4lu6n0005nz6925a4df9f","category_id":"ckyo4lu6o0007nz69hfpn4go2","_id":"ckyo4lu6t000mnz695bts5ktq"},{"post_id":"ckyo4lu6q000anz69168hh4v4","category_id":"ckyo4lu6s000inz69dhnu091e","_id":"ckyo4lu6t000qnz696elq17lg"},{"post_id":"ckyo4lu6z000znz69awtr7b95","category_id":"ckyo4lu6s000inz69dhnu091e","_id":"ckyo4lu710015nz697his3v66"},{"post_id":"ckyo4lu6z0010nz6937uzel7u","category_id":"ckyo4lu6s000inz69dhnu091e","_id":"ckyo4lu710016nz69b2s4e3u2"},{"post_id":"ckyo4lu700012nz69b6lmhc2h","category_id":"ckv5ff35w0002xgep6dqgdmdf","_id":"ckyo4lu720018nz6906m92iit"},{"post_id":"ckzgq58r80000o969hgrbefc5","category_id":"ckzgq58re0001o9691t7x1mqq","_id":"ckzgq58rj0005o969fs91fkfl"},{"post_id":"cmbq19nxn0000rq9k3q10f8v5","category_id":"ckyo4lu6o0007nz69hfpn4go2","_id":"cmbq19nxp0002rq9k9mkqbzck"}],"PostTag":[{"post_id":"ckv5ff35t0001xgepaegu0pvk","tag_id":"ckv5ff35x0003xgep5x6a5kem","_id":"ckv5ff35y0004xgepe03tfso6"},{"post_id":"ckyo4lu6i0000nz6973jf9sth","tag_id":"ckv5ff35x0003xgep5x6a5kem","_id":"ckyo4lu6l0002nz6993fi6pqb"},{"post_id":"ckyo4lu6o0008nz696ewge9pz","tag_id":"ckv5ff35x0003xgep5x6a5kem","_id":"ckyo4lu6q000cnz693fm7cp6v"},{"post_id":"ckyo4lu6o0008nz696ewge9pz","tag_id":"ckyo4lu6m0004nz691m0ocxuq","_id":"ckyo4lu6r000enz69f9k30j62"},{"post_id":"ckyo4lu6k0001nz692p6jg09c","tag_id":"ckv5ff35x0003xgep5x6a5kem","_id":"ckyo4lu6s000hnz69fxixb06q"},{"post_id":"ckyo4lu6k0001nz692p6jg09c","tag_id":"ckyo4lu6m0004nz691m0ocxuq","_id":"ckyo4lu6s000knz69aawo6uw0"},{"post_id":"ckyo4lu6l0003nz69fspg7s6k","tag_id":"ckv5ff35x0003xgep5x6a5kem","_id":"ckyo4lu6t000nnz69bnkh67m7"},{"post_id":"ckyo4lu6l0003nz69fspg7s6k","tag_id":"ckyo4lu6q000bnz6905l37vey","_id":"ckyo4lu6t000onz69cwb69n6b"},{"post_id":"ckyo4lu6l0003nz69fspg7s6k","tag_id":"ckyo4lu6s000gnz69h9xs6mri","_id":"ckyo4lu6t000rnz69dikzgtco"},{"post_id":"ckyo4lu6n0005nz6925a4df9f","tag_id":"ckv5ff35x0003xgep5x6a5kem","_id":"ckyo4lu6w000tnz690zwt76sg"},{"post_id":"ckyo4lu6n0005nz6925a4df9f","tag_id":"ckyo4lu6q000bnz6905l37vey","_id":"ckyo4lu6w000unz69d9j2ek9n"},{"post_id":"ckyo4lu6n0005nz6925a4df9f","tag_id":"ckyo4lu6s000gnz69h9xs6mri","_id":"ckyo4lu6x000wnz693h9ianip"},{"post_id":"ckyo4lu6q000anz69168hh4v4","tag_id":"ckyo4lu6t000snz69fq7hg1sw","_id":"ckyo4lu6x000xnz698xoh8s8d"},{"post_id":"ckyo4lu6q000anz69168hh4v4","tag_id":"ckyo4lu6w000vnz69azcd3wnz","_id":"ckyo4lu6x000ynz698aw6bjvp"},{"post_id":"ckyo4lu6z000znz69awtr7b95","tag_id":"ckyo4lu6t000snz69fq7hg1sw","_id":"ckyo4lu700011nz69drmp0ujj"},{"post_id":"ckyo4lu6z000znz69awtr7b95","tag_id":"ckyo4lu6w000vnz69azcd3wnz","_id":"ckyo4lu710014nz69avwh9ygb"},{"post_id":"ckyo4lu6z0010nz6937uzel7u","tag_id":"ckv5ff35x0003xgep5x6a5kem","_id":"ckyo4lu72001anz69026yeiu0"},{"post_id":"ckyo4lu6z0010nz6937uzel7u","tag_id":"ckyo4lu700013nz69gl2vhesc","_id":"ckyo4lu72001bnz694eu2dd9l"},{"post_id":"ckyo4lu6z0010nz6937uzel7u","tag_id":"ckyo4lu720017nz695chkgzda","_id":"ckyo4lu72001dnz69crjzgjfg"},{"post_id":"ckyo4lu700012nz69b6lmhc2h","tag_id":"ckv5ff35x0003xgep5x6a5kem","_id":"ckyo4lu73001enz69d0f76hdq"},{"post_id":"ckyo4lu700012nz69b6lmhc2h","tag_id":"ckyo4lu700013nz69gl2vhesc","_id":"ckyo4lu73001fnz6992usb8fy"},{"post_id":"ckyo4lu700012nz69b6lmhc2h","tag_id":"ckyo4lu72001cnz69780lgt8l","_id":"ckyo4lu73001gnz69djmhaerz"},{"post_id":"ckzgq58r80000o969hgrbefc5","tag_id":"ckzgq58rh0002o9696t0l8yx4","_id":"ckzgq58rj0003o969eehp20pg"},{"post_id":"ckzgq58r80000o969hgrbefc5","tag_id":"ckyo4lu6s000gnz69h9xs6mri","_id":"ckzgq58rj0004o9695soqgmwh"},{"post_id":"cmbq19nxn0000rq9k3q10f8v5","tag_id":"cmbq19nxo0001rq9k2vpcataw","_id":"cmbq19nxp0003rq9k1m5n5b4s"}],"Tag":[{"name":"JavaScript","_id":"ckv5ff35x0003xgep5x6a5kem"},{"name":"异步编程","_id":"ckyo4lu6m0004nz691m0ocxuq"},{"name":"Babel","_id":"ckyo4lu6q000bnz6905l37vey"},{"name":"前端工程化","_id":"ckyo4lu6s000gnz69h9xs6mri"},{"name":"Vue","_id":"ckyo4lu6t000snz69fq7hg1sw"},{"name":"Webpack","_id":"ckyo4lu6w000vnz69azcd3wnz"},{"name":"http","_id":"ckyo4lu700013nz69gl2vhesc"},{"name":"NodeJs","_id":"ckyo4lu720017nz695chkgzda"},{"name":"浏览器","_id":"ckyo4lu72001cnz69780lgt8l"},{"name":"hexo","_id":"ckzgq58rh0002o9696t0l8yx4"},{"name":"redux","_id":"cmbq19nxo0001rq9k2vpcataw"}]}}